<!DOCTYPE html>
<html lang="en" data-theme="dark">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, shrink-to-fit=no">

    <title>Trailblazer - Activity</title>

    <script src="/vite-dev/@vite/client" type="module"></script>
    <script src="/vite-dev/entrypoints/documentation.js" crossorigin="anonymous" type="module"></script>

    <link
      href="https://fonts.googleapis.com/css?family=Raleway:200,300,400,500,600,700,800"
      rel="stylesheet"
    >
    <link
      href="https://fonts.googleapis.com/icon?family=Material+Icons"
      rel="stylesheet"
    >
    <link
      rel="preconnect"
      href="https://R2IYF7ETH7-dsn.algolia.net" crossorigin
    >
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/@docsearch/css@3"
    >

    

    <link rel="icon" type="image/png" sizes="32x32" href="/vite-dev/images/favicon.ico">
  </head>
  <body>
    <div class="alert alert-primary m-0 rounded-0 text-center" role="alert">
      <span class="alert-text text-center">
        <!-- The new TRB 2.1 book series has begun - 82 pages are <a class="alert-link" href="https://leanpub.com/buildalib">waiting for you</a>! -->
        Dear Russian friends, please watch President Zelenskyy's
        <a href="https://twitter.com/PMoelleken/status/1496941845812760577">speech addressed to you</a>.
        üá∫üá¶ Help our brave mates in Ukraine
        <a
          href="https://actions.sumofus.org/a/give-to-ukrainians-who-need-an-urgent-lifeline"
        >
          with a donation
        </a>.
      </span>
    </div>

    <div class="lg-bg">
      <!-- Add class="session-show" if you need a header with dark background -->
      <header
        id="header"
        class="trailblazer-header documentation-navbar navbar navbar-expand-lg flex-column flex-md-row"
      >
        <h1 class="m-2">
          <a class="navbar-brand mr-0 mr-md-2" href="/2.1/index.html">Trailblazer</a>
        </h1>

        <div class="navbar-nav-scroll ml-md-auto">
          <ul class="navbar-nav documentation-nav-items">
  <li>
    <a class="nav-item nav-link active" href="/2.1/docs/trailblazer.html">
      <i class="fas fa-arrow-right"></i>
      DOCS
    </a>
  </li>

  <li>
    <a class="nav-item nav-link " href="https://dev.to/trailblazer">BLOG</a>
  </li>

  <li class="d-none d-md-block">
    <a class="nav-item nav-link " href="/2.1/about_us.html">ABOUT US</a>
  </li>

  <li>
    <a class="nav-item nav-link " href="/2.1/learn.html">LEARN</a>
  </li>

  <li class="d-none d-md-block">
    <a class="nav-item nav-link" href="/2.0/index.html">
      <i class="fas fa-arrow-right"></i>
      2.0
    </a>
  </li>

  <li>
    <a class="nav-item nav-link" href="https://trailblazer.zulipchat.com" target="_blank">
      <i class="fas fa-comments"></i>
      CHAT
    </a>
  </li>

  <!--
  
    <li>
      <div id="docsearch"></div> https://docsearch.algolia.com/docs/DocSearch-v3
    </li>
  
  -->
</ul>

        </div>
      </header>

      <main>
        <section class="documentation-main">
          <div class="container-fluid">
            <div class="row flex-xl-nowrap">
              <div class="col-md-3 col-xl-2 border-bottom order-1 sidebar-accordion sidebar-scroll">
                <form class="d-md-none d-flex align-items-center position-relative py-3 mx-n3 border-bottom">
                  <button
                    class="navbar-toggler collapsed"
                    type="button"
                    data-toggle="collapse"
                    data-target="#navBarTrailBlazer"
                    aria-controls="navBarTrailBlazer"
                    aria-expanded="false"
                    aria-label="Toggle navigation"
                  >
                    <i class="far fa-lg fa-bars"></i>
                  </button>
                </form>
                <div class="collapse d-md-block py-3 mx-n3" id="navBarTrailBlazer">
                  <div class="border-bottom">
  <div class="my-4">
    <div class="sidebar-accordion-wrapper">
  <div id="trailblazer">
    <h2 class="mb-0 mt-1 sidebar-accordion-item">
      <a href="/2.1/docs/trailblazer.html">
        <button
          class="collapsed"
          data-toggle="collapse"
          data-target="#trailblazer-collapse"
          aria-expanded="false"
          aria-controls="trailblazer-collapse"
        >
          <i class="fas fa-chevron-right"></i>
          <i class="fas fa-times"></i>
          <span>Trailblazer</span>
        </button>
      </a>
    </h2>
  </div>

  
</div>

<div class="sidebar-accordion-wrapper">
  <div id="rails-integration">
    <h2 class="mb-0 mt-1 sidebar-accordion-item">
      <a href="/2.1/docs/rails.html">
        <button
          class="collapsed"
          data-toggle="collapse"
          data-target="#rails-integration-collapse"
          aria-expanded="false"
          aria-controls="rails-integration-collapse"
        >
          <i class="fas fa-chevron-right"></i>
          <i class="fas fa-times"></i>
          <span>Rails Integration</span>
        </button>
      </a>
    </h2>
  </div>

  
</div>

<div class="sidebar-accordion-wrapper">
  <div id="test">
    <h2 class="mb-0 mt-1 sidebar-accordion-item">
      <a href="/2.1/docs/test.html">
        <button
          class="collapsed"
          data-toggle="collapse"
          data-target="#test-collapse"
          aria-expanded="false"
          aria-controls="test-collapse"
        >
          <i class="fas fa-chevron-right"></i>
          <i class="fas fa-times"></i>
          <span>Test</span>
        </button>
      </a>
    </h2>
  </div>

  
</div>

  </div>
</div>

<div class="border-bottom">
  <div class="my-4">
    <div class="sidebar-accordion-wrapper">
  <div id="activity">
    <h2 class="mb-0 mt-1 sidebar-accordion-item">
      <a href="/2.1/docs/activity.html">
        <button
          class=""
          data-toggle="collapse"
          data-target="#activity-collapse"
          aria-expanded="true"
          aria-controls="activity-collapse"
        >
          <i class="fas fa-chevron-right"></i>
          <i class="fas fa-times"></i>
          <span>Activity</span>
        </button>
      </a>
    </h2>
  </div>

  
    <div
      id="activity-collapse"
      class="collapse show"
      aria-labelledby="activity"
      data-parent="#accordion"
    >
      <ul class="nav vertical menu navbar-light">
        
          <li class="nav-item">
            <a class="nav-link active" href="#activity-overview">
              Overview
            </a>
          </li>
        
          <li class="nav-item">
            <a class="nav-link " href="#activity-strategy">
              STRATEGY
            </a>
          </li>
        
          <li class="nav-item">
            <a class="nav-link " href="#activity-wiring-api">
              Wiring API
            </a>
          </li>
        
          <li class="nav-item">
            <a class="nav-link " href="#activity-dsl-options">
              DSL Options
            </a>
          </li>
        
          <li class="nav-item">
            <a class="nav-link " href="#activity-variable-mapping">
              Variable Mapping
            </a>
          </li>
        
          <li class="nav-item">
            <a class="nav-link " href="#activity-dependency-injection">
              Dependency Injection
            </a>
          </li>
        
          <li class="nav-item">
            <a class="nav-link " href="#activity-macro-api">
              Macro API
            </a>
          </li>
        
          <li class="nav-item">
            <a class="nav-link " href="#activity-internals">
              Internals
            </a>
          </li>
        
          <li class="nav-item">
            <a class="nav-link " href="#activity-taskwrap">
              TaskWrap
            </a>
          </li>
        
          <li class="nav-item">
            <a class="nav-link " href="#activity-troubleshooting">
              Troubleshooting
            </a>
          </li>
        
      </ul>
    </div>
  
</div>

<div class="sidebar-accordion-wrapper">
  <div id="macro">
    <h2 class="mb-0 mt-1 sidebar-accordion-item">
      <a href="/2.1/docs/macro.html">
        <button
          class="collapsed"
          data-toggle="collapse"
          data-target="#macro-collapse"
          aria-expanded="false"
          aria-controls="macro-collapse"
        >
          <i class="fas fa-chevron-right"></i>
          <i class="fas fa-times"></i>
          <span>Macro</span>
        </button>
      </a>
    </h2>
  </div>

  
</div>

<div class="sidebar-accordion-wrapper">
  <div id="operation">
    <h2 class="mb-0 mt-1 sidebar-accordion-item">
      <a href="/2.1/docs/operation.html">
        <button
          class="collapsed"
          data-toggle="collapse"
          data-target="#operation-collapse"
          aria-expanded="false"
          aria-controls="operation-collapse"
        >
          <i class="fas fa-chevron-right"></i>
          <i class="fas fa-times"></i>
          <span>Operation</span>
        </button>
      </a>
    </h2>
  </div>

  
</div>

<div class="sidebar-accordion-wrapper">
  <div id="workflow">
    <h2 class="mb-0 mt-1 sidebar-accordion-item">
      <a href="/2.1/docs/workflow.html">
        <button
          class="collapsed"
          data-toggle="collapse"
          data-target="#workflow-collapse"
          aria-expanded="false"
          aria-controls="workflow-collapse"
        >
          <i class="fas fa-chevron-right"></i>
          <i class="fas fa-times"></i>
          <span>Workflow</span>
        </button>
      </a>
    </h2>
  </div>

  
</div>

<div class="sidebar-accordion-wrapper">
  <div id="endpoint">
    <h2 class="mb-0 mt-1 sidebar-accordion-item">
      <a href="/2.1/docs/endpoint.html">
        <button
          class="collapsed"
          data-toggle="collapse"
          data-target="#endpoint-collapse"
          aria-expanded="false"
          aria-controls="endpoint-collapse"
        >
          <i class="fas fa-chevron-right"></i>
          <i class="fas fa-times"></i>
          <span>Endpoint</span>
        </button>
      </a>
    </h2>
  </div>

  
</div>

  </div>
</div>

<div class="border-bottom">
  <div class="my-4">
    <div class="sidebar-accordion-wrapper">
  <div id="reform">
    <h2 class="mb-0 mt-1 sidebar-accordion-item">
      <a href="/2.1/docs/reform.html">
        <button
          class="collapsed"
          data-toggle="collapse"
          data-target="#reform-collapse"
          aria-expanded="false"
          aria-controls="reform-collapse"
        >
          <i class="fas fa-chevron-right"></i>
          <i class="fas fa-times"></i>
          <span>Reform</span>
        </button>
      </a>
    </h2>
  </div>

  
</div>

<div class="sidebar-accordion-wrapper">
  <div id="cells">
    <h2 class="mb-0 mt-1 sidebar-accordion-item">
      <a href="/2.1/docs/cells.html">
        <button
          class="collapsed"
          data-toggle="collapse"
          data-target="#cells-collapse"
          aria-expanded="false"
          aria-controls="cells-collapse"
        >
          <i class="fas fa-chevron-right"></i>
          <i class="fas fa-times"></i>
          <span>Cells</span>
        </button>
      </a>
    </h2>
  </div>

  
</div>

<div class="sidebar-accordion-wrapper">
  <div id="representable">
    <h2 class="mb-0 mt-1 sidebar-accordion-item">
      <a href="/2.1/docs/representable.html">
        <button
          class="collapsed"
          data-toggle="collapse"
          data-target="#representable-collapse"
          aria-expanded="false"
          aria-controls="representable-collapse"
        >
          <i class="fas fa-chevron-right"></i>
          <i class="fas fa-times"></i>
          <span>Representable</span>
        </button>
      </a>
    </h2>
  </div>

  
</div>

<div class="sidebar-accordion-wrapper">
  <div id="disposable">
    <h2 class="mb-0 mt-1 sidebar-accordion-item">
      <a href="/2.1/docs/disposable.html">
        <button
          class="collapsed"
          data-toggle="collapse"
          data-target="#disposable-collapse"
          aria-expanded="false"
          aria-controls="disposable-collapse"
        >
          <i class="fas fa-chevron-right"></i>
          <i class="fas fa-times"></i>
          <span>Disposable</span>
        </button>
      </a>
    </h2>
  </div>

  
</div>

<div class="sidebar-accordion-wrapper">
  <div id="roar">
    <h2 class="mb-0 mt-1 sidebar-accordion-item">
      <a href="/2.1/docs/roar.html">
        <button
          class="collapsed"
          data-toggle="collapse"
          data-target="#roar-collapse"
          aria-expanded="false"
          aria-controls="roar-collapse"
        >
          <i class="fas fa-chevron-right"></i>
          <i class="fas fa-times"></i>
          <span>Roar</span>
        </button>
      </a>
    </h2>
  </div>

  
</div>

  </div>
</div>

<div class="border-bottom">
  <div class="my-4">
    <div class="sidebar-accordion-wrapper">
  <div id="tutorials">
    <h2 class="mb-0 mt-1 sidebar-accordion-item">
      <a href="/2.1/docs/tutorials/activity.html">
        <button
          class="collapsed"
          data-toggle="collapse"
          data-target="#tutorials-collapse"
          aria-expanded="false"
          aria-controls="tutorials-collapse"
        >
          <i class="fas fa-chevron-right"></i>
          <i class="fas fa-times"></i>
          <span>Tutorials</span>
        </button>
      </a>
    </h2>
  </div>

  
</div>

<div class="sidebar-accordion-wrapper">
  <div id="pro">
    <h2 class="mb-0 mt-1 sidebar-accordion-item">
      <a href="/2.1/docs/pro.html">
        <button
          class="collapsed"
          data-toggle="collapse"
          data-target="#pro-collapse"
          aria-expanded="false"
          aria-controls="pro-collapse"
        >
          <i class="fas fa-chevron-right"></i>
          <i class="fas fa-times"></i>
          <span>PRO</span>
        </button>
      </a>
    </h2>
  </div>

  
</div>

  </div>
</div>

                </div>
              </div>

              <main
                class="col-md-9 col-xl-8 py-md-5 pl-md-5 order-2"
                role="main"
              >
                <div class="doc-block section-name session-show">
                  <h1 class="w-100">Activity</h1>
                  <ul>
                    <li>
                      <i class="far fa-clock pink"></i>
                      <span>Last updated 29 Aug 22</span>
                    </li>
                  </ul>
                </div>

                <div class="doc-block">
<p><span class="divider"></span></p>

<h2 id="activity-overview">Overview</h2>
<p><!-- {activity-overview-toc} --></p>

<p>An activity is an executable <em>circuit</em> of tasks. Each task is arbitrary Ruby code, usually encapsulated in a callable object. Depending on its return value and its outgoing connections, the next task to invoke is picked.</p>

<p>Activities are tremendously helpful for modelling and implementing any kind of logic and any level of complexity. They‚Äôre useful for a hash merge algorithm, an application‚Äôs function to validate form data and update models with it, or for implementing long-running business workflows that drive entire application lifecycles.</p>

<div class="bd-callout bd-callout-info">
<p>The <code>activity</code> gem is an extraction from Trailblazer 2.0, where we only had operations. Operations expose a linear flow which goes into one direction, only. While this was a massive improvement over messily nested code, we soon decided it‚Äôs cool being able to model non-linear flows. This is why activities are the major concept since Trailblazer 2.1.</p>
</div>

<p><span class="divider"></span></p>

<h3 id="activity-overview-anatomy">Anatomy</h3>
<p><!-- {activity-overview-anatomy-toc} --></p>

<p>To understand the mechanics behind Trailblazer‚Äôs activities, you need to know a few simple concepts.</p>

<ol>
  <li>An <strong>activity</strong> is a circuit of tasks - boxes being connected by arrows.</li>
  <li>It has one <strong>start</strong> and at least one <strong>end event</strong>. Those are the circles in the diagrams.</li>
  <li>A <strong>task</strong> is a unit of business logic. They‚Äôre visualized as boxes. This is where your code goes!</li>
  <li>Each task has one or more <strong>outputs</strong>. From one particular output you can draw one connecting line to the next task.</li>
  <li>An output is triggered by a <strong>signal</strong>. The last line in a task usually decides what output to pick, and that happens by <code>return</code>ing a specific object, a signal.</li>
  <li>Besides the signal, a <strong>semantic</strong> is assigned to an output. This is a completely arbitrary ‚Äúmeaning‚Äù. In Trailblazer, we use <code>success</code> and <code>failure</code> as conventional semantics.</li>
  <li>In a railway activity, for instance, the ‚Äúfailure‚Äù and ‚Äúsuccess‚Äù track mean nothing more than following the <code>failure</code> or <code>success</code>-labeled outputs. That‚Äôs a <strong>track</strong>.</li>
</ol>

<p>Activities can be visualized neatly by taking advantage of the BPMN specification.</p>

<p><img class="mx-auto d-block" src="/vite-dev/images/intermediate.webp" /></p>

<p>Well, this is not entirely BPMN, but you get the idea. Intuitively, you understand that the tasks <code>B</code> and <code>C</code> have only one outcome, whereas <code>A</code> yields two possible results. This works by adding two <em>outputs</em> to <code>A</code>.</p>

<p>An output is a combination of a <em>semantic</em> and a <em>signal</em>. A part of the return value of the invoked task is interpreted as a signal, and that‚Äôs how Trailblazer picks the connection to the next task to take.</p>

<p>Depending on <code>A</code>‚Äôs‚Äô returned signal (yet to be defined), the flow will continue on its <code>success</code> or <code>failure</code> connection. It‚Äôs completely up to the modelling developer what names they choose for semantics, and how many outputs they need. Nevertheless, for binary outputs we usually take <code>success</code> and <code>failure</code> as meaningful semantics.</p>

<p><span class="divider"></span></p>

<h3 id="activity-overview-dsl">DSL</h3>
<p><!-- {activity-overview-dsl-toc} --></p>

<p>To implement our activity, we can use Activity‚Äôs DSL.</p>

<div class="bd-callout bd-callout-info">
<p>To demonstrate the concepts of an activity, we make use of the DSL. This simplifies defining activities. However, keep in mind that you‚Äôre free to build activities using the PRO editor, with your own DSL or with our [low-level API].</p>
</div>

<pre><code>class Upsert &lt; Trailblazer::Activity::Path
  step :find_model, Output(Trailblazer::Activity::Left, :failure) =&gt; Id(:create)
  step :update
  step :create, magnetic_to: nil, Output(Trailblazer::Activity::Right, :success) =&gt; Id(:update)

  # ...
end
</code></pre>

<p>The <code>Activity::Path</code> class is the simplest DSL strategy. It automatically connects each <code>step</code> to the previous one, unless you use the <code>:magnetic_to</code> option. In our case, this is necessary to connect <code>#find</code> (A) to <code>#create</code> (C). The <code>Output</code> method helps to define what signal and semantic an output has, and using <code>Id</code> you can point those to a specific neighbor task.</p>

<p>If unsure, use the [developer tools] to render the circuit.</p>

<pre><code>Trailblazer::Developer.render(A::Upsert)
</code></pre>

<p>Alternatively, use the PRO editor tools.</p>

<p><span class="divider"></span></p>

<h3 id="activity-overview-invocation">Invocation</h3>
<p><!-- {activity-overview-invocation-toc} --></p>

<p>Before you can use your activity, the tasks need to be written. Using the [task interface] this is pretty straight-forward. Note that you can return either a boolean value or a [signal subclass] in order to dictate the direction of flow.</p>

<pre><code>class Upsert &lt; Trailblazer::Activity::Path
  # ...

  def find_model(ctx, id:, **) # A
    ctx[:memo] = Memo.find(id)
    ctx[:memo] ? Trailblazer::Activity::Right : Trailblazer::Activity::Left # can be omitted.
  end

  def update(ctx, params:, **) # B
    ctx[:memo].update(**params)
    true # can be omitted
  end

  def create(ctx, **)
    ctx[:memo] = Memo.new
  end
end
</code></pre>

<div class="bd-callout bd-callout-info">
<p>You don‚Äôt have to stick to the task interface! The [circuit interface] is a bit more clumsy, but gives you much better control over how ctx and signals are handled.</p>
</div>

<p>To run your activity, use its <code>call</code> method. <code>Activity</code>s always use the [circuit interface].</p>

<pre><code>ctx = {id: 1, params: {text: "Hydrate!"}}

signal, (ctx, flow_options) = A::Upsert.([ctx, {}])
</code></pre>

<p>The <code>ctx</code> will be whatever the most recently executed task returned, and hopefully contain what you‚Äôre expecting.</p>

<pre><code># FIXME
</code></pre>

<p>After this brief introduction, you should check out how [nesting] of activities will help you, what [operations] are, and what awesome debugging tools such as [tracing] we provide.</p>

<p><code>:activity</code> is guaranteed to match the currently invoked activity</p>

<p><span class="divider"></span></p>

<h2 id="activity-strategy">STRATEGY</h2>
<p><!-- {activity-strategy-toc} --></p>

<p><span class="divider"></span></p>

<h3 id="activity-strategy-path">Path</h3>
<p><!-- {activity-strategy-path-toc} --></p>

<p>The simplest strategy is <code>Path</code>, which does nothing but connecting each task‚Äôs <code>:success</code> output to the following task.</p>

<pre><code>class Create &lt; Trailblazer::Activity::Path
  step :validate
  step :create
  # ...
end
</code></pre>

<p>Without any additional DSL options, this results in a straight path.</p>

<p><img class="mx-auto d-block" src="/vite-dev/images/path.webp" /></p>

<p>In turn, this means that only <code>true</code> return values in your tasks will work. The DSL will, per default, wrap every task with the <code>Binary</code> interface, meaning returning <code>true</code> will result in <code>Activity::Right</code>, and false in <code>Activity::Left</code>. Currently, only <code>Right</code> signals are wired up.</p>

<p><span class="divider"></span></p>

<ul class="navigation">
    <li>Path</li>
    <li id="activity-strategy-path-output">Output</li>
</ul>

<p>You may add as many outputs to a task as you need. The DSL provides the <code>Output()</code> helper to do so.</p>

<pre><code>class Create &lt; Trailblazer::Activity::Path
  step :validate, Output(Trailblazer::Activity::Left, :failure) =&gt; End(:invalid)
  step :create
  # ...
end
</code></pre>

<p>The <code>Path</code> strategy only maintains the <code>:success</code>/<code>Activity::Right</code> semantic/signal combination. Any other combination you need to define explicitly using <code>Output(signal, semantic)</code>.</p>

<p><span class="divider"></span></p>

<ul class="navigation">
    <li>Path</li>
    <li id="activity-strategy-path-end">End</li>
</ul>

<p>The <code>End()</code> helper allows creating a new end event labelled with the specified semantic.</p>

<pre><code>class Create &lt; Trailblazer::Activity::Path
  step :validate, Output(Trailblazer::Activity::Left, :failure) =&gt; End(:invalid)
  step :create
  # ...
end
</code></pre>

<p>This will result in the following circuit.</p>

<p><img class="mx-auto d-block" src="/vite-dev/images/path-end.webp" /></p>

<p>The <code>validate</code> task now has a <code>success</code> and a <code>failure</code> output. Since it‚Äôs wrapped using <code>Binary</code> it may return <code>true</code> or <code>false</code> to dictate the used output (or <code>Activity::Right</code>/<code>Activity::Left</code> since it‚Äôs the [task interface]).</p>

<pre><code>class Create &lt; Trailblazer::Activity::Path
  # ...
  def validate(ctx, params:, **)
    ctx[:input] = Form.validate(params) # true/false
  end

  def create(ctx, input:, **)
    Memo.create(input)
  end
end
</code></pre>

<p>The activity will halt on the <code>:invalid</code>-labelled end if <code>validate</code> was falsey.</p>

<pre><code>ctx = {params: nil}
signal, (ctx, flow_options) = Memo::Create.([ctx, {}])

puts signal #=&gt; #&lt;Trailblazer::Activity::End semantic=:invalid&gt;
</code></pre>

<p><span class="divider"></span></p>

<ul class="navigation">
    <li>Path</li>
    <li id="activity-strategy-path-multiple-references">Multiple References</li>
</ul>

<p>Note that repeatedly using the same semantic (<code>End(:semantic)</code>) will reference the same end event.</p>

<pre><code>class Create &lt; Trailblazer::Activity::Path
  step :validate, Output(Trailblazer::Activity::Left, :failure) =&gt; End(:invalid)
  step :create,   Output(Trailblazer::Activity::Left, :failure) =&gt; End(:invalid)
  # ...
end
</code></pre>

<p>Since we‚Äôre adding a <code>:failure</code> output, <code>create</code> now has two outgoing connections.</p>

<p><img class="mx-auto d-block" src="/vite-dev/images/double-end.webp" /></p>

<p><span class="divider"></span></p>

<h3 id="activity-strategy-railway">Railway</h3>
<p><!-- {activity-strategy-railway-toc} --></p>

<p>The <a href="http://fsharpforfunandprofit.com/rop/"><code>Railway</code> pattern</a> is used for ‚Äúautomatic‚Äù error handling. You arrange your actual chain of logic on the ‚Äúsuccess‚Äù track, if a problem occurs, the processing jumps to the parallel ‚Äúfailure‚Äù track, skipping the rest of the tasks on the success track.</p>

<p>Once on the failure track, it stays there (unless you instruct not to do so!).</p>

<p><img class="mx-auto d-block" src="/vite-dev/images/railway.webp" /></p>

<p>Three possible execution paths this activity might take.</p>

<ul>
  <li>No errors: First <code>validate</code>, then <code>create</code>, then ends in <code>End.success</code>. The activity was successful.</li>
  <li>Validation error: First <code>validate</code>, which returns a <code>Left</code> (failure) signal, leading to <code>log_error</code>, then <code>End.failure</code>.</li>
  <li>Creation error: First <code>validate</code>, then <code>create</code>, which deviates to the failure track, leading to <code>End.failure</code>. Note this doesn‚Äôt hit the logging error handler due to the sequence order.</li>
</ul>

<p>To place tasks on the failure track, use <code>#fail</code>. Note that the order of tasks corresponds to the order in the Railway.</p>

<pre><code>class Create &lt; Trailblazer::Activity::Railway
  step :validate
  fail :log_error
  step :create
  # ...
end
</code></pre>

<p>Obviously, you may use as many tasks as you need on both tracks. There are no limitations.</p>

<div class="bd-callout bd-callout-info">
<p>Historically, the success path is called ‚Äúright‚Äù whereas the error handling track is ‚Äúleft‚Äù. The signals <code>Right</code> and <code>Left</code> in Trailblazer are still named following this convention.</p>
</div>

<p><span class="divider"></span></p>

<ul class="navigation">
    <li>Railway</li>
    <li id="activity-strategy-railway-wiring">Wiring</li>
</ul>

<p>All wiring features apply to <code>Railway</code>. You can rewire, add or remove connections as you please.</p>

<pre><code>class Create &lt; Trailblazer::Activity::Railway
  step :validate
  fail :log_error
  step :create, Output(:failure) =&gt; End(:db_error)
  # ...
end
</code></pre>

<p>Railway automatically connects a task‚Äôs <code>success</code> output to the next possible task available on the success track. Vice-verse, the <code>failure</code> output is connected the the new possible task on the failure path.</p>

<p>Here, <code>create</code>‚Äôs failure output is reconnected.</p>

<p><img class="mx-auto d-block" src="/vite-dev/images/railway-wire.webp" /></p>

<p><span class="divider"></span></p>

<ul class="navigation">
    <li>Railway</li>
    <li id="activity-strategy-railway-fail">Fail</li>
</ul>

<p>DSL‚Äôs <code>#fail</code> method allows to place tasks on the failure track.</p>

<p>Such error handlers are still wrapped using <code>Binary</code>. In other words, they can still return a <code>Right</code> or <code>Left</code> signal. However, per default, both outputs are connected to the next task on the failure track.</p>

<p>You may rewire or add outputs on failure tasks, too.</p>

<pre><code>class Create &lt; Trailblazer::Activity::Railway
  step :validate
  fail :log_error, Output(:success) =&gt; Track(:success)
  step :create
  # ...
end
</code></pre>

<p>For instance, it‚Äôs possible to jump back to the success path if <code>log_error</code> decides to do so.</p>

<p><img class="mx-auto d-block" src="/vite-dev/images/railway-fail.webp" /></p>

<p>The return value of <code>log_error</code> now does matter.</p>

<pre><code>class Create &lt; Trailblazer::Activity::Railway
  # ...

  def log_error(_ctx, logger:, params:, **)
    logger.error("wrong params: #{params.inspect}")

    fixable?(params) ? true : false # or Activity::Right : Activity::Left
  end
end
</code></pre>

<p><span class="divider"></span></p>

<ul class="navigation">
    <li>Railway</li>
    <li id="activity-strategy-railway-pass">Pass</li>
</ul>

<p>If the return value of a ‚Äúright‚Äù task shouldn‚Äôt matter, use <code>#pass</code>.</p>

<pre><code>class Create &lt; Trailblazer::Activity::Railway
  step :validate
  fail :log_error
  pass :create
  # ...
end
</code></pre>

<p>Regardless of <code>create</code>‚Äôs return value, it will always flow to the next success task.</p>

<p><img class="mx-auto d-block" src="/vite-dev/images/railway-pass.webp" /></p>

<p>Both outputs are connected to the following task on the success path (or, in this case, the success end).</p>

<p><span class="divider"></span></p>

<ul class="navigation">
    <li>Railway</li>
    <li id="activity-strategy-railway-notes">Notes</li>
</ul>

<p>FIXME</p>

<ul>
  <li>Using <code>Railway</code>, tasks always get two outputs assigned: <code>:success/Right</code> and <code>:failure/Left</code>.</li>
</ul>

<p><span class="divider"></span></p>

<h3 id="activity-strategy-fasttrack">FastTrack</h3>
<p><!-- {activity-strategy-fasttrack-toc} --></p>

<p>Based on the <code>Railway</code> strategy, the <code>FastTrack</code> pattern allows to ‚Äúshort-circuit‚Äù tasks and leave the circuit at specified events.</p>

<div class="bd-callout bd-callout-info">
<p>The infamous <code>Trailblazer::Operation</code> is a thin public API around <code>Activity::FastTrack</code>.</p>
</div>

<p><span class="divider"></span></p>

<ul class="navigation">
    <li>FastTrack</li>
    <li id="activity-strategy-fasttrack-passfast">PassFast</li>
</ul>

<p>The <code>:pass_fast</code> option wires the <code>:success</code> output straight to the new <code>pass_fast</code> end.</p>

<pre><code>class Create &lt; Trailblazer::Activity::FastTrack
  step :validate, pass_fast: true
  fail :log_error
  step :create
  # ...
end
</code></pre>

<p>If <code>validate</code> returns a true value, it will skip the remaining tasks on the success track and end in <code>End.pass_fast</code>.</p>

<p><img class="mx-auto d-block" src="/vite-dev/images/ft-passfast.webp" /></p>

<p>Note that in the example, the <code>create</code> task not accessable anymore.</p>

<p><span class="divider"></span></p>

<ul class="navigation">
    <li>FastTrack</li>
    <li id="activity-strategy-fasttrack-failfast">FailFast</li>
</ul>

<p>The counter-part for <code>:pass_fast</code> is <code>:fail_fast</code>.</p>

<pre><code>class Create &lt; Trailblazer::Activity::FastTrack
  step :validate, fail_fast: true
  fail :log_error
  step :create
  # ...
end
</code></pre>

<p>A falsey return value from <code>#validate</code> will deviate the flow and go straight to <code>End.fail_fast</code>.</p>

<p><img class="mx-auto d-block" src="/vite-dev/images/ft-failfast.webp" /></p>

<p>Again, this specific example renders the <code>log_errors</code> task unreachable.</p>

<p><span class="divider"></span></p>

<ul class="navigation">
    <li>FastTrack</li>
    <li id="activity-strategy-fasttrack-fasttrack">FastTrack</li>
</ul>

<p>It‚Äôs possible to wire a task to the two FastTrack ends <code>End.fail_fast</code> and <code>End.pass_fast</code> in addition to the normal Railway wiring.</p>

<pre><code>class Create &lt; Trailblazer::Activity::FastTrack
  step :validate, fast_track: true
  fail :log_error
  step :create

  def validate(ctx, params:, **)
    begin
      ctx[:input] = Form.validate(params) # true/false
    rescue
      return Trailblazer::Activity::FastTrack::FailFast # signal
    end

    ctx[:input] # true/false
  end

  # ...
end
</code></pre>

<p>The <code>validate</code> task now has four outputs. You can instruct the two new FastTrack outputs by returning either <code>Trailblazer::Activity::FastTrack::FailFast</code> or <code>Trailblazer::Activity::FastTrack::PassFast</code> (see also [returning signals]).</p>

<p>Note that you don‚Äôt have to use both outputs.</p>

<p><img class="mx-auto d-block" src="/vite-dev/images/ft-fasttrack.webp" /></p>

<p>The standard FastTrack setup allows you to communicate and model up to four states from one task.</p>

<p><span class="divider"></span></p>

<ul class="navigation">
    <li>FastTrack</li>
    <li id="activity-strategy-fasttrack-notes">Notes</li>
</ul>

<p>FIXME</p>

<ul>
  <li>All options (<code>:pass_fast</code>, <code>:fail_fast</code> and <code>:fast_track</code>) may be used with <code>step</code>, <code>pass</code> or <code>fail</code>. If in doubt, [render the circuit].</li>
  <li><code>:pass_fast</code> and <code>:fail_fast</code> can be used in combination.</li>
</ul>

<p><span class="divider"></span></p>

<h2 id="activity-wiring-api">Wiring API</h2>
<p><!-- {activity-wiring-api-toc} --></p>

<p>You can use the wiring API to model more complicated flows in activities.</p>

<div class="bd-callout bd-callout-info">
<p>The wiring API is implemented in the [<code>trailblazer-activity-dsl-linear</code> gem].</p>

<p>Feel invited to write your own DSL using our [low-level mechanics], or if your activities get too complex, please use the [visual editor].</p>
</div>

<p>In addition to your friends <code>step</code>, <code>pass</code> and <code>fail</code>, the DSL provides helpers to fine-tune your wiring.</p>

<pre><code>class Execute &lt; Trailblazer::Activity::Railway
  step :find_provider
  step :charge_creditcard
end
</code></pre>

<p>By default, and without additional helpers used, the DSL will connect every <code>step</code> task‚Äôs two outputs to the two respective tracks of a ‚Äúrailway‚Äù.</p>

<p><img class="mx-auto d-block" src="/vite-dev/images/wire-output.webp" /></p>

<p><span class="divider"></span></p>

<h3 id="activity-wiring-api-output-">Output()</h3>
<p><!-- {activity-wiring-api-output--toc} --></p>

<p>The <code>Output()</code> method helps to rewire one or more specific outputs of a task, or to add outputs.</p>

<p>To understand this helper, you should understand that every <code>step</code> invocation calls <code>Output()</code> for you behind the scenes. The following DSL use is identical to the one [above].</p>

<pre><code>class Execute &lt; Trailblazer::Activity::Railway
  step :find_provider,
    Output(Trailblazer::Activity::Left, :failure) =&gt; Track(:failure),
    Output(Trailblazer::Activity::Right, :success) =&gt; Track(:success)
  step :charge_creditcard

end
</code></pre>

<p>We‚Äôre adding two outputs here, provide the <em>signal</em> as the first and the <em>semantic</em> as the second parameter to <code>Output()</code> and then connect them to a track.</p>

<p><span class="divider"></span></p>

<ul class="navigation">
    <li>Output()</li>
    <li id="activity-wiring-api-output-implicit-signal">Implicit signal</li>
</ul>

<p>Trailblazer has two outputs predefined. As you might‚Äôve guessed, the <code>:failure</code> and <code>:success</code> outputs are a convention. This allows to <strong>omit the signal</strong> when referencing an existing output.</p>

<pre><code>class Execute &lt; Trailblazer::Activity::Railway
  step :find_provider, Output(:failure) =&gt; Track(:failure)
  step :charge_creditcard
end
</code></pre>

<p>As the DSL knows the <code>:failure</code> output, it will reconnect it accordingly while keeping the signal.</p>

<p><span class="divider"></span></p>

<ul class="navigation">
    <li>Output()</li>
    <li id="activity-wiring-api-output-adding-outputs">Adding outputs</li>
</ul>

<p>When specifying a new semantic to <code>Output()</code>, you are adding an output to the task. This is why you must also pass a signal as the first argument.</p>

<div class="bd-callout bd-callout-info">
<p>Since a particular output is triggered by a particular signal, note that each output must be configured with a <strong>unique signal</strong> per activity.</p>
</div>

<pre><code>class Execute &lt; Trailblazer::Activity::Railway
  UsePaypal = Class.new(Trailblazer::Activity::Signal)

  step :find_provider, Output(UsePaypal, :paypal) =&gt; Track(:paypal)
  step :charge_creditcard
end
</code></pre>

<p><img class="mx-auto d-block" src="/vite-dev/images/wire-output-add.webp" /></p>

<p>The <code>find_provider</code> task now has three possible outcomes that can be triggered by returning either <code>Right</code>, <code>Left</code>, or <code>UsePaypal</code>.</p>

<p><span class="divider"></span></p>

<h3 id="activity-wiring-api-end-">End()</h3>
<p><!-- {activity-wiring-api-end--toc} --></p>

<p>Use <code>End()</code> to connect outputs to an existing end, or create a new end.</p>

<p>You may reference existing ends by their semantic.</p>

<pre><code>class Execute &lt; Trailblazer::Activity::Railway
  step :find_provider
  step :charge_creditcard, Output(:failure) =&gt; End(:success)
end
</code></pre>

<p>This reconnects both outputs to the same end, always ending in a - desirable, yet unrealistic - successful state.</p>

<p><img class="mx-auto d-block" src="/vite-dev/images/wire-output-end.webp" /></p>

<p><span class="divider"></span></p>

<ul class="navigation">
    <li>End()</li>
    <li id="activity-wiring-api-end-adding-ends">Adding ends</li>
</ul>

<p>Providing a new semantic to the <code>End()</code> function will create a new end event.</p>

<pre><code>class Execute &lt; Trailblazer::Activity::Railway
  step :find_provider
  step :charge_creditcard, Output(:failure) =&gt; End(:declined)
end
</code></pre>

<p>Adding ends to an activity is a beautiful way to communicate more than two outcomes to the outer world without having to use a state field in the <code>ctx</code>. It also allows wiring those outcomes to different tracks in the container activity. [See nesting]</p>

<p><img class="mx-auto d-block" src="/vite-dev/images/wire-output-endadd.webp" /></p>

<p>This activity now maintains three end events. The path to the <code>declined</code> end is taken from the task‚Äôs <code>failure</code> output.</p>

<div class="bd-callout bd-callout-info">
<p>Successive uses of the same <code>End(:semantic)</code> will all connect to the same end.</p>
</div>

<p><span class="divider"></span></p>

<h3 id="activity-wiring-api-id-">Id()</h3>
<p><!-- {activity-wiring-api-id--toc} --></p>

<p>An output can be connected to a particular task by using <code>Id()</code>.</p>

<pre><code>class Execute &lt; Trailblazer::Activity::Railway
  step :find_provider
  step :charge_creditcard, Output(:failure) =&gt; Id(:find_provider)
end
</code></pre>

<p>This connects the <code>failure</code> output to the previous task, which might create an infinity loop and waste your computing time - it is solely here for demonstrational purposes.</p>

<p><span class="divider"></span></p>

<h3 id="activity-wiring-api-track-">Track()</h3>
<p><!-- {activity-wiring-api-track--toc} --></p>

<p>The <code>Track()</code> function will snap the output to the next task that is ‚Äúmagnetic to‚Äù the track‚Äôs semantic.</p>

<pre><code>class Execute &lt; Trailblazer::Activity::Railway
  step :find_provider, Output(:success) =&gt; Track(:failure)
  step :charge_creditcard
  fail :notify
end
</code></pre>

<p>Since <code>notify</code> sits on the ‚Äúfailure‚Äù track and hence is ‚Äúmagnetic to‚Äù <code>:failure</code>, <code>find_provider</code> will be connected to it.</p>

<p>Using <code>Track()</code> with a new track semantic only makes sense when using the [<code>:magnetic_to</code> option] on other tasks.</p>

<div class="bd-callout bd-callout-info">
<p>Use [Path()] if you want to avoid <code>Track()</code> and <code>:magnetic_to</code> - this helper does nothing but providing those values to your convenience.</p>
</div>

<p><span class="divider"></span></p>

<h3 id="activity-wiring-api-terminus">Terminus</h3>
<p><!-- {activity-wiring-api-terminus-toc} --></p>

<p><a href="https://github.com/trailblazer/trailblazer-activity-dsl-linear" class="pink"><i class="fa fa-gem" aria-hidden="true"></i> trailblazer-activity-dsl-linear 1.0.0</a></p>

<p>In addition to the strategy‚Äôs termini, you can add your own end events using <code>#terminus</code>. This is an important design tool helping you to communicate outcomes other than ‚Äúsuccess‚Äù or ‚Äúfailure‚Äù to the outer world (in a <code>Railway</code> activity).</p>

<pre><code>module Payment::Operation
  class Create &lt; Trailblazer::Activity::Railway
    step :find_provider

    terminus :provider_invalid # , id: "End.provider_invalid", magnetic_to: :provider_invalid
    # ...
  end
end
</code></pre>

<p>The above code adds a new terminus named <code>End.provider_invalid</code> to the activity.</p>

<p><img class="mx-auto d-block" src="/vite-dev/images/wiring-terminus-dashed.png" /></p>

<p>As visible, this terminus is not connected to anything as its <code>magnetic_to</code> property is set to <code>:provider_invalid</code>.</p>

<p>You could now connect <code>find_provider</code>‚Äôs failure output to the new terminus by using the <code>Track()</code> helper.</p>

<pre><code>module Payment::Operation
  class Create &lt; Trailblazer::Activity::Railway
    step :find_provider,
      # connect {failure} to the next element that is magnetic_to {:provider_invalid}.
      Output(:failure) =&gt; Track(:provider_invalid)

    terminus :provider_invalid
    # ...
  end
end
</code></pre>

<p>The failure output will be connected to the next following element that is magnetic_to <code>:provider_invalid</code>, which is the new terminus we created.</p>

<p><img class="mx-auto d-block" src="/vite-dev/images/wiring-terminus-track.png" /></p>

<p>Invoking this activity with an unsolicited provider will stop on the newly added terminus.</p>

<pre><code>signal, (ctx, _) = Payment::Operation::Create.(provider: "bla-unknown")
puts signal.to_h[:semantic] #=&gt; :provider_invalid
</code></pre>

<div class="bd-callout bd-callout-info">
<p>The default semantic is <code>:provider_invalid</code>. Note that the following options <code>:id</code> and <code>:magnetic_to</code> can be passed to <code>#terminus</code>:</p>

<ul>
  <li><code>:id</code></li>
  <li><code>:magnetic_to</code></li>
  <li><code>:task</code> which has to be a subclass of <code>Trailblazer::Activity::End</code>.</li>
</ul>
</div>

<p><span class="divider"></span></p>

<h3 id="activity-wiring-api-path-">Path()</h3>
<p><!-- {activity-wiring-api-path--toc} --></p>

<p>For branching out a separate path in an activity, use the <code>Path()</code> macro. It‚Äôs a convenient, simple way to declare alternative routes, even if you could do everything it does manually.</p>

<pre><code>class Charge &lt; Trailblazer::Activity::Path
  # ...
  step :validate
  step :decide_type, Output(Trailblazer::Activity::Left, :credit_card) =&gt; Path(end_id: "End.cc", end_task: End(:with_cc)) do
    step :authorize
    step :charge
  end
  step :direct_debit
end
</code></pre>

<p>By providing the options <code>:end_id</code> and <code>:end_task</code>, the newly created path will quit in a new end event.</p>

<p><img class="mx-auto d-block" src="/vite-dev/images/path-macro.webp" /></p>

<p>Using <code>Output</code> you can create an additional output in <code>decide_type</code> with the semantic <code>:credit_card</code>. This output is triggered when its task returns a <code>Trailblazer::Activity::Left</code> signal.</p>

<p>Note that the path ends in its very own end, signalizing a new end state, or outcome. The end‚Äôs semantic is <code>:with_cc</code>.</p>

<p><span class="divider"></span></p>

<ul class="navigation">
    <li>Path()</li>
    <li id="activity-wiring-api-path-join">Join</li>
</ul>

<p>If you want the path to reconnect and join the activity at some point, use the <code>:connect_to</code> option.</p>

<pre><code>class Charge &lt; Trailblazer::Activity::Path
  # ...
  step :validate
  step :decide_type, Output(Trailblazer::Activity::Left, :credit_card) =&gt; Path(connect_to: Id(:finalize)) do
    step :authorize
    step :charge
  end
  step :direct_debit
  step :finalize
end
</code></pre>

<p>There won‚Äôt be another end event created.</p>

<p><img class="mx-auto d-block" src="/vite-dev/images/path-macro-join.webp" /></p>

<p><span class="divider"></span></p>

<ul class="navigation">
    <li>Path()</li>
    <li id="activity-wiring-api-path-railway">Railway</li>
</ul>

<p>You can use <code>Path()</code> in any Trailblazer strategy, for example in <code>Railway</code>.</p>

<pre><code>class Charge &lt; Trailblazer::Activity::Railway
  MySignal = Class.new(Trailblazer::Activity::Signal)
  # ...
  step :validate
  step :decide_type, Output(MySignal, :credit_card) =&gt; Path(connect_to: Id(:finalize)) do
    step :authorize
    step :charge
  end
  step :direct_debit
  step :finalize
end
</code></pre>

<p>In this example, we add a third output to <code>decide_type</code> to handle the credit card payment scenario (you could also ‚Äúoverride‚Äù or re-configure the existing <code>:failure</code> or <code>:success</code> outputs).</p>

<p><img class="mx-auto d-block" src="/vite-dev/images/path-macro-railway.webp" /></p>

<p>Only when <code>decide_type</code> returns <code>MySignal</code>, the new path alternative is taken.</p>

<pre><code>def decide_type(ctx, model:, **)
  if model.is_a?(CreditCard)
    return MySignal # go the Path() way!
  elsif model.is_a?(DebitCard)
    return true
  else
    return false
  end
end
</code></pre>

<p><code>Output()</code> in combination with <code>Path()</code> allow very simple modelling for alternive routes.</p>

<p><span class="divider"></span></p>

<h3 id="activity-wiring-api-subprocess">Subprocess</h3>
<p><!-- {activity-wiring-api-subprocess-toc} --></p>

<p>While you could nest an activity into another manually, the <code>Subprocess</code> macro will come in handy.</p>

<p>Consider the following nested activity.</p>

<pre><code>class Memo::Validate &lt; Trailblazer::Activity::Railway
  step :check_params
  step :check_attributes
  # ...
end
</code></pre>

<p>Use <code>Subprocess</code> to nest it into the <code>Create</code> activity.</p>

<pre><code>class Memo::Create &lt; Trailblazer::Activity::Railway
  step :create_model
  step Subprocess(Memo::Validate)
  step :save
  # ...
  # ...
</code></pre>

<p>The macro automatically wires all of <code>Validate</code>‚Äôs ends to the known counter-part tracks.</p>

<p><img class="mx-auto d-block" src="/vite-dev/images/nesting.webp" /></p>

<p>The <code>Subprocess</code> macro will go through all outputs of the nested activity, query their semantics and search for tracks with the same semantic.</p>

<p>Note that the failure track starting from <code>create_model</code> will skip the nested activity, just as if it was simple task.</p>

<p><span class="divider"></span></p>

<ul class="navigation">
    <li>Subprocess</li>
    <li id="activity-wiring-api-subprocess-wiring">Wiring</li>
</ul>

<p>You can use the familiar DSL to reconnect ends.</p>

<pre><code>class Memo::Create &lt; Trailblazer::Activity::Railway
  step :create_model
  step Subprocess(Memo::Validate), Output(:failure) =&gt; Track(:success)
  step :save
  # ...
end
</code></pre>

<p>The nested‚Äôs <code>failure</code> output now goes to the outer <code>success</code> track.</p>

<p><img class="mx-auto d-block" src="/vite-dev/images/nesting-reconnect.webp" /></p>

<p>In this example, regardless of nested‚Äôs outcome, it will always be interpreted as a successful invocation.</p>

<p><span class="divider"></span></p>

<ul class="navigation">
    <li>Subprocess</li>
    <li id="activity-wiring-api-subprocess-end">End</li>
</ul>

<p>A nested activity doesn‚Äôt have to have two ends, only.</p>

<pre><code>class Memo::Validate &lt; Trailblazer::Activity::Railway
  step :check_params, Output(:failure) =&gt; End(:invalid_params)
  step :check_attributes
  # ...
end
</code></pre>

<p><code>Subprocess</code> will try to match the nested ends‚Äô semantics to the tracks it knows. You may wire custom ends using <code>Output</code>.</p>

<pre><code>class Memo::Create &lt; Trailblazer::Activity::Railway
  step :create_model
  step Subprocess(Memo::Validate), Output(:invalid_params) =&gt; Track(:failure)
  step :save
  # ...
end
</code></pre>

<p>The new special end is now wired to the <code>failure</code> track of the containing activity.</p>

<p><img class="mx-auto d-block" src="/vite-dev/images/nesting-end.webp" /></p>

<p>There will be an exception thrown if you don‚Äôt connect unknown ends.</p>

<p><span class="divider"></span></p>

<h2 id="activity-dsl-options">DSL Options</h2>
<p><!-- {activity-dsl-options-toc} --></p>

<p><code>#step</code> and friends accept a bunch of options in order to insert a task at a specific location, add pre-defined connections and outputs, or even configure its taskWrap.
<!--
  outputs
  connections
  magnetic_to
 --></p>

<p><span class="divider"></span></p>

<h3 id="activity-dsl-options-magnetic_to">magnetic_to</h3>
<p><!-- {activity-dsl-options-magnetic_to-toc} --></p>

<p>In combination with [<code>Track()</code>], the <code>:magnetic_to</code> option allows for a neat way to spawn custom tracks outside of the conventional Railway or FastTrack schema.</p>

<pre><code>class Execute &lt; Trailblazer::Activity::Railway
  step :find_provider, Output(:failure) =&gt; Track(:paypal)
  step :charge_creditcard
  step :charge_paypal, magnetic_to: :paypal
end
</code></pre>

<p>The <code>failure</code> output of the <code>find_provider</code> task will now snap to the next task being <code>:magnetic_to</code> its semantic - which obviously is the <code>charge_paypal</code> task.</p>

<p>When creating a new branch (or path) in this way, it‚Äôs a matter of repeating the use of <code>Track()</code> and <code>:magnetic_to</code> to add more tasks to the branch.</p>

<p><span class="divider"></span></p>

<h3 id="activity-dsl-options-extensions">extensions</h3>
<p><!-- {activity-dsl-options-extensions-toc} --></p>

<p><span class="divider"></span></p>

<h3 id="activity-dsl-options-sequence-options">Sequence Options</h3>
<p><!-- {activity-dsl-options-sequence-options-toc} --></p>

<p>In addition to wiring options, there are a handful of other options known as <em>sequence options</em>. They configure where a task goes when inserted, and helps with introspection and tracing.</p>

<p><span class="divider"></span></p>

<ul class="navigation">
    <li>Sequence Options</li>
    <li id="activity-dsl-options-sequence-options-id">id</li>
</ul>

<p>The DSL will provide default names for tasks.
You can name explicitely using the <code>:id</code> option.</p>

<pre><code>class Memo::Create &lt; Trailblazer::Activity::Path
  step :create_model
  step :validate
  step :save, id: :save_the_world
  # ...
end
</code></pre>

<p>The IDs are as follows.</p>

<pre><code>Trailblazer::Developer.railway(Memo::Create)
#=&gt; [&gt;create_model,&gt;validate,&gt;save_the_world]
</code></pre>

<p>This is advisable when planning to override a step via a module or inheritance or when reconnecting it. Naming also shows up in tracing and introspection. Defaults names are given to steps without the <code>:id</code> options, but these might be awkward sometimes.</p>

<p><span class="divider"></span></p>

<ul class="navigation">
    <li>Sequence Options</li>
    <li id="activity-dsl-options-sequence-options-delete">Delete</li>
</ul>

<p>When it‚Äôs necessary to remove a task, you can use <code>:delete</code>.</p>

<pre><code>class Memo::Create::Admin &lt; Memo::Create
  step nil, delete: :validate
end
</code></pre>

<p>The <code>:delete</code> option can be helpful when using modules or inheritance to build concrete operations from base operations. In this example, a very poor one, the <code>validate</code> task gets removed, assuming the <code>Admin</code> won‚Äôt need a validation.</p>

<pre><code>Trailblazer::Developer.railway(Memo::Create::Admin)
#=&gt; [&gt;create_model,&gt;save_the_world]
</code></pre>

<p>All steps are inherited, then the deletion is applied, as the introspection shows.</p>

<p><span class="divider"></span></p>

<ul class="navigation">
    <li>Sequence Options</li>
    <li id="activity-dsl-options-sequence-options-before">Before</li>
</ul>

<p>To insert a new task before an existing one, for example in a subclass, use <code>:before</code>.</p>

<pre><code>class Memo::Create::Authorized &lt; Memo::Create
  step :policy, before: :create_model
  # ...
end
</code></pre>

<p>The circuit now yields a new <code>policy</code> step before the inherited tasks.</p>

<pre><code>Trailblazer::Developer.railway(Memo::Create::Authorized)
#=&gt; [&gt;policy,&gt;create_model,&gt;validate,&gt;save_the_world]
</code></pre>

<p><span class="divider"></span></p>

<ul class="navigation">
    <li>Sequence Options</li>
    <li id="activity-dsl-options-sequence-options-after">After</li>
</ul>

<p>To insert after an existing task, you might have guessed it, use the <code>:after</code> option with the exact same semantics as <code>:before</code>.</p>

<pre><code>class Memo::Create::Logging &lt; Memo::Create
  step :logger, after: :validate
  # ...
end
</code></pre>

<p>The task is inserted after, as the introspection shows.</p>

<pre><code>Trailblazer::Developer.railway(Memo::Create::Logging)
#=&gt; [&gt;create_model,&gt;validate,&gt;logger,&gt;save_the_world]
</code></pre>

<p><span class="divider"></span></p>

<ul class="navigation">
    <li>Sequence Options</li>
    <li id="activity-dsl-options-sequence-options-replace">Replace</li>
</ul>

<p>Replacing an existing task is done using <code>:replace</code>.</p>

<pre><code>class Memo::Update &lt; Memo::Create
  step :find_model, replace: :create_model, id: :update_memo
  # ...
end
</code></pre>

<p>Replacing, obviously, only replaces in the applied class, not in the superclass.</p>

<pre><code>Trailblazer::Developer.railway(Memo::Update)
#=&gt; [&gt;update_memo,&gt;validate,&gt;save_the_world]
</code></pre>

<p><span class="divider"></span></p>

<h3 id="activity-dsl-options-patching">Patching</h3>
<p><!-- {activity-dsl-options-patching-toc} --></p>

<p>Working with <code>Subprocess</code> and deeply nested activities for complex flows is a great way to encapsulate and create reusable code. However, it can be a PITA if you want to customize one of those deeply nested components and add or remove a certain step, for example.</p>

<p>Suppose the following 3-level nested activity.</p>

<p><img class="mx-auto d-block" src="/vite-dev/images/patching.webp" /></p>

<p>The public operation <code>Destroy</code> contains <code>Delete</code> as a nested activity, which itself contains <code>DeleteAssets</code>. In order to customize the latter one and add another step <code>tidy_storage</code>, you‚Äôd normally have to subclass all three activities and override steps.</p>

<p><span class="divider"></span></p>

<ul class="navigation">
    <li>Patching</li>
    <li id="activity-dsl-options-patching-patch-option">Patch Option</li>
</ul>

<p>Using patching, you can do this ad-hoc in the uppermost <code>Destroy</code> activity.</p>

<pre><code>class Destroy &lt; Trailblazer::Activity::Railway
  def self.tidy_storage(ctx, **)
    # delete files from your amazing cloud
    true
  end
  # ...

  step :policy
  step :find_model
  step Subprocess(Delete,
    patch: {
      [:delete_assets] =&gt; -&gt; { step Destroy.method(:tidy_storage), before: :rm_uploads }
    }
  )
end
</code></pre>

<p>The <code>Subprocess()</code> macro accepts the <code>:patch</code> option which is a hash of the path to the customized activity, and its patch. This patch block is <code>class_eval</code>ed in context of the patched activity. You may add methods here, add, remove, or move steps, or whatever else needs fixing.</p>

<div class="bd-callout bd-callout-info">
<p>Note that patching does <strong>not</strong> change the originally nested activities. It creates copies of them.
Also, the automatically assigned ID of a step gets replaced with new a copy. Make sure you mention it <a href="#activity-dsl-options-sequence-options-id">explicitly</a> to persist.</p>
</div>

<p>Looking at the trace of <code>Destroy</code>, you can see that <code>#tidy_storage</code> is executed where you want it.</p>

<p><img class="mx-auto d-block" src="/vite-dev/images/patching-trace.webp" /></p>

<p>Patching can be also done at the top-level activity by passing  <code>:patch</code> as a block (Take <code>Delete</code> from above example).</p>

<pre><code>step Subprocess(
  Delete,
  patch: -&gt; { step Destroy.method(:tidy_storage), before: :delete_model }
), id: :delete
</code></pre>

<p><span class="divider"></span></p>

<ul class="navigation">
    <li>Patching</li>
    <li id="activity-dsl-options-patching-side-effects">Side effects</li>
</ul>

<p>The idea of patching is that the originally nested activities remain untouched.</p>

<pre><code>class Delete &lt; Trailblazer::Activity::Railway
  step :delete_model
  step Subprocess(DeleteAssets), id: :delete_assets
  # ...
end
</code></pre>

<p>They‚Äôre inherited and customized for you automatically by the DSL.</p>

<pre><code>class DeleteAssets &lt; Trailblazer::Activity::Railway
  step :rm_images
  step :rm_uploads
  # ...
end
</code></pre>

<p>Patching has no implicit, magical side-effects and is strongly encouraged to customize flows for a specific case in a quick and consise way.</p>

<p><span class="divider"></span></p>

<h2 id="activity-variable-mapping">Variable Mapping</h2>
<p><!-- {activity-variable-mapping-toc} --></p>

<p>Since TRB 2.1 it is possible to define the input and output variables for each step. This is called <em>variable mapping</em>, or I/O in short. It provides an interface to define what variable go in and come out of a task, enabling you to limit what steps ‚Äúsee‚Äù and what ‚Äúoutput‚Äù they can add to the context.</p>

<p>It‚Äôs one of the most frequently used features in Trailblazer.</p>

<p><span class="divider"></span></p>

<h3 id="activity-variable-mapping-overview">Overview</h3>
<p><!-- {activity-variable-mapping-overview-toc} --></p>

<p>Imagine a complex application where policies are protecting your operation code from unsolicited access. This code component - the policy - sits as a step in every business operation and decides whether or not the current user is permitted to execute this very operation.</p>

<pre><code>class Create &lt; Trailblazer::Activity::Railway
  step :create_model
  step Policy::Create # an imaginary policy step.
  # ...
end
</code></pre>

<p>The <code>Policy::Create</code> implementaition is a simple callable class following the <a href="#activity-internals-step-interface">step interface</a>.</p>

<pre><code>module Policy
  # Explicit policy, not ideal as it results in a lot of code.
  class Create
    def self.call(ctx, model:, user:, **)
      decision = ApplicationPolicy.can?(model, user, :create) # FIXME: how does pundit/cancan do this exactly?
      # ...
    end
  end
end
</code></pre>

<p>Note that it requires two variables <code>:model</code> and <code>:user</code> from the ctx. For whatever reasons, the author of this class dictated that the ‚Äúcurrent user‚Äù must be passed named <code>:user</code>, not, as it‚Äôs a convention in Trailblazer, named <code>:current_user</code>.</p>

<p>Last, depending on the policy decision, the step code returns true or false.</p>

<p>When executing the <code>Create</code> operation using the <code>:current_user</code> variable, an <code>ArgumentError</code> is raised.</p>

<pre><code>result = Trailblazer::Activity::TaskWrap.invoke(AA::Create, [{current_user: Module}])

#=&gt; ArgumentError: missing keyword: :user
</code></pre>

<p>Since the ‚Äúcurrent user‚Äù is handed into the operation as the <code>:current_user</code> variable, and no other step preceding <code>Policy::Create</code> is setting this variable, the step expecting <code>:user</code> crashes.</p>

<p>And this is why we need variable mapping in Trailblazer.</p>

<p><span class="divider"></span></p>

<h3 id="activity-variable-mapping-composable-i-o">Composable I/o</h3>
<p><!-- {activity-variable-mapping-composable-i-o-toc} --></p>

<p>Variable mapping (short: i/o) can be done manually, with ugly ‚Äúhelper‚Äù steps before or after the respective step, or by using <code>In()</code>, <code>Out()</code> and <code>Inject()</code>. Before these helpers got introduced, we used the <code>:input</code> and <code>:output</code> option - both works, the latter one coming with several drawbacks.</p>

<p>Helpers can be used multiple times, depending on how complex the incoming or outcoming variables are, forming a pipeline of filters around the actual task.</p>

<pre><code>class Create &lt; Trailblazer::Activity::Railway
  step :create_model
  step Policy::Create,
    In() =&gt; {:current_user =&gt; :user},
    In() =&gt; [:model],
    Out() =&gt; [:message]
  # ...
end
</code></pre>

<p>Not only are those input and output pipelines easy to <a href="#activity-variable-mapping-introspect">debug</a>, they also allow to be altered in derived operations, when <a href="#activity-variable-mapping-inheritance">using inheritance</a>, and  work in <a href="#activity-variable-mapping-macro">combination with macros</a>.</p>

<p><span class="divider"></span></p>

<h3 id="activity-variable-mapping-in-">In()</h3>
<p><!-- {activity-variable-mapping-in--toc} --></p>

<p>As you might have guessed, <code>In()</code> helps creating input filters. It allows to configure or dynamically compute variables going <em>into</em> the step. The helper accepts either a mapping hash, a limiting array or a callable object (often a lambda).</p>

<p>Be wary that once you use <code>In()</code>, only the variables defined in your filters will be passed into the step. All other variables from ctx are invisible in the step.</p>

<p><span class="divider"></span></p>

<ul class="navigation">
    <li>In()</li>
    <li id="activity-variable-mapping-in-mapping-hash">Mapping hash</li>
</ul>

<p>Picking up the example from above, here‚Äôs how a mapping hash ‚Äútranslates‚Äù the selected variables from the original ctx object to a new ctx, one that is compatible with <code>Policy::Create</code>‚Äôs interface.</p>

<pre><code>class Create &lt; Trailblazer::Activity::Railway
  step :create_model
  step Policy::Create,
    In() =&gt; {
      :current_user =&gt; :user, # rename {:current_user} to {:user}
      :model        =&gt; :model # add {:model} to the inner ctx.
    }
  # ...
end
</code></pre>

<p>The <code>In()</code> filter will result in <code>:current_user</code> being renamed to <code>:user</code>. Since the policy step also needs <code>:model</code> we need to mention this variable as well, no renaming happening here. The beauty of I/O: this is only visible to <code>Policy::Create</code>!</p>

<p><img class="mx-auto d-block" src="/vite-dev/images/ctx-in.png" /></p>

<p>To instantly see what new ctx is passed into the configured step, you could replace the original policy step with a <code>#show_ctx</code> method.</p>

<pre><code>class Create &lt; Trailblazer::Activity::Railway
  step :create_model
  step :show_ctx,
    In() =&gt; {
      :current_user =&gt; :user, # rename {:current_user} to {:user}
      :model        =&gt; :model # add {:model} to the inner ctx.
    }

  def show_ctx(ctx, **)
    p ctx.to_h
    #=&gt; {:user=&gt;#&lt;User email:...&gt;, :model=&gt;#&lt;Song name=nil&gt;}
  end
  # ...
end
</code></pre>

<p>You should use the mapping hash when variables need to be renamed. If variables need to be added without renaming, a limiting array is your friend.</p>

<p><span class="divider"></span></p>

<ul class="navigation">
    <li>In()</li>
    <li id="activity-variable-mapping-in-limiting-array">Limiting array</li>
</ul>

<p><code>In()</code> accepts an array, listed variables are passed into the new ctx (whether they exist in the original ctx or not!).</p>

<pre><code>class Create &lt; Trailblazer::Activity::Railway
  step :create_model
  step Policy::Create,
    In() =&gt; {:current_user =&gt; :user},
    In() =&gt; [:model]
  # ...
end
</code></pre>

<p>This configuration will lead to the exact same new ctx for <code>Policy::Create</code> as in the <a href="#activity-variable-mapping-in-mapping-hash">example above</a>, producing a new ctx that will look as below.</p>

<pre><code>#=&gt; {
#     :user  =&gt; #&lt;User email:...&gt;,
#     :model =&gt; #&lt;Song name=nil&gt;}
#   }
</code></pre>

<p><span class="divider"></span></p>

<ul class="navigation">
    <li>In()</li>
    <li id="activity-variable-mapping-in-callable">Callable</li>
</ul>

<p>As always, you may implement your own input filter with any callable object [adhering to the step interface])(#activity-internals-step-interface).</p>

<pre><code>class Create &lt; Trailblazer::Activity::Railway
  step :create_model
  step Policy::Create,
    In() =&gt; -&gt;(ctx, **) do
      # only rename {:current_user} if it's there.
      ctx[:current_user].nil? ? {} : {user: ctx[:current_user]}
    end,
    In() =&gt; [:model]
  # ...
end
</code></pre>

<p>Callable <code>In()</code> filters <strong>have to</strong> return a hash. This hash will be merged with the other <code>In()</code> filters and comprise the new ctx.</p>

<p>And again, when the operation is invoked with a <code>:current_user</code>, this will, result in the same new ctx as above.</p>

<pre><code>#=&gt; {
#     :user  =&gt; #&lt;User email:...&gt;,
#     :model =&gt; #&lt;Song name=nil&gt;}
#   }
</code></pre>

<p>However, if <code>:current_user</code> is <code>nil</code>, <code>Policy::Create</code> will raise an exception complaining about the <code>:user</code> keyword missing.</p>

<p><span class="divider"></span></p>

<ul class="navigation">
    <li>In()</li>
    <li id="activity-variable-mapping-in-filter-method">Filter method</li>
</ul>

<p>Following the TRB option standard, an <code>In()</code> filter may even be implemented as an instance method. All you need to do is pass a symbol to <code>In()</code>.</p>

<pre><code>class Create &lt; Trailblazer::Activity::Railway
  step :create_model
  step Policy::Create,
    In() =&gt; :input_for_policy, # You can use an {:instance_method}!
    In() =&gt; [:model]

  def input_for_policy(ctx, **)
    # only rename {:current_user} if it's there.
    ctx[:current_user].nil? ? {} : {user: ctx[:current_user]}
  end
  # ...
end
</code></pre>

<p>The method needs to expose a step interface just like any other callable.</p>

<p><span class="divider"></span></p>

<ul class="navigation">
    <li>In()</li>
    <li id="activity-variable-mapping-in-keyword-arguments">Keyword arguments</li>
</ul>

<p>Both callables and filter methods for <code>In()</code> can receive ctx variables as keyword arguments, making it a convenient access and have Ruby perform a loose existance test automatically.</p>

<pre><code>class Create &lt; Trailblazer::Activity::Railway
  step :create_model
  step Policy::Create,
                  # vvvvvvvvvvvv keyword arguments rock!
    In() =&gt; -&gt;(ctx, current_user: nil, **) do
      current_user.nil? ? {} : {user: current_user}
    end,
    In() =&gt; [:model]
  # ...
end
</code></pre>

<p>Keep in mind that when not defaulting the keyword argument your filter might crash at runtime when the expected variables were not passed.</p>

<p><span class="divider"></span></p>

<h3 id="activity-variable-mapping-out-">Out()</h3>
<p><!-- {activity-variable-mapping-out--toc} --></p>

<p>Without any output configuration on the exemplary policy step, any variable written to <code>ctx</code> will be automatically set on the outer ctx. Anything the step writes to <code>ctx</code> is passed along to the following step.</p>

<p><img class="mx-auto d-block" src="/vite-dev/images/ctx-out-all.png" /></p>

<p>Here, both <code>:status</code> and <code>:message</code> variables that were written in <code>Policy::Create</code> are passed into the outer ctx. The behavior is identical to the way before you were using i/o.</p>

<p>However, it is often necessary to rename or limit the outgoing variables of a particular step. Especially when using nested operations you probably don‚Äôt want the entire nested ctx to be copied into the outer context. This is where output filters enter the stage.</p>

<p>Consider the following updated <code>Policy::Create</code> step.</p>

<pre><code>module Policy
  # Explicit policy, not ideal as it results in a lot of code.
  class Create
    def self.call(ctx, model:, user:, **)
      decision = ApplicationPolicy.can?(model, user, :create) # FIXME: how does pundit/cancan do this exactly?

      if decision.allowed?
        return true
      else
        ctx[:status]  = 422 # we're not interested in this field.
        ctx[:message] = "Command {create} not allowed!"
        return false
      end
    end
  end
end
</code></pre>

<p>Both <code>ctx[:status]</code> and <code>ctx[:message]</code> will be visible in all steps following <code>Policy::Create</code>. This might lead to ‚Äúmisunderstandings‚Äù and bugs in more complex applications.</p>

<p>As soon as you use <code>Out()</code>, only variables specified through the filters will be merged with the original (outer) ctx and passed on to the next step.</p>

<p><span class="divider"></span></p>

<ul class="navigation">
    <li>Out()</li>
    <li id="activity-variable-mapping-out-limiting-array">Limiting array</li>
</ul>

<p>In order to limit variables added to the outer ctx, <code>Out()</code> accepts an array similar to <code>In()</code>. Consider this as a whitelisting to specify exposed variables.</p>

<pre><code>class Create &lt; Trailblazer::Activity::Railway
  step :create_model
  step Policy::Create,
    In() =&gt; {:current_user =&gt; :user},
    In() =&gt; [:model],
    Out() =&gt; [:message]
  # ...
end
</code></pre>

<p>This single <code>Out()</code> usage will result in only the <code>:message</code> variable being written to the outer ctx that is passed on. The <code>:status</code> variable is discarded.</p>

<p><img class="mx-auto d-block" src="/vite-dev/images/ctx-out.png" /></p>

<p>You may pass any number of variables in the limiting array.</p>

<p><span class="divider"></span></p>

<ul class="navigation">
    <li>Out()</li>
    <li id="activity-variable-mapping-out-mapping-hash">Mapping hash</li>
</ul>

<p>Renaming variables from the inner to the outer ctx works by providing a mapping hash, where the ‚Äúold‚Äù inner name points to the outer name that you want to use in the operation hosting that step.</p>

<pre><code>class Create &lt; Trailblazer::Activity::Railway
  step :create_model
  step Policy::Create,
    In() =&gt; {:current_user =&gt; :user},
    In() =&gt; [:model],
    Out() =&gt; {:message =&gt; :message_from_policy}
  # ...
end
</code></pre>

<p>Here, steps following <code>Policy::Create</code> will see a variable <code>:message_from_policy</code> merged into the ctx - which is the original <code>:message</code>, renamed.</p>

<p><span class="divider"></span></p>

<ul class="navigation">
    <li>Out()</li>
    <li id="activity-variable-mapping-out-callable">Callable</li>
</ul>

<p>An <code>Out()</code> filter can be any callable object following the <a href="#activity-internals-step-interface">step interface</a>.</p>

<pre><code>class Create &lt; Trailblazer::Activity::Railway
  step :create_model
  step Policy::Create,
    In() =&gt; {:current_user =&gt; :user},
    In() =&gt; [:model],
    Out() =&gt; -&gt;(ctx, **) do
      return {} unless ctx[:message]

      { # you always have to return a hash from a callable!
        :message_from_policy =&gt; ctx[:message]
      }
    end
  # ...
end
</code></pre>

<p>The callable receives the inner ctx that just left the actual step, here <code>Policy::Create</code>. You may run any Ruby code in the callable, even <code>if</code>s.</p>

<p>Note that a callable always must return a hash, which is then merged with the original outer ctx.</p>

<p>Be adviced that it is usually a better idea to maintain multiple smaller <code>Out()</code> callables for different variables. You might later decide to override them, debugging will be easier and the code is more maintainable. This was different when <code>:output</code> was the only way to filter outgoing variables and you had to create one big hash in a one single filter.</p>

<div class="bd-callout bd-callout-info">
<p>You may also use an <code>:instance_method</code> to filter outgoing variables, similar to <a href="#activity-variable-mapping-in-filter-method">how it‚Äôs done with In()</a>.</p>
</div>

<p><span class="divider"></span></p>

<ul class="navigation">
    <li>Out()</li>
    <li id="activity-variable-mapping-out-keyword-arguments">Keyword arguments</li>
</ul>

<p>Just as with <code>In()</code> callables can receive keyword arguments.</p>

<pre><code>class Create &lt; Trailblazer::Activity::Railway
  step :create_model
  step Policy::Create,
    In() =&gt; {:current_user =&gt; :user},
    In() =&gt; [:model],
    Out() =&gt; -&gt;(ctx, message: nil, **) do
      return {} if message.nil?

      { # you always have to return a hash from a callable!
        :message_from_policy =&gt; message
      }
    end
  include Steps
end
</code></pre>

<p>Any variable readable on the inner <code>ctx</code> that just left <code>Policy::Create</code> is available as a keyword argument for a callable. Note that you need to default it if its presence is not guaranteed.</p>

<p><span class="divider"></span></p>

<ul class="navigation">
    <li>Out()</li>
    <li id="activity-variable-mapping-out-outer-context">Outer context</li>
</ul>

<p>You can access the outer, original ctx by passing the <code>:with_outer_ctx</code> option to <code>Out()</code>.</p>

<pre><code>class Create &lt; Trailblazer::Activity::Railway
  step :create_model
  step Policy::Create,
    In() =&gt; {:current_user =&gt; :user},
    In() =&gt; [:model],
    Out() =&gt; [:message],

    Out(with_outer_ctx: true) =&gt; -&gt;(inner_ctx, outer_ctx, **) do
      {
        errors: outer_ctx[:errors].merge(policy_message: inner_ctx[:message])
      }
    end
  # ...
end
</code></pre>

<p>While the callable still needs to return a hash that is then merged with the original ctx, it‚Äôs possible to access variables from the outer ctx before that merge. This allows for merging deeper data structures, such as error objects.</p>

<p><span class="divider"></span></p>

<h3 id="activity-variable-mapping-inject-">Inject()</h3>
<p><!-- {activity-variable-mapping-inject--toc} --></p>

<p>An <code>Inject()</code> filter, as opposed to <code>In()</code>, does an existance check on the ctx using <code>ctx.key?(:variable)</code> before performing its logic. It is helpful in combination with <code>In()</code> filters, when using defaulted keyword arguments in a step or in nested operations.</p>

<ul>
  <li>It allows defaulting a variable when it‚Äôs absent in the ctx.</li>
  <li>It can pass-through a variable when it is present in the ctx, and only then.</li>
</ul>

<p>Check the following exemplary policy code.</p>

<pre><code>module Policy
  class Check
                                    # vvvvvvvvvvvvvvv-- defaulted keyword arguments
    def self.call(ctx, model:, user:, action: :create, **)
      decision = ApplicationPolicy.can?(model, user, action) # FIXME: how does pundit/cancan do this exactly?
      # ...
    end
  end
end
</code></pre>

<p>This policy implementation uses keyword arguments to automatically extract <code>:model</code>, <code>:user</code> and <code>:action</code> from the ctx. Note that the latter is defaulted to <code>:create</code>. Defaulting kwargs only works when the keyword variable is <strong>not passed</strong> into the step - if it‚Äôs <code>nil</code>, the defaulting will not get triggered.</p>

<p>You could now use <code>In()</code> filters to embed this policy step into your operation.</p>

<pre><code>class Create &lt; Trailblazer::Activity::Railway
  step :create_model
  step Policy::Check,
    In() =&gt; {:current_user =&gt; :user},
    In() =&gt; [:model, :action]
  # ...
end
</code></pre>

<p>However, this will break because the <code>action</code> variable will never be defaulted to <code>:create</code>. The <code>In()</code> filter will <em>always</em> pass <code>:action</code> through when calling the policy, even when it‚Äôs absent.</p>

<p>The <code>Inject()</code> helper is designed to handle this case.</p>

<p><span class="divider"></span></p>

<ul class="navigation">
    <li>Inject()</li>
    <li id="activity-variable-mapping-inject-array-style">Array style</li>
</ul>

<p>Use <code>Inject()</code> in combination with <code>In()</code> to add variables to the filtered ctx, but only when they‚Äôre present in the outer ctx.</p>

<pre><code>class Create &lt; Trailblazer::Activity::Railway
  step :create_model
  step Policy::Check,
    In() =&gt; {:current_user =&gt; :user},
    In() =&gt; [:model],
    Inject() =&gt; [:action]
  # ...
end
</code></pre>

<p>We call this <em>qualified pass-through</em>, it means the <code>:action</code> variable will only be passed into the filtered ctx if it exists on <code>ctx</code> when the filter is invoked.</p>

<p><span class="divider"></span></p>

<ul class="navigation">
    <li>Inject()</li>
    <li id="activity-variable-mapping-inject-defaulting">Defaulting</li>
</ul>

<p>Instead of hard-wiring defaulted keyword arguments into your step implementations, you can configure <code>Inject()</code> to set a default value to variables, if they‚Äôre absent in the ctx.</p>

<p>Here‚Äôs an example policy without any defaulting in the signature.</p>

<pre><code>module Policy
  class Check
                                    # vvvvvvv-- no defaulting!
    def self.call(ctx, model:, user:, action:, **)
      decision = ApplicationPolicy.can?(model, user, action) # FIXME: how does pundit/cancan do this exactly?
      # ...
    end
  end
end
</code></pre>

<p>Defaulting the <code>:action</code> variable via <code>Inject()</code> will improve the policy component‚Äôs reusability.</p>

<pre><code>class Create &lt; Trailblazer::Activity::Railway
  step :create_model
  step Policy::Check,
    In() =&gt; {:current_user =&gt; :user},
    In() =&gt; [:model],
    Inject() =&gt; {
      action: -&gt;(ctx, **) { :create }
    }
  # ...
end
</code></pre>

<p>The lambda is executed at runtime, just before the actual step is invoked. It provides access to the ctx object and allows extracting keyword arguments.</p>

<p><span class="divider"></span></p>

<h3 id="activity-variable-mapping-macro">Macro</h3>
<p><!-- {activity-variable-mapping-macro-toc} --></p>

<p>As all DSL options the <code>In()</code>, <code>Out()</code> and <code>Inject()</code> helpers can be used from macros, providing the macro author a convenient way to define default filters. <a href="/2.1/docs/activity.html#activity-macro-api"><i class="fa fa-book" aria-hidden="true"></i> API docs</a></p>

<pre><code>module Policy
  def self.Create()
    {
      task: Policy::Create,
      wrap_task: true,
      Trailblazer::Activity::Railway.In()  =&gt; {:current_user =&gt; :user},
      Trailblazer::Activity::Railway.In()  =&gt; [:model],
      Trailblazer::Activity::Railway.Out() =&gt; {:message =&gt; :message_from_policy},
    }
  end
end
</code></pre>

<p>In the options hash that a macro must return, you can use the helpers by referencing <code>Trailblazer::Activity::Railway</code>. Except for the prefixed constant, there is no difference or limitation to their usage.</p>

<p>They can be extended with options the macro user provides.</p>

<pre><code>class Create &lt; Trailblazer::Activity::Railway
  step :create_model
  step Policy::Create(),
    Out() =&gt; {:message =&gt; :copied_message} # user options!
  # ...
end
</code></pre>

<p>The user options will be merged into the macro options, resulting in <code>:message</code> being renamed to <code>:message_from_policy</code> and copied to <code>:copied_message</code>.</p>

<div class="bd-callout bd-callout-info">
<p>Before <code>trailblazer-activity-dsl-linear-1.0.0</code> and the <code>In()</code> and <code>Out()</code> helper shipped with it, any <code>:input</code> from the user would always override the macro‚Äôs <code>:input</code> option.</p>
</div>

<p><span class="divider"></span></p>

<h3 id="activity-variable-mapping-inheritance">Inheritance</h3>
<p><!-- {activity-variable-mapping-inheritance-toc} --></p>

<p>Subclasses can add and remove input and output filters - hence the term <em>composable</em>. This is a great tool when inherited operations replace particular steps and need to fine-tune ingoing or returned variables.</p>

<p>Consider the following base operation.</p>

<pre><code>class Create &lt; Trailblazer::Activity::Railway
  extend Trailblazer::Activity::DSL::Linear::VariableMapping::Inherit # this has to be done on the root level!

  step :create_model
  step Policy::Create,
    In() =&gt; {:current_user =&gt; :user},
    In() =&gt; [:model],
    Out() =&gt; [:message],
    id: :policy
  # ...
end
</code></pre>

<p>It defines two input and one output filter.</p>

<p>A sub operation could now replace the policy step. However, instead of redefining the i/o filters, they can be inherited and extended.</p>

<div class="bd-callout bd-callout-info">
<p>As <code>inherit: [:variable_mapping]</code> is still an experimental feature, you need to explicitely <code>extend</code> the <code>VariableMapping::Inherit</code> module into the top-most operation where the inheritance chain should begin.</p>
</div>

<p>Here‚Äôs a potential inheriting operation.</p>

<pre><code>class Admin &lt; Create
  step Policy::Create,
    Out() =&gt; {:message =&gt; :raw_message_for_admin},
    inherit: [:variable_mapping],
    id: :policy,      # you need to reference the :id when your step
    replace: :policy
end
</code></pre>

<p>This configuration is adding another <code>Out()</code> filter, resulting in a total filter setup as follows in the introspection.</p>

<pre><code>puts Trailblazer::Developer::Render::TaskWrap.(Admin, id: :policy)

ComposableVariableMappingDocTest::EEE::Admin
# `-- policy
#     |-- task_wrap.input..................Trailblazer::Activity::DSL::Linear::VariableMapping::Pipe::Input
#     |   |-- input.init_hash.............................. ............................................. VariableMapping.initial_aggregate
#     |   |-- input.add_variables.0.994[...]............... {:current_user=&gt;:user}....................... VariableMapping::AddVariables
#     |   |-- input.add_variables.0.592[...]............... [:model]..................................... VariableMapping::AddVariables
#     |   `-- input.scope.................................. ............................................. VariableMapping.scope
#     |-- task_wrap.call_task..............Method
#     `-- task_wrap.output.................Trailblazer::Activity::DSL::Linear::VariableMapping::Pipe::Output
#         |-- output.init_hash............................. ............................................. VariableMapping.initial_aggregate
#         |-- output.add_variables.0.599[...].............. [:message]................................... VariableMapping::AddVariables::Output
#         |-- output.add_variables.0.710[...].............. {:message=&gt;:raw_message_for_admin}........... VariableMapping::AddVariables::Output
#        `-- output.merge_with_original................... ............................................. VariableMapping.merge_with_original
</code></pre>

<p>The new <code>Out()</code> filter setting <code>:raw_message_for_admin</code> is placed behind the inherited filter.</p>

<!--


TODO: decompose trick (input )
-->

<p><span class="divider"></span></p>

<h3 id="activity-variable-mapping-introspect">Introspect</h3>
<p><!-- {activity-variable-mapping-introspect-toc} --></p>

<p>You can visualize the pipelines around each step by using the <code>trailblazer-developer</code> gem.</p>

<pre><code>puts Trailblazer::Developer::Render::TaskWrap.(Song::Operation::Create, id: :policy)
</code></pre>

<p>This handy invocation will render the task wrap around <code>Song::Operation::Create</code>‚Äôs step <code>:policy</code>.</p>

<pre><code>Song::Operation::Create
`-- policy
    |-- task_wrap.input..................Trailblazer::Activity::DSL::Linear::VariableMapping::Pipe::Input
    |   |-- input.init_hash.............................. ............................................. VariableMapping.initial_aggregate
    |   |-- input.add_variables.0.994[...]............... {:current_user=&gt;:user}....................... VariableMapping::AddVariables
    |   |-- input.add_variables.0.592[...]............... [:model]..................................... VariableMapping::AddVariables
    |   `-- input.scope.................................. ............................................. VariableMapping.scope
    |-- task_wrap.call_task..............Method
    `-- task_wrap.output.................Trailblazer::Activity::DSL::Linear::VariableMapping::Pipe::Output
        |-- output.init_hash............................. ............................................. VariableMapping.initial_aggregate
        |-- output.add_variables.0.599[...].............. [:message]................................... VariableMapping::AddVariables::Output
        `-- output.merge_with_original................... ............................................. VariableMapping.merge_with_original
</code></pre>

<p>In i/o context, the interesting branches here are <code>task_wrap.input</code> and <code>task_wrap.output</code>. Sandwiched between generic library steps are your filter steps. The visualizer even renders filter configuration where possible.</p>

<div class="bd-callout bd-callout-info">
<p>We‚Äôre planning improvements on this part of <code>trailblazer-developer</code>. If you want to help out with better rendering, please <a href="https://trailblazer.zulipchat.com">come chat to us</a>.</p>
</div>

<p><span class="divider"></span></p>

<h3 id="activity-variable-mapping-input-output">Input / Output</h3>
<p><!-- {activity-variable-mapping-input-output-toc} --></p>

<p>Before the introduction of the composable <code>In()</code>, <code>Out()</code> and <code>Inject()</code> filters, variable mapping was done with the <code>:input</code> and <code>:output</code> option. This is still supported and not planned to be dropped. However, there are a bunch of drawbacks with using the monolithic, non-composable options.</p>

<div class="bd-callout bd-callout-info">
<p>With <code>trailblazer-2.1.1</code> and the bundled <code>trailblazer-activity-dsl-linear-1.0.0</code> gems, the recommended way of I/O is using <a href="">composable variable mapping</a> via <code>In()</code> and <code>Out()</code>.</p>
</div>

<p><img class="mx-auto d-block" src="/vite-dev/images/input.webp" /></p>

<p>The <code>:input</code> filter is normally used to create a new context that limits what its task sees.</p>

<p><img class="mx-auto d-block" src="/vite-dev/images/output.webp" /></p>

<p>With the <code>:output</code> filter, you can control what variables go from the inner scoped context to the outer.</p>

<p>Without any I/O configuration, all values written in a task to <code>ctx</code> will be visible in the following tasks. This might - sometimes - lead to context pollution or, even worse, certain tasks ‚Äúseeing‚Äù wrong values.</p>

<p>When using the DSL, the filter options <code>:input</code> and <code>:output</code> are your interface for variable mapping.</p>

<p>Please note that I/O works for both ‚Äúsimple‚Äù tasks as well as nested activities.</p>

<p><span class="divider"></span></p>

<ul class="navigation">
    <li>Input / Output</li>
    <li id="activity-variable-mapping-input-output-overview">Overview</li>
</ul>

<p>The variable mapping API provides some shortcuts to control the scope.</p>

<pre><code>class Memo::Create &lt; Trailblazer::Activity::Path
  step :authorize, input: [:params], output: {user: :current_user}
  step :create_model

  # ...
end
</code></pre>

<p>An array value such as <code>[:params]</code> passed to <code>:input</code> will result in the configured task only ‚Äúseeing‚Äù the provided list of variables. All other values are not available, mimicking a whitelist.</p>

<p>A hash value (e.g. <code>{user: :current_user}</code>) acts like a variable mapping directive. With <code>:output</code>, it will only expose the variables mentioned in the hash, but rename them to the specifed value.</p>

<pre><code>def authorize(ctx, params:, **)
  ctx[:user] = User.find(params[:id])

  if ctx[:user]
    ctx[:result] = "Found a user."
  else
    ctx[:result] = "User unknown."
  end
end
</code></pre>

<p>In the <code>#authorize</code> example, the following happens.</p>

<ol>
  <li>The task receives a context with only one variable set, which is <code>:params</code> passed into the activity invocation.</li>
  <li>In the task, it may write (and pollute) the <code>ctx</code> object as much as it wants. It‚Äôs a scoped, private ctx object that will be discarded after the task is finished. This leads to the <code>:result</code> variable being thrown away.</li>
  <li>Before the private <code>ctx</code> gets disposed of, its <code>:user</code> key gets copied into the original <code>ctx</code> under the name <code>:current_user</code>.</li>
  <li>The following task <code>create_model</code> will see the original ctx plus <code>:current_user</code> that was written in the previous step using <code>:output</code>.</li>
</ol>

<pre><code>signal, (ctx, flow_options) = Trailblazer::Activity::TaskWrap.invoke(A::Memo::Create, [{params: {id: 1}}, {}])
</code></pre>

<p>An array passed to <code>:output</code> will exclusively copy the specified variables to the original ctx, only.</p>

<p>A hash passed to <code>:input</code> results in the called task only ‚Äúseeing‚Äù the specified variables, but renamed to the hash values.</p>

<p><span class="divider"></span></p>

<ul class="navigation">
    <li>Input / Output</li>
    <li id="activity-variable-mapping-input-output-callable">Callable</li>
</ul>

<p>As usual, you may provide your own code for dynamic filtering or renaming.</p>

<pre><code>class Memo::Create &lt; Trailblazer::Activity::Path
  step :authorize,
    input:  -&gt;(original_ctx, **) do {params: original_ctx[:parameters]} end,
    output: -&gt;(scoped_ctx, **) do {current_user: scoped_ctx[:user]} end
  step :create_model

  # ...
end
</code></pre>

<p>From the <code>:input</code> callable, you can return a hash containing the values that <code>#authorize</code> may see. All other variables you don‚Äôt include in that hash will be unavailable. This is called a <em>scope</em> and resembles the arguments you pass into a normal Ruby method along with a method that doesn‚Äôt have access to variables outside its scope.</p>

<p>Trailblazer will automatically create a new <code>Context</code> object around your custom input hash. You can write to that without interferring with the original context.</p>

<p>The <code>:output</code> callable receives the scoped, new context object that you wrote to in <code>#authorize</code>. In <code>:output</code>, you return the hash of variables that you want to be visible in the following steps. This hash will be automatically merged into the original context.</p>

<p>In both filters, you‚Äôre able to rename and coerce variables. This gives you a bit more control than the simpler DSL.</p>

<p><span class="divider"></span></p>

<ul class="navigation">
    <li>Input / Output</li>
    <li id="activity-variable-mapping-input-output-filter-methods">Filter Methods</li>
</ul>

<p>For better readability, you may use instance methods for your filters.</p>

<pre><code>class Memo::Create &lt; Trailblazer::Activity::Path
  step :authorize,
    input:  :authorize_input,
    output: :authorize_output

  def authorize_input(original_ctx, **)
    {params: original_ctx[:parameters]}
  end

  def authorize_output(scoped_ctx, user:, **)
    {current_user: scoped_ctx[:user]}
  end
</code></pre>

<p>They receive the identical set of arguments that other callables are called with.</p>

<p><span class="divider"></span></p>

<ul class="navigation">
    <li>Input / Output</li>
    <li id="activity-variable-mapping-input-output-keyword-arguments">Keyword Arguments</li>
</ul>

<p>You may use keyword arguments in your filters for type safety and better readable code.</p>

<pre><code>step :authorize,
  input:  -&gt;(original_ctx, parameters:, **) do {params: parameters} end,
  output: -&gt;(scoped_ctx, user:, **) do {current_user: user} end
</code></pre>

<ul>
  <li><code>:input</code> provides all variables from the original context as kw args.</li>
  <li><code>:output</code> will receive a list of all variables you added to the scoped, inner context.</li>
</ul>

<p><span class="divider"></span></p>

<ul class="navigation">
    <li>Input / Output</li>
    <li id="activity-variable-mapping-input-output-with-outer-ctx">With Outer Ctx</li>
</ul>

<p>It is possible to access the outer context (in addition to the inner ctx) in an <code>:output</code> filter using the <code>:output_with_outer_ctx</code> DSL option.</p>

<pre><code>step :authorize,
  output_with_outer_ctx: true, # tell TRB you want {outer_ctx} in the {:output} filter.
  output: -&gt;(inner_ctx, outer_ctx, user:, **) do
    {
      current_user: user,
      params:       outer_ctx[:params].merge(errors: false)
    }
  end
</code></pre>

<p>The <code>:output</code> filter then receives a second positional argument which is the original, outer context. This is helpful if you want to merge new values into existing datastructures, such as error objects.</p>

<p>As usual, the returned hash is then merged into the outer context.</p>

<div class="bd-callout bd-callout-info">
<p>The <code>:output_with_outer_ctx</code> option is available since <code>trailblazer-activity-dsl-linear-0.4.0</code>.</p>
</div>

<p><span class="divider"></span></p>

<ul class="navigation">
    <li>Input / Output</li>
    <li id="activity-variable-mapping-input-output-notes">Notes</li>
</ul>

<p>¬†</p>

<ul>
  <li>You can mix any <code>:input</code> style with any <code>:output</code> style.</li>
  <li><strong>CTX MANAGEMENT</strong> Using I/O filters always results in a new, scoped context being created in <code>:input</code> (containing your filtered variables), and disposing of that very context in <code>:output</code> (copying desired variables over to the original ctx).</li>
  <li><strong>LOW-LEVEL API</strong> Please note that the I/O DSL is only providing the most-used requirements. Feel free to use the low-level taskWrap API to build your own variable mapping with different scoping techniques.</li>
  <li><strong>DEFAULTS</strong> When omitting either <code>:input</code> or <code>:output</code>, defaults will be provided. Default <code>:input</code> will pass through all variables. Default <code>:output</code> copies all written variables from the scoped context to the original one.</li>
</ul>

<p><span class="divider"></span></p>

<h2 id="activity-dependency-injection">Dependency Injection</h2>
<p><!-- {activity-dependency-injection-toc} --></p>

<div class="bd-callout bd-callout-info">
<p>WIP: This section is not final, yet.
TODO: maybe use Operation API instead?</p>
</div>

<p><span class="divider"></span></p>

<h3 id="activity-dependency-injection-overview">Overview</h3>
<p><!-- {activity-dependency-injection-overview-toc} --></p>

<p>Very often your activity or one of the steps contained require particular objects and values to get their job done. Instead of hard-wiring those <em>‚Äúdependencies‚Äù</em> in the code it is good style to allow providing those objects by passing them into the activity at run-time. This is called dependency injection and is a <a href="https://en.wikipedia.org/wiki/Dependency_injection">common technique</a> in software engineering.</p>

<p>One way for using dependency injection is using keyword arguments for variables you need, and defaulting those in the step signature.</p>

<pre><code>class Log &lt; Trailblazer::Activity::Railway # could be Operation, too.
  step :write
  # ...
  def write(ctx, time: Time.now, **) # {:time} is a dependency.
    ctx[:log] = "Called @ #{time}!"
  end
</code></pre>

<p>The <code>#write</code> step requires a variable <code>:time</code>, which is a dependency. The variable‚Äôs default is hard-wired and applied if no other value is provided. However, by injecting <code>:time</code> when invoking the activity, you can override this value at run-time.</p>

<pre><code>signal, (ctx, _) = Trailblazer::Activity::TaskWrap.invoke(Log, [{time: "yesterday"}, {}])
</code></pre>

<p>This is extremely helpful when you have to replace a ‚Äúhard-wired‚Äù dependency, for example in a test where you want to know and define <code>:time</code>‚Äôs value upfront.</p>

<p><span class="divider"></span></p>

<h3 id="activity-dependency-injection-inject">Inject</h3>
<p><!-- {activity-dependency-injection-inject-toc} --></p>

<p>The <code>:inject</code> option allows to pass through injected variables without having to add them in the <code>:input</code> filter code. It also provides a way to default variables should they not have been passed from the outside.</p>

<div class="bd-callout bd-callout-info">
<p>The <code>:inject</code> was introduced in <code>trailblazer-activity-dsl-linear</code> 0.4.3 and is still considered experimental. Use it, but be reasonable and keep in mind that syntactical API might change.</p>
</div>

<p>When using <code>:inject</code> <strong>without</strong> <code>:input</code> there won‚Äôt be any filtering happening. The original ctx with all its variables will be passed into the step.</p>

<p>As usual, the option can be used with both nested operations/activities and callable steps.</p>

<p><span class="divider"></span></p>

<ul class="navigation">
    <li>Inject</li>
    <li id="activity-dependency-injection-inject-qualified-pass-through">Qualified Pass-through</li>
</ul>

<p>The most commonly used style for <code>:inject</code> is the pass-through array. When used in combination with <code>:input</code> this allows to reduce the <code>:input</code> filter code.</p>

<p>Check the following snippet. It‚Äôs a common pattern in many TRB applications to use an <code>:input</code> filter to limit variables going into the subprocess. Anyways, when you have defaulted variables in the subprocess, you should only add those to your <code>:input</code> when they‚Äôre actually defined by the invoker - or passed from the outside.</p>

<pre><code>class Create &lt; Trailblazer::Activity::Railway # could be Operation, too.
  # ...
  step Subprocess(Log),
    input:  -&gt;(ctx, model:, **) {
      { model: model }                                  # always pass {:model}
      .merge(ctx.key?(:time) ? {time: ctx[:time]} : {}) # only add {:time} when it's there.
    }
end
</code></pre>

<p>Quickly, the code gets messy as you constantly need to check whether or not the dependency is injected.</p>

<p><span class="divider"></span></p>

<ul class="navigation">
    <li>Inject</li>
    <li id="activity-dependency-injection-inject-array-style">array style</li>
</ul>

<p>Use the <code>:inject</code> option to automatically add injected variables when they‚Äôre present in <code>ctx</code>.</p>

<pre><code>class Create &lt; Trailblazer::Activity::Railway # could be Operation, too.
  # ...
  step Subprocess(Log),
    input:  -&gt;(ctx, model:, **) { {model: model} }, # always pass {model}
    inject: [:time] # only pass {:time} when it's in ctx.
end
</code></pre>

<p>Depending on the variables passed into the activity, the <code>ctx</code> going into <code>Log</code> will look as follows.</p>

<pre><code>#                                 ctx for {Log}
Create.({})                  #=&gt; {model: XXX}
Create.({time: "yesterday"}) #=&gt; {model: XXX, time: "yesterday"}
</code></pre>

<p>Note that this (currently) only has effects when combined with <code>:input</code>.</p>

<p><span class="divider"></span></p>

<ul class="navigation">
    <li>Inject</li>
    <li id="activity-dependency-injection-inject-defaulting">defaulting</li>
</ul>

<p>Instead of defaulting injected variables in the method signature, you can define a more convenient defaulting injection using <code>:inject</code>. Obviously, the affected steps should not use defaulted kwargs for variables that have defaulting happen via <code>:inject</code>.</p>

<pre><code>class Log &lt; Trailblazer::Activity::Railway # could be Operation, too.
  step :write
  # ...
  def write(ctx, time: Time.now, date:, **) # {date} has no default configured.
    ctx[:log] = "Called @ #{time} and #{date}!"
  end
</code></pre>

<p>In this example, we use Ruby‚Äôs defaulting for the <code>:time</code> kwarg, and make <code>:date</code> a required kwarg without any defaulting.</p>

<p>The <code>:inject</code> option with a hash allows for configuring defaulting for any number of injected variables.</p>

<pre><code>class Create &lt; Trailblazer::Activity::Railway # could be Operation, too.
  # ...
  step Subprocess(Log),
    input:  -&gt;(ctx, model:, **) { {model: model} }, # always pass {model}
    inject: [:time, {date: -&gt;(ctx, **) { Date.today }}]
end
</code></pre>

<p>In the proc, you have access to the original <code>ctx</code> and its variables via keyword arguments.</p>

<p>Depending on the variables passed into the activity, the <code>ctx</code> going into <code>Log</code> will look as follows.</p>

<pre><code>#                                         ctx for {Log}
Create.({})                           #=&gt; {model: XXX, date: &lt;today&gt;}
Create.({time: "now", date: "today"}) #=&gt; {model: XXX, time: "now", date: "today"}
</code></pre>

<p>Note that defaulted injects are always processed and either added to the original context when used without <code>:input</code> or to the new, filtered context when using it in combination with <code>:input</code>.</p>

<p><span class="divider"></span></p>

<h3 id="activity-dependency-injection-mapping">Mapping</h3>
<p><!-- {activity-dependency-injection-mapping-toc} -->
TODO</p>

<p><span class="divider"></span></p>

<h3 id="activity-dependency-injection-dry-container">Dry container</h3>
<p><!-- {activity-dependency-injection-dry-container-toc} -->
TODO</p>

<p>defaulting in macros</p>

<p><span class="divider"></span></p>

<h2 id="activity-macro-api">Macro API</h2>
<p><!-- {activity-macro-api-toc} --></p>

<p>Macros are short-cuts for inserting a task along with options into your activity.</p>

<p><span class="divider"></span></p>

<h3 id="activity-macro-api-definition">Definition</h3>
<p><!-- {activity-macro-api-definition-toc} --></p>

<p>They‚Äôre simple functions that return a hash with options described here.</p>

<pre><code>module MyMacro
  def self.NormalizeParams(name: :myparams, merge_hash: {})
    task = -&gt;((ctx, flow_options), _) do
      ctx[name] = ctx[:params].merge(merge_hash)

      return Trailblazer::Activity::Right, [ctx, flow_options]
    end

    # new API
    {
      task: task,
      id:   name
    }
  end
end
</code></pre>

<p>Two required options are <code>:id</code> and <code>:task</code>, the latter being the actual task you want to insert. The callable task needs to implement the [circuit interface].</p>

<div class="bd-callout bd-callout-info">
<p>Please note that the actual task doesn‚Äôt have to be a proc! Use a class, constant, object, as long as it exposes a <code>#call</code> method it will flow.</p>
</div>

<p><span class="divider"></span></p>

<h3 id="activity-macro-api-usage">Usage</h3>
<p><!-- {activity-macro-api-usage-toc} --></p>

<p>To actually apply the macro you call the function in combination with <code>step</code>, <code>pass</code>, <code>fail</code>, etc.</p>

<pre><code>class Create &lt; Trailblazer::Activity::Railway
  step MyMacro::NormalizeParams(merge_hash: {role: "sailor"})
end
</code></pre>

<p>There‚Äôs no additional logic from Trailblazer happening here. The function returns a well-defined hash which is passed as an argument to <code>step</code>.</p>

<p><span class="divider"></span></p>

<h3 id="activity-macro-api-options">Options</h3>
<p><!-- {activity-macro-api-options-toc} --></p>

<p>In the returned hash you may insert any valid DSL [step option], such as sequence options like <code>:before</code>, <code>Output()</code> and friends from the wiring API or even <code>:extensions</code>.</p>

<p>The following <code>FindModel</code> macro retrieves a configured model just like <code>trailblazer-macro</code>‚Äôs <code>Model()</code> and automatically wires the step‚Äôs <code>failure</code> output to a new terminus <code>not_found</code>.</p>

<pre><code>module MyMacro
  def self.FindModel(model_class)
    # the inserted task.
    task = -&gt;((ctx, flow_options), _) do
      model         = model_class.find_by(id: ctx[:params][:id])

      return_signal = model ? Trailblazer::Activity::Right : Trailblazer::Activity::Left
      ctx[:model]   = model

      return return_signal, [ctx, flow_options]
    end

    # the configuration needed by Trailblazer's DSL.
    {
      task: task,
      id:   :"find_model_#{model_class}",
      Trailblazer::Activity::Railway.Output(:failure) =&gt; Trailblazer::Activity::Railway.End(:not_found)
    }
  end
end
</code></pre>

<p>See how you can simply add <code>Output</code> wirings by using the well-established mechanics from the wiring API? Remember you‚Äôre not in an <code>Activity</code> or <code>Operation</code> namespace and hence need to use the fully-qualified constant reference <code>Trailblazer::Activity::Railway.Output()</code>.</p>

<p>To insert that step and its extended wiring, simply call the macro.</p>

<pre><code>class Create &lt; Trailblazer::Activity::Railway
  step MyMacro::FindModel(User)
end
</code></pre>

<p>When running the activity without a valid model ID, it will now terminate on <code>End.not_found</code>.</p>

<pre><code>signal, (ctx, _) = Trailblazer::Developer.wtf?(User::Create, [{params: {id: nil}}])
signal #=&gt; #&lt;Trailblazer::Activity::End semantic=:not_found&gt;

`-- User::Create
    |-- Start.default
    |-- find_model_User
    `-- End.not_found
</code></pre>

<p>Using the wiring API in your own macros gives you a powerful tool for harnessing extended wiring without requiring the user to know about the details - the crucial point for a good API.</p>

<p><span class="divider"></span></p>

<ul class="navigation">
    <li>Options</li>
    <li id="activity-macro-api-options-subprocess">Subprocess</li>
</ul>

<p>You can even use other macros in custom macros, such as the <a href="#activity-wiring-api-subprocess"><code>Subprocess()</code> helper</a> for nesting activities.</p>

<p>Consider the following <code>Logger</code> activity.</p>

<pre><code>class Logger &lt; Trailblazer::Activity::Railway
  step :log

  def log(ctx, logged:, **)
    ctx[:log] = logged.inspect
  end
end
</code></pre>

<p>Along with the nested <code>Logger</code> step should also go <code>:input</code> and <code>:output</code> configuration. When using the <code>Logger</code> in multiple operation, you would need to repeat the options, so why not pack the entire configuration in a macro?</p>

<pre><code>module Macro
  def self.Logger(logged_name: )
    {
      id: "logger",
      input:  {logged_name =&gt; :logged},
      output: [:log],
      **Trailblazer::Activity::Railway.Subprocess(Logger), # nest
    }
  end
end
</code></pre>

<p>The nesting activity can now elegantly use the macro without inconvenient options.</p>

<pre><code>class Create &lt; Trailblazer::Activity::Railway
  step Macro::Logger(logged_name: :model) # we want to log {ctx[:model]}
end
</code></pre>

<p><span class="divider"></span></p>

<h2 id="activity-internals">Internals</h2>
<p><!-- {activity-internals-toc} --></p>

<p>This section discusses low-level structures and is intended for engineers interested in changing or adding their own DSLs, the activity build process, or who want to optimize the Trailblazer internals (which is always appreciated!).</p>

<p><span class="divider"></span></p>

<h3 id="activity-internals-introspection-api">Introspection API</h3>
<p><!-- {activity-internals-introspection-api-toc} --></p>

<p>To find out the structure and composition details about any activity, use the <code>Introspect</code> API.</p>

<p><span class="divider"></span></p>

<ul class="navigation">
    <li>Introspection API</li>
    <li id="activity-internals-introspection-api-find">Find</li>
</ul>

<p>You may use <code>Graph#find</code> with a block for a more complex search.</p>

<pre><code>node = graph.find { |node| node.task.class == Trailblazer::Activity::TaskBuilder }
</code></pre>

<p>Alternatively, using the <code>Graph#find</code> method with an ID provided, you can retrieve a particular node in the activity‚Äôs circuit.</p>

<p>Consider the following activity.</p>

<pre><code>class Memo::Update &lt; Trailblazer::Activity::Railway
  step :find_model
  step :validate, Output(:failure) =&gt; End(:validation_error)
  step :save
  fail :log_error
end
</code></pre>

<p>You can introspect a certain element by using <code>find(id)</code>.</p>

<pre><code>graph = Trailblazer::Activity::Introspect.Graph(Memo::Update)

node = graph.find(:validate)
</code></pre>

<p>Note that all queries go via a <code>Graph</code> instance.</p>

<p><span class="divider"></span></p>

<ul class="navigation">
    <li>Introspection API</li>
    <li id="activity-internals-introspection-api-node-api">Node API</li>
</ul>

<p>The returned node instance exposes several inspect helpers.</p>

<p>The ID of the element is retrieved by using <code>#id</code>.</p>

<pre><code># puts node.id.inspect #=&gt; :validate
</code></pre>

<p>To see what actual task sits behind this circuit‚Äôs node, use <code>#task</code>. This is always the low-level task that responds to a circuit interface. It might be a wrapper around your actual logic, provided by the DSL.</p>

<pre><code># puts node.task       #=&gt; #Trailblazer::Activity::TaskBuilder::Task user_proc=validate&gt;
</code></pre>

<p>Outgoing connections from a task can be queried using <code>#outgoings</code>. This returns an array of all outgoing arrows.</p>

<pre><code># left, right = node.outgoings # returns array
</code></pre>

<p><span class="divider"></span></p>

<ul class="navigation">
    <li>Introspection API</li>
    <li id="activity-internals-introspection-api-outgoing">Outgoing</li>
</ul>

<p>An <code>Outgoing</code> provides several interesting fields.</p>

<p>You can retrieve the connected element by using <code>#task</code>. It returns the actual low-level task.</p>

<pre><code># puts left.task #=&gt; #Trailblazer::Activity::End semantic=:validation_error&gt;
</code></pre>

<p>The <code>#output</code> method returns the <code>Output</code> instance that connects the task to the next element.</p>

<pre><code># puts left.output.signal   #=&gt; Trailblazer::Activity::Left
# puts left.output.semantic #=&gt; :failure
</code></pre>

<p>The <code>Output#signal</code> field returns the signal object the task returns to trigger that connection. To see the semantic of this output, use <code>Output#semantic</code>.</p>

<p><span class="divider"></span></p>

<ul class="navigation">
    <li>Introspection API</li>
    <li id="activity-internals-introspection-api-outputs">Outputs</li>
</ul>

<p>The <code>Node#outputs</code> method returns an array of <code>Output</code> objects defining each output of outgoing connections of a specific node.</p>

<pre><code>outputs = node.outputs
left = outputs[0] #=&gt; output object
</code></pre>

<p><span class="divider"></span></p>

<h3 id="activity-internals-build-structures">Build Structures</h3>
<p><!-- {activity-internals-build-structures-toc} --></p>

<p>The Activity DSL is only one way to define activities. Under the hood, the DSL simply creates a handful of generic objects such as an <em>intermediate</em> structure or an <em>implementation</em>. Those standardized objects then get compiled into an <code>Activity</code> instance to be used at run-time.</p>

<p><img class="mx-auto d-block" src="/vite-dev/images/dsl_to_activity.webp" /></p>

<p>This section discusses those underlying concepts - it will be helpful if you want to better understand how the DSL works, write your own DSL or generate activities from your own editor.</p>

<p><span class="divider"></span></p>

<ul class="navigation">
    <li>Build Structures</li>
    <li id="activity-internals-build-structures-intermediate">Intermediate</li>
</ul>

<p>When defining an activity, two objects are used: an <code>Intermediate</code> and an <code>Implementation</code> structure. The intermediate object is a generic definition of the <strong>structure</strong> of the activity: which task got what connections?</p>

<p><img class="mx-auto d-block" src="/vite-dev/images/intermediate.webp" /></p>

<p>It simply lists all tasks, along with the connections they have. The little gray bubbles on the task border are <em>outputs</em>. An output has a certain <em>semantic</em> plus a connection (an arrow) pointing to the following task.</p>

<pre><code>Intermediate = Trailblazer::Activity::Schema::Intermediate # shortcut alias.

intermediate = Intermediate.new(
    {
        Intermediate::TaskRef(:"Start")  =&gt; [Intermediate::Out(:success, :A)],
        Intermediate::TaskRef(:A)        =&gt; [Intermediate::Out(:success, :B),
                                             Intermediate::Out(:failure, :C)],
        Intermediate::TaskRef(:B)        =&gt; [Intermediate::Out(:success, :"End")],
        Intermediate::TaskRef(:C)        =&gt; [Intermediate::Out(:success, :B)],
        Intermediate::TaskRef(:"End", stop_event: true) =&gt; [Intermediate::Out(:success, nil)] # :)
    },
    [:"End"],   # end events
    [:"Start"], # start
)
</code></pre>

<p>Basically, it resembles a hash where the key is an <code>Intermediate::TaskRef</code> instance referencing a task‚Äôs ID, and its values an array of possible <code>Intermediate::Out</code> outputs going from this very task. Again, only IDs are used to point to the following task.</p>

<p>An <code>Intermediate</code> structure is not used at run-time. It might come from a DSL, or from a generator, for example, from the PRO editor.</p>

<p>The idea is to allow serializing intermediate structures without a complex deserialization of task logic. Only task IDs are referenced, and no signal objects used. Instead, the heavy-lifting after defining the structure is done in the <code>Implementation</code>.</p>

<p><span class="divider"></span></p>

<ul class="navigation">
    <li>Build Structures</li>
    <li id="activity-internals-build-structures-implementation">Implementation</li>
</ul>

<p>After defining the structure, the actual start and end events, and the tasks have to be specified. This happens in an <code>Implementation</code> object. It references ‚Äúreal‚Äù Ruby callables for each task. Usually, tasks and events are defined in some sort of namespace or module.</p>

<pre><code>module Upsert
  module_function

  def a((ctx, flow_options), *)
    ctx[:seq] &lt;&lt; :a
    return Trailblazer::Activity::Right, [ctx, flow_options]
  end

  # ~mod
  extend T.def_tasks(:b, :c)
  # ~mod end
end

start = Activity::Start.new(semantic: :default)
_end  = Activity::End.new(semantic: :success)
</code></pre>

<p>The implementation object lists all the tasks and events.</p>

<pre><code>Activity = Trailblazer::Activity # shortcut alias.
Implementation = Trailblazer::Activity::Schema::Implementation

implementation = {
    :"Start"  =&gt; Implementation::Task(start,             [Activity::Output(Activity::Right, :success)], []),
    :A        =&gt; Implementation::Task(Upsert.method(:c), [Activity::Output(Activity::Right, :success),
                                                          Activity::Output(Activity::Left, :failure)],  []),
    :B        =&gt; Implementation::Task(Upsert.method(:c), [Activity::Output(Activity::Right, :success)], []),
    :C        =&gt; Implementation::Task(Upsert.method(:c), [Activity::Output(Activity::Right, :success)], []),
    :"End"    =&gt; Implementation::Task(_end, [Activity::Output(_end, :success)],                         []), # :)
}
</code></pre>

<p>An <code>Implementation::Task</code> needs the actual Ruby callable that responds to the <a href="#TODO">circuit interface</a> and a list of <code>Activity::Output</code>s. Outputs consist of the actual signal the task returns (like <code>Activity::Right</code>) and a semantic that is needed in the next step, the <code>Activity</code> compilation.</p>

<p>Note that all tasks, even start and end events, need to be defined on this very low-level.</p>

<p><span class="divider"></span></p>

<ul class="navigation">
    <li>Build Structures</li>
    <li id="activity-internals-build-structures-compilation">Compilation</li>
</ul>

<p>In order to combine intermediate structure with the implementation, you need to compile an activity from both.</p>

<pre><code>schema = Intermediate.(intermediate, implementation)

Activity.new(schema)
</code></pre>

<p>This will create a callable <code>Activity</code> instance that you‚Äôre used to.</p>

<!-- @activity-circuit-interface <trailblazer-activity[1.0] activity, circuit interface, low level -->

<p><span class="divider"></span></p>

<h3 id="activity-internals-circuit-interface">Circuit Interface</h3>
<p><!-- {activity-internals-circuit-interface-toc} --></p>

<p>Activities and all tasks (or ‚Äústeps‚Äù) are required to expose a <em>circuit interface</em>. This is the low-level interface. When an activity is executed, all involved tasks are called with that very signature.</p>

<p>Most of the times it is hidden behind the <a href="#FIXME">task interface</a> that you‚Äôre probably used to from your operations when using <code>step</code>. Under the hood, however, all callable circuit elements operate through that very interface.</p>

<p>The circuit interface consists of three things.</p>

<ul>
  <li>A circuit element has to expose a <code>call</code> method.</li>
  <li>The signature of the <code>call</code> method is <code>call((ctx, flow_options), **circuit_options)</code>.</li>
  <li>Return value of the <code>call</code> method is an array of format <code>[signal, [new_ctx, new_flow_options]]</code>.</li>
</ul>

<p>Do not fear those syntactical finesses unfamiliar to you, young padawan.</p>

<pre><code>class Create &lt; Trailblazer::Activity::Railway
  def self.validate((ctx, flow_options), **_circuit_options)
    # ...
    return signal, [ctx, flow_options]
  end

  step task: method(:validate)
end
</code></pre>

<p>Both the <code>Create</code> activity itself and the <code>validate</code> step expose the circuit interface. Note that the <code>:task</code> option for <code>step</code> configures this element as a low-level circuit interface, or in other words, it will skip the wrapping with the task interface.</p>

<p><span class="divider"></span></p>

<ul class="navigation">
    <li>Circuit Interface</li>
    <li id="activity-internals-circuit-interface-invocation">Invocation</li>
</ul>

<p>Maybe it makes more sense now when you see how an activity is called manually? Here‚Äôs how to invoke <code>Create</code>.</p>

<pre><code>ctx          = {name: "Face to Face"}
flow_options = {}

signal, (ctx, _flow_options) = Create.([ctx, flow_options])

signal #=&gt; #&lt;Trailblazer::Activity::End semantic=:success&gt;
ctx    #=&gt; {:name=&gt;\"Face to Face\", :validate_outcome=&gt;true}
</code></pre>

<p>Note that both <code>ctx</code> and <code>flow_options</code> can be just anything. Per convention, they respond to a hash interface, but theoretically it‚Äôs up to you how your network of activities and tasks communicates.</p>

<p>Check the implementation of <code>validate</code> to understand how you return a different signal or a changed <code>ctx</code>.</p>

<pre><code>def self.validate((ctx, flow_options), **_circuit_options)
  is_valid = ctx[:name].nil? ? false : true

  ctx    = ctx.merge(validate_outcome: is_valid) # you can change ctx
  signal = is_valid ? Trailblazer::Activity::Right : Trailblazer::Activity::Left

  return signal, [ctx, flow_options]
end
</code></pre>

<p>Make sure to always stick to the <code>return</code> signature on the circuit interface level.</p>

<p><span class="divider"></span></p>

<ul class="navigation">
    <li>Circuit Interface</li>
    <li id="activity-internals-circuit-interface-signature">Signature</li>
</ul>

<p>The circuit interface is a bit more clumsy but it gives you unlimited power over the way the activity will be run. And trust us, we‚Äôve been playing with different APIs for two years and this was the easiest and fastest outcome.</p>

<pre><code>def self.validate((ctx, flow_options), **_circuit_options)
  # ...
  return signal, [ctx, flow_options]
end
</code></pre>

<p>The alienating signature uses <a href="https://docs.ruby-lang.org/en/2.1.0/syntax/methods_rdoc.html#label-Array+Decomposition">Ruby‚Äôs decomposition</a> feature. This only works because the first argument for <code>call</code> is actually an array.</p>

<p>Using this interface empowers you to fully take <em>control of the flow‚Ñ¢</em>.</p>

<ul>
  <li>You can return any <code>signal</code> you want, not only the binary style in <em>steps</em>. Do not forget to wire that signal appropriately to the next task, though.</li>
  <li>If needed, the <code>ctx</code> object might be mutated or, better, replaced and a new version returned. This is the place where you‚Äôd start implementing an immutable version of Trailblazer‚Äôs <code>ctx</code>, for instance.</li>
  <li>Advanced features like tracing, input/output filters or type checking leverage the framework argument <code>flow_options</code>, which will be passed onwards through the entire activities flow. Know what you‚Äôre doing when using <code>flow_options</code> and <strong>always return it</strong> even if you‚Äôre not changing it.</li>
  <li>The <code>circuit_options</code> is another framework argument needed to control the start task and more. It is immutable and you don‚Äôt have to return it. The same <code>circuit_options</code> are guaranteed to be passed to all invoked tasks within one activity.</li>
</ul>

<p>Since in 99% the <code>circuit_options</code> are irrelevant for you, it‚Äôs nicer and faster to discard them instantly.</p>

<pre><code class="ruby light code-snippet wow fadeIn">
def validate((ctx, flow_options), *)
  # ...
end
</code></pre>

<p>Use the lonely <code>*</code> squat asterisk to do so.</p>

<p><span class="divider"></span></p>

<ul class="navigation">
    <li>Circuit Interface</li>
    <li id="activity-internals-circuit-interface-circuit-options">Circuit options</li>
</ul>

<p>The last positional argument when <code>call</code>ing an activity or task is called <em>circuit options</em>. It‚Äôs a library-level hash that is guaranteed to be identical for all tasks of an activity. In other words, all tasks of one activity will be called with the same <code>circuit_options</code> hash.</p>

<p>The following options are available.</p>

<p><span class="divider"></span></p>

<ul class="navigation">
    <li>Circuit Interface</li>
    <li id="activity-internals-circuit-interface-start_task">Start_task</li>
</ul>

<p>You can instruct the activity where to start - it doesn‚Äôt have to be the default start event! Use the <code>:start_task</code> option.</p>

<p>Consider this activity.</p>

<pre><code>class Create &lt; Trailblazer::Activity::Railway
  # ...
  step :create
  step :validate
  step :save
end
</code></pre>

<p>Inject the <code>:start_task</code> option via the circuit options. The value has to be the actual callable task object. You can use the [introspection API] to grab it.</p>

<pre><code>circuit_options = {
  start_task: Trailblazer::Activity::Introspect::Graph(B::Create).find { |node| node.id == :validate  }.task
}

signal, (ctx, flow_options) = B::Create.([ctx, flow_options], **circuit_options)
</code></pre>

<p>Starting with <code>:validate</code>, the <code>:create</code> task will be skipped and only <code>:validate</code> and then <code>:save</code> will be executed.</p>

<p>Note that this is a low-level option that should not be used to build ‚Äúreuseable‚Äù activities. If you want different behavior for differing contexts, you should compose different activities.</p>

<p><span class="divider"></span></p>

<ul class="navigation">
    <li>Circuit Interface</li>
    <li id="activity-internals-circuit-interface-exec_context">Exec_context</li>
</ul>

<p>When using the <code>step :method_name</code> DSL style, the <code>:exec_context</code> option controls what object provides the method implementations at runtime.</p>

<p>Usually, <code>Activity#call</code> will automatically set this, but you can invoke the <code>circuit</code> instead, and inject your own <code>exec_context</code>. This allows you to have a separate structure and implementation.</p>

<p>The following activity is such an ‚Äúempty‚Äù structure.</p>

<pre><code>class Create &lt; Trailblazer::Activity::Railway
  step :create
  step :save
end
</code></pre>

<p>You may then use a class, object or module to define the implementation of your steps.</p>

<pre><code>class Create::Implementation
  def create(ctx, params:, **)
    ctx[:model] = Memo.new(params)
  end

  def save(ctx, model:, **)
    ctx[:model].save
  end
end
    end
</code></pre>

<p>This is really just a container of the desired step logic, with the familiar interface.</p>

<p>When invoking the <code>Create</code> activity, you need to call the <code>circuit</code> directly and inject the <code>:exec_context</code> option.</p>

<pre><code>circuit_options = {
  exec_context: C::Create::Implementation.new
}

signal, (ctx, flow_options) = C::Create.to_h[:circuit].([ctx, flow_options], **circuit_options)
</code></pre>

<p>While this bypasses <code>Activity#call</code>, it gives you a powerful tool for advanced activity design.</p>

<p><span class="divider"></span></p>

<ul class="navigation">
    <li>Circuit Interface</li>
    <li id="activity-internals-circuit-interface-dsl">DSL</li>
</ul>

<p>When using the DSL, use the <code>:task</code> option if you want your added task to be called directly with the circuit interface.  This skips the <code>TaskBuilder::Binary</code> wrapping.</p>

<pre><code class="ruby light code-snippet wow fadeIn">
class Create &lt; Trailblazer::Activity::Railway
  # ...
  step task: method(:validate)
end
</code></pre>

<!-- @activity-circuit-interface <trailblazer-activity[1.0] activity, circuit interface, low level -->

<p><a name="activity-internals-task-interface"><!-- old name/link -->
<span class="divider"></span></a></p>

<h3 id="activity-internals-step-interface">Step Interface</h3>
<p><!-- {activity-internals-step-interface-toc} --></p>

<p><em>a.k.a. <strong>Task interface</strong></em></p>

<p>The convenient high-level interface for a task implementation is - surprisingly - called <em>task interface</em>. It‚Äôs the one you will be working with 95% of your time when writing task logic.</p>

<p>This interface comprises of two parts.</p>

<ul>
  <li>The <strong>signature</strong> receives a mutable <code>ctx</code> object, and an optional list of keywords, often seen as <code>(ctx, **)</code>.</li>
  <li>The <strong>return value</strong> can be <code>true</code>, <code>false</code>, or a subclass of <code>Activity::Signal</code> to dictate the control flow.</li>
</ul>

<p>The return value does not control what is the next task. Instead, it informs the circuit runner about its outcome, and the circuit runner will find the task executed next.</p>

<pre><code>module Memo::Operation
  class Create &lt; Trailblazer::Activity::Railway
    def self.create_model(ctx, **)
      attributes = ctx[:attrs]           # read from ctx

      ctx[:model] = Memo.new(attributes) # write to ctx

      ctx[:model].save ? true : false    # return value matters
    end

    step method(:create_model)
    # ...
  end
end
</code></pre>

<p>Components (such as methods or callable objects) exposing the step interface always receive the <code>ctx</code> as the first (and only) positional argument. Keyword arguments may be used to extract variables from the <code>ctx</code>.</p>

<p>Depending on the step‚Äôs logic, you can write variables to the <code>ctx</code> object.</p>

<p>The return value can be either a subclass of <code>Trailblazer::Activity::Signal</code> or it will be evaluated to <code>true</code> or <code>false</code>.</p>

<p><span class="divider"></span></p>

<ul class="navigation">
    <li>Step Interface</li>
    <li id="activity-internals-step-interface-keyword-arguments">Keyword Arguments</li>
</ul>

<p>A cleaner way to access data from the <code>ctx</code> object is to use keyword arguments in the method signature. Trailblazer makes all <code>ctx</code> options available as kw args.</p>

<pre><code>def self.create_model(ctx, attrs:, **) # kw args!
  ctx[:model] = Memo.new(attrs)        # write to ctx

  ctx[:model].save ? true : false      # return value matters
end
</code></pre>

<p>You may use as many keyword arguments as you need - it will save you reading from <code>ctx</code> manually, gives you automatic presence checks, and allows defaulting, too.</p>

<!-- @activity-circuit-interface-class-method <trailblazer-activity[1.0] activity, circuit interface, low level, class method -->

<p><span class="divider"></span></p>

<ul class="navigation">
    <li>Step Interface</li>
    <li id="activity-internals-step-interface-return-value">Return Value</li>
</ul>

<p>Using the DSL, your task will usually be wrapped in a <code>TaskBuilder::Binary</code> object, which translates a <code>nil</code> and <code>false</code> return value to an <code>Activity::Left</code> signal, and all other return values to <code>Activity::Right</code>.</p>

<pre><code>def self.create_model(ctx, attrs:, **) # kw args!
  # ...
  ctx[:model].save ? true : false      # return value matters
end
</code></pre>

<p>In a Railway activity, a true value will usually result in the flow staying on the ‚Äúsuccess‚Äù path, where a falsey return value deviates to the ‚Äúfailure‚Äù track. However, eventually it‚Äôs the developer‚Äôs decision how to <a href="#activity-wiring-api">wire signals to connections</a>.</p>

<p><span class="divider"></span></p>

<ul class="navigation">
    <li>Step Interface</li>
    <li id="activity-internals-step-interface-return-signal">Return Signal</li>
</ul>

<p>You are not limited to true and falsey return values. Any subclass of <code>Activity::Signal</code> will simply be passed through without getting ‚Äútranslated‚Äù by the <code>Binary</code> wrapper. This allows to emit more than two possible states from a task.</p>

<pre><code>module Memo::Operation
  class Create &lt; Trailblazer::Activity::Railway
    DatabaseError = Class.new(Trailblazer::Activity::Signal) # subclass Signal

    def create_model(ctx, attrs:, **)
      ctx[:model] = Memo.new(attrs)

      begin
        return ctx[:model].save ? true : false  # binary return values
      rescue
        return DatabaseError                    # third return value
      end
    end
    # ...

    step :create_model,
      Output(DatabaseError, :handle_error) =&gt; Id(:handle_db_error)
    step :handle_db_error,
      magnetic_to: nil, Output(:success) =&gt; Track(:failure)
  end
end
</code></pre>

<p>The exemplary <code>DatabaseError</code> is being passed through to the routing and interpreted. It‚Äôs your job to make sure this signal is wired to a following task, track, or end (line 16).</p>

<p><img class="mx-auto d-block" src="/vite-dev/images/activity-signal.png" /></p>

<p>Note that you don‚Äôt have to use the default binary signals at all (<code>Left</code> and <code>Right</code>).
<!-- <a href="#" class="pink">
   <i class="far fa-arrow-alt-circle-right"></i>
   <span class="medium">wiring</span>
</a>
 -->
<a href="#wiring-api"><i class="fa fa-book" aria-hidden="true"></i> API docs</a></p>

<p><span class="divider"></span></p>

<ul class="navigation">
    <li>Step Interface</li>
    <li id="activity-internals-step-interface-instance-method">Instance Method</li>
</ul>

<p>The most convenient way is to use instance methods. Those may be declared after the <code>step</code> definitions, allowing you to first define the flow, then implement it.</p>

<pre><code>class Memo::Create &lt; Trailblazer::Activity::Railway
  step :authorize
  # ...

  def authorize(ctx, current_user:, **)
    current_user.can?(Memo, :create)
  end
end
</code></pre>

<p>Use <code>:method_name</code> to refer to instance methods.</p>

<div class="bd-callout bd-callout-info">
<p>Do <em>not use instance variables</em> (<code>@ivar</code>) ever as they‚Äôre not guaranteed to work as expected. Always transport state via <code>ctx</code>.</p>
</div>

<p><span class="divider"></span></p>

<ul class="navigation">
    <li>Step Interface</li>
    <li id="activity-internals-step-interface-class-method">Class Method</li>
</ul>

<p>A class method can implement a task of an activity. It needs to be declared as a class method using <code>self.method_name</code> and must precede the <code>step</code> declaration. Using Ruby‚Äôs <code>#method</code>, it can be passed to the <code>step</code> DSL.</p>

<pre><code>class Memo::Create &lt; Trailblazer::Activity::Railway
  def self.authorize(ctx, current_user:, **)
    current_user.can?(Memo, :create)
  end

  step method(:authorize)
end
</code></pre>

<p>Instead of prefixing every method signature with <code>self.</code> you could use Ruby‚Äôs <code>class &lt;&lt; self</code> block to create class methods.</p>

<pre><code>class Memo::Create &lt; Trailblazer::Activity::Railway
  class &lt;&lt; self
    def authorize(ctx, current_user:, **)
      current_user.can?(Memo, :create)
    end
    # more methods...
  end

  step method(:authorize)
end
</code></pre>

<p>In TRB 2.0, instance methods in operations were the preferred way for implementing tasks. This was a bit more convenient, but required the framework to create an object instance with every single activity invocation. It also encouraged users to transport state via the activity instance itself (instead of the <code>ctx</code> object), which led to bizarre issues.</p>

<p>Since 2.1, the approach is as stateless and functional as possible, as we now prefer class methods.</p>

<!-- @activity-circuit-interface-callable <trailblazer-activity[1.0] activity, circuit interface, low level, class method -->

<p><span class="divider"></span></p>

<ul class="navigation">
    <li>Step Interface</li>
    <li id="activity-internals-step-interface-callable">Callable</li>
</ul>

<p>As a matter of fact, you can use any callable object. That means, any object that responds to <code>#call</code> is suitable as a task implementation.</p>

<pre><code>class Memo::Create &lt; Trailblazer::Activity::Railway
  # ...
  step AuthorizeForCreate
end
</code></pre>

<p>When using a class, it needs to expose a class method <code>#call</code>. This is ideal for more complex task code that needs to be decomposed into smaller private methods internally.</p>

<pre><code>class AuthorizeForCreate
  def self.call(ctx, current_user:, **)
    current_user.can?(Memo, :create)
  end
end
</code></pre>

<p>The signature of <code>#call</code> is identical to the other implementation styles.</p>

<p><span class="divider"></span></p>

<ul class="navigation">
    <li>Step Interface</li>
    <li id="activity-internals-step-interface-module">Module</li>
</ul>

<p>Keep in mind that you don‚Äôt have to implement every task in the activity itself - it can be outsourced to a module.</p>

<pre><code>module Authorizer
  module_function

  def memo_create(ctx, current_user:, **)
    current_user.can?(Memo, :create)
  end
end
</code></pre>

<p>When using <code>module_function</code>, every method will be a ‚Äúclass‚Äù method automatically.</p>

<p>In the activity, you can reference the module‚Äôs methods using our old friend <code>method</code>.</p>

<pre><code>class Memo::Create &lt; Trailblazer::Activity::Railway
  step Authorizer.method(:memo_create)
  # ...
end
</code></pre>

<p><span class="divider"></span></p>

<h2 id="activity-taskwrap">TaskWrap</h2>
<p><!-- {activity-taskwrap-toc} --></p>

<p>The <em>taskWrap</em> is the ‚Äú<code>around_filter</code>‚Äù of Trailblazer. It allows adding steps before and after actual tasks without having to change the activity, and without having to introduce <code>if</code>s.</p>

<p>Some prominent examples for taskWrap usage in the wild are the <a href="https://github.com/trailblazer/trailblazer-activity-dsl-linear/blob/f54ce384f57dde063f77a769487fc38023217910/lib/trailblazer/activity/dsl/linear/variable_mapping.rb"><code>:input</code>/<code>:output</code> variable mapping</a> and tracing happening in <a href="https://github.com/trailblazer/trailblazer-developer/blob/de84d67ac390fee5e98ffc0a172cf80141e06c81/lib/trailblazer/developer/trace.rb"><code>#wtf?</code></a>.</p>

<p><img class="mx-auto d-block" src="/vite-dev/images/task-wrap.webp" /></p>

<p>You can maintain a taskWrap for each specific task of an activity, or run the same ‚Äúaround steps‚Äù for every task, even in nested activities. Also, taskWraps can be configured statically at compile-time or defined dynamically at run-time, which is how tracing in <code>#wtf?</code> works.</p>

<p><span class="divider"></span></p>

<h3 id="activity-taskwrap-runtime">Runtime</h3>
<p><!-- {activity-taskwrap-runtime-toc} --></p>

<p>At run-time, any taskWrap can be injected using <code>:wrap_runtime</code>. However, the taskWrap needs to be set up beforehand.</p>

<p>Consider the following operation, or activity.</p>

<pre><code>class Create &lt; Trailblazer::Activity::Railway # or Trailblazer::Operation
  step :model
  step :save
  # ...
  # ...
</code></pre>

<p>In order to invoke your own logger before every task (including the <code>Create</code> activity itself), you need to define a taskWrap extension and a taskWrap step for the actual logging.</p>

<p><span class="divider"></span></p>

<ul class="navigation">
    <li>Runtime</li>
    <li id="activity-taskwrap-runtime-taskwrap-step">taskWrap step</li>
</ul>

<p>A taskWrap step looks very similar to a normal step but has a slightly different interface.</p>

<pre><code>module TaskWrapLogger
  def self.log_before(wrap_ctx, original_args)
    # Pick what you need here.
    (ctx, flow_options), circuit_options = original_args

    ctx[:log] &lt;&lt; "Before #{wrap_ctx[:task]}"

    return wrap_ctx, original_args
  end
end
</code></pre>

<p>Note that the first positional argument is <code>wrap_ctx</code> which is a taskWrap-specific datastructure. It contains the <code>:task</code> variable which is the currently ‚Äúinvoked‚Äù step of your operation.</p>

<p>The second positional argument is <code>original_args</code>, which are the circuit-interface arguments that are being passed to the actual step. Depending on whether your taskWrap step is placed before or after the actual step, you can change the <code>ctx</code>, add or remove variables, or completely change what‚Äôs being passed around.</p>

<p>It is important to always return an array <code>[wrap_ctx, original_args]</code>.</p>

<div class="bd-callout bd-callout-info">
<p>You don‚Äôt have to mutate structures in the taskWrap. The example shows a convenient version. Anyway, you can build your own <code>ctx</code> and return the respective new structures from the taskWrap step.</p>
</div>

<p><span class="divider"></span></p>

<ul class="navigation">
    <li>Runtime</li>
    <li id="activity-taskwrap-runtime-extension">Extension</li>
</ul>

<p>Before injecting, you need to build a taskWrap extension.</p>

<pre><code>merge = [
  [
    Trailblazer::Activity::TaskWrap::Pipeline.method(:insert_before), # insert my step before
    "task_wrap.call_task",                                            # the {call_task} taskWrap step
    ["user.log_before", TaskWrapLogger.method(:log_before)]           # here's my own taskWrap step
  ],
  # ... add more, e.g. with {:insert_after}
  # [Trailblazer::Activity::TaskWrap::Pipeline.method(:insert_after), ...
]

wrap = Trailblazer::Activity::TaskWrap::Pipeline::Merge.new(*merge)

wrap_runtime = Hash.new(wrap) # wrap_runtime[...] will always return the same wrap
</code></pre>

<p>This might look a bit clumsy, but this API is not designed for people who don‚Äôt know what they‚Äôre doing. Feel special.</p>

<ul>
  <li>Each item in the <code>merge</code> array is a taskWrap you want to add.</li>
  <li>The <code>"task_wrap.call_task"</code> is the taskWrap step which invokes the actual step, e.g. <code>Create#model</code>.</li>
  <li>You can configure taskWrap steps for specific steps. In this example, we want the taskWrap to be invoked for every step, that‚Äôs why we use <code>Hash.new(wrap)</code>.</li>
  <li>The hash passed as <code>wrap_runtime</code> can contain specific wraps like <code>{my_task =&gt; my_specific_taskwrap}</code>, but in our example will always return the same taskWrap for each step.</li>
</ul>

<p><span class="divider"></span></p>

<ul class="navigation">
    <li>Runtime</li>
    <li id="activity-taskwrap-runtime-invoke">Invoke</li>
</ul>

<p>The taskWrap needs to be injected into the activity‚Äôs <code>invoke</code>, following the <a href="/2.1/docs/activity.html#activity-internals-circuit-interface">circuit-interface</a>.</p>

<pre><code>signal, (ctx, flow_options) = Trailblazer::Activity::TaskWrap.invoke(
  Create,
  [{log: []}, {}],
  wrap_runtime: wrap_runtime
)
</code></pre>

<p>You can now inspect the <code>ctx[:log]</code> field to see that your <code>log_before</code> has been called for each step, including the activity itself.</p>

<pre><code>puts ctx[:log]
 =&gt; [
      "Before Create",
      "Before #&lt;Trailblazer::Activity::Start semantic=:default&gt;",
      "Before #&lt;Trailblazer::Activity::TaskBuilder::Task user_proc=model&gt;"
      "Before #&lt;Trailblazer::Activity::TaskBuilder::Task user_proc=save&gt;",
      "Before #&lt;Trailblazer::Activity::End semantic=:success&gt;",
    ]
</code></pre>

<p>Using the <code>:wrap_runtime</code> feature is a beautiful way to add behavior around steps without having to use any decider or <code>if</code>s.</p>

<p><span class="divider"></span></p>

<h3 id="activity-taskwrap-static">Static</h3>
<p><!-- {activity-taskwrap-static-toc} --></p>

<p><span class="divider"></span></p>

<h2 id="activity-troubleshooting">Troubleshooting</h2>
<p><!-- {activity-troubleshooting-toc} --></p>

<p>Even though tracing and <code>wtf?</code> attempt to make your developer experience as smooth as possible, sometimes there are annoying issues.</p>

<p><span class="divider"></span></p>

<h3 id="activity-troubleshooting-type-error">Type Error</h3>
<p><!-- {activity-troubleshooting-type-error-toc} --></p>

<p>It‚Äôs a common error to use a bare <code>Hash</code> (with string keys!) instead of a <code>Trailblazer::Context</code> object when running an activity. While symbolized hashes are not a problem, string keys will fail.</p>

<pre><code>ctx = {"message" =&gt; "Not gonna work!"} # bare hash.
Bla.([ctx])
</code></pre>

<p>The infamous <code>TypeError</code> means your context object can‚Äôt convert strings into symbol keys. This is required when calling your steps with keyword arguments.</p>

<pre><code>TypeError: wrong argument type String (expected Symbol)
</code></pre>

<p>Use <code>Trailblazer::Context</code> as a wrapper.</p>

<pre><code>ctx = Trailblazer::Context({"message" =&gt; "Yes, works!"})

signal, (ctx, _) = Bla.([ctx])
</code></pre>

<p>The <code>Context</code> object automatically converts string keys to symbols.</p>

<p><span class="divider"></span></p>

<h3 id="activity-troubleshooting-wrong-circuit">Wrong circuit</h3>
<p><!-- {activity-troubleshooting-wrong-circuit-toc} --></p>

<p>When using the same task multiple times in an activity, you might end up with a wiring you‚Äôre not expecting. This is due to Trailblazer internally keying tasks by their object identity.</p>

<pre><code>class Update &lt; Trailblazer::Activity::Railway
  class CheckAttribute &lt; Trailblazer::Activity::Railway
    step :valid?
  end

  step :find_model
  step Subprocess(CheckAttribute), id: :a
  step Subprocess(CheckAttribute), id: :b # same task!
  step :save
end
</code></pre>

<p>When introspecting this activity, you will see that the <code>CheckAttribute</code> task is present only once.</p>

<p>You need to create a copy of the method or the class of your callable task in order to fix this and have two identical steps.</p>

<pre><code>class Update &lt; Trailblazer::Activity::Railway
  class CheckAttribute &lt; Trailblazer::Activity::Railway
    step :valid?
  end

  step :find_model
  step Subprocess(CheckAttribute), id: :a
  step Subprocess(Class.new(CheckAttribute)), id: :b # different task!
  step :save
end
</code></pre>

<p><span class="divider"></span></p>

<h3 id="activity-troubleshooting-illegal-signal-error">Illegal Signal Error</h3>
<p><!-- {activity-troubleshooting-illegal-signal-error-toc} --></p>

<p>As the name suggests, the <code>IllegalSignalError</code> exception is raised when a step returns a signal that is not registered at <a href="/2.1/docs/activity.html#activity-internals-build-structures-compilation">compile time</a>. The routing algorithm is not able to find a connection for the returned signal and raises an error at run-time.</p>

<p>Usually, you encounter this beautiful exception when using the <a href="#activity-internals-circuit-interface">circuit interface</a> signature for a step, and returning a ‚Äúwrong‚Äù signal that is not wired to an on-going next task.</p>

<p>Other common cases may be</p>

<ul>
  <li>Steps which are not wrapped by [TaskBuilder], for example: <code>step task: method(:validate)</code></li>
  <li><a href="/2.1/docs/activity.html#activity-macro-api">User defined macros</a>.</li>
</ul>

<pre><code>class Create &lt; Trailblazer::Activity::Railway
  def self.validate((ctx, flow_options), **circuit_options)
    return :invalid_signal, [ctx, flow_options], circuit_options
  end

  step task: method(:validate)
end

ctx = {"message" =&gt; "Not gonna work!"} # bare hash.
Create.([ctx])

# IllegalSignalError: Create:
# Unrecognized Signal `:invalid_signal` returned from `Method: Create.validate`. Registered signals are,
# - Trailblazer::Activity::Left
# - Trailblazer::Activity::Right
</code></pre>

<p>The exception helps by displaying both the actually returned signal and the registered, wired signals for this step.</p>

</div>

                <aside>
                  <span class="deco-purple-cross wow fadeIn"></span>
                </aside>
              </main>

              <div class="d-none d-xl-block col-xl-2 list-group sidebar-scroll order-3">
                <img alt="Trailblazer" class="wow fadeIn" src="/vite-dev/images/deco1.webp" />
                <div class="features" id="activity-overview-features">
  <h3>
    <i class="fas fa-times"></i>
    <span>Overview</span>
  </h3>

  <ul class="vertical menu">
    
      <li>
        <a href="#activity-overview-anatomy">
          <i class="fas fa-arrow-right"></i>
          Anatomy
        </a>
      </li>
      
    
      <li>
        <a href="#activity-overview-dsl">
          <i class="fas fa-arrow-right"></i>
          DSL
        </a>
      </li>
      
    
      <li>
        <a href="#activity-overview-invocation">
          <i class="fas fa-arrow-right"></i>
          Invocation
        </a>
      </li>
      
    
  </ul>
</div>

<div class="features" id="activity-strategy-features">
  <h3>
    <i class="fas fa-times"></i>
    <span>STRATEGY</span>
  </h3>

  <ul class="vertical menu">
    
      <li>
        <a href="#activity-strategy-path">
          <i class="fas fa-arrow-right"></i>
          Path
        </a>
      </li>
      
        
        <li class="sub-item">
          <a href="#activity-strategy-path-output">Output</a>
        </li>
      
        
        <li class="sub-item">
          <a href="#activity-strategy-path-end">End</a>
        </li>
      
        
        <li class="sub-item">
          <a href="#activity-strategy-path-multiple-references">Multiple References</a>
        </li>
      
    
      <li>
        <a href="#activity-strategy-railway">
          <i class="fas fa-arrow-right"></i>
          Railway
        </a>
      </li>
      
        
        <li class="sub-item">
          <a href="#activity-strategy-railway-wiring">Wiring</a>
        </li>
      
        
        <li class="sub-item">
          <a href="#activity-strategy-railway-fail">Fail</a>
        </li>
      
        
        <li class="sub-item">
          <a href="#activity-strategy-railway-pass">Pass</a>
        </li>
      
        
        <li class="sub-item">
          <a href="#activity-strategy-railway-notes">Notes</a>
        </li>
      
    
      <li>
        <a href="#activity-strategy-fasttrack">
          <i class="fas fa-arrow-right"></i>
          FastTrack
        </a>
      </li>
      
        
        <li class="sub-item">
          <a href="#activity-strategy-fasttrack-passfast">PassFast</a>
        </li>
      
        
        <li class="sub-item">
          <a href="#activity-strategy-fasttrack-failfast">FailFast</a>
        </li>
      
        
        <li class="sub-item">
          <a href="#activity-strategy-fasttrack-fasttrack">FastTrack</a>
        </li>
      
        
        <li class="sub-item">
          <a href="#activity-strategy-fasttrack-notes">Notes</a>
        </li>
      
    
  </ul>
</div>

<div class="features" id="activity-wiring-api-features">
  <h3>
    <i class="fas fa-times"></i>
    <span>Wiring API</span>
  </h3>

  <ul class="vertical menu">
    
      <li>
        <a href="#activity-wiring-api-output-">
          <i class="fas fa-arrow-right"></i>
          Output()
        </a>
      </li>
      
        
        <li class="sub-item">
          <a href="#activity-wiring-api-output-implicit-signal">Implicit signal</a>
        </li>
      
        
        <li class="sub-item">
          <a href="#activity-wiring-api-output-adding-outputs">Adding outputs</a>
        </li>
      
    
      <li>
        <a href="#activity-wiring-api-end-">
          <i class="fas fa-arrow-right"></i>
          End()
        </a>
      </li>
      
        
        <li class="sub-item">
          <a href="#activity-wiring-api-end-adding-ends">Adding ends</a>
        </li>
      
    
      <li>
        <a href="#activity-wiring-api-id-">
          <i class="fas fa-arrow-right"></i>
          Id()
        </a>
      </li>
      
    
      <li>
        <a href="#activity-wiring-api-track-">
          <i class="fas fa-arrow-right"></i>
          Track()
        </a>
      </li>
      
    
      <li>
        <a href="#activity-wiring-api-terminus">
          <i class="fas fa-arrow-right"></i>
          Terminus
        </a>
      </li>
      
    
      <li>
        <a href="#activity-wiring-api-path-">
          <i class="fas fa-arrow-right"></i>
          Path()
        </a>
      </li>
      
        
        <li class="sub-item">
          <a href="#activity-wiring-api-path-join">Join</a>
        </li>
      
        
        <li class="sub-item">
          <a href="#activity-wiring-api-path-railway">Railway</a>
        </li>
      
    
      <li>
        <a href="#activity-wiring-api-subprocess">
          <i class="fas fa-arrow-right"></i>
          Subprocess
        </a>
      </li>
      
        
        <li class="sub-item">
          <a href="#activity-wiring-api-subprocess-wiring">Wiring</a>
        </li>
      
        
        <li class="sub-item">
          <a href="#activity-wiring-api-subprocess-end">End</a>
        </li>
      
    
  </ul>
</div>

<div class="features" id="activity-dsl-options-features">
  <h3>
    <i class="fas fa-times"></i>
    <span>DSL Options</span>
  </h3>

  <ul class="vertical menu">
    
      <li>
        <a href="#activity-dsl-options-magnetic_to">
          <i class="fas fa-arrow-right"></i>
          magnetic_to
        </a>
      </li>
      
    
      <li>
        <a href="#activity-dsl-options-extensions">
          <i class="fas fa-arrow-right"></i>
          extensions
        </a>
      </li>
      
    
      <li>
        <a href="#activity-dsl-options-sequence-options">
          <i class="fas fa-arrow-right"></i>
          Sequence Options
        </a>
      </li>
      
        
        <li class="sub-item">
          <a href="#activity-dsl-options-sequence-options-id">id</a>
        </li>
      
        
        <li class="sub-item">
          <a href="#activity-dsl-options-sequence-options-delete">Delete</a>
        </li>
      
        
        <li class="sub-item">
          <a href="#activity-dsl-options-sequence-options-before">Before</a>
        </li>
      
        
        <li class="sub-item">
          <a href="#activity-dsl-options-sequence-options-after">After</a>
        </li>
      
        
        <li class="sub-item">
          <a href="#activity-dsl-options-sequence-options-replace">Replace</a>
        </li>
      
    
      <li>
        <a href="#activity-dsl-options-patching">
          <i class="fas fa-arrow-right"></i>
          Patching
        </a>
      </li>
      
        
        <li class="sub-item">
          <a href="#activity-dsl-options-patching-patch-option">Patch Option</a>
        </li>
      
        
        <li class="sub-item">
          <a href="#activity-dsl-options-patching-side-effects">Side effects</a>
        </li>
      
    
  </ul>
</div>

<div class="features" id="activity-variable-mapping-features">
  <h3>
    <i class="fas fa-times"></i>
    <span>Variable Mapping</span>
  </h3>

  <ul class="vertical menu">
    
      <li>
        <a href="#activity-variable-mapping-overview">
          <i class="fas fa-arrow-right"></i>
          Overview
        </a>
      </li>
      
    
      <li>
        <a href="#activity-variable-mapping-composable-i-o">
          <i class="fas fa-arrow-right"></i>
          Composable I/o
        </a>
      </li>
      
    
      <li>
        <a href="#activity-variable-mapping-in-">
          <i class="fas fa-arrow-right"></i>
          In()
        </a>
      </li>
      
        
        <li class="sub-item">
          <a href="#activity-variable-mapping-in-mapping-hash">Mapping hash</a>
        </li>
      
        
        <li class="sub-item">
          <a href="#activity-variable-mapping-in-limiting-array">Limiting array</a>
        </li>
      
        
        <li class="sub-item">
          <a href="#activity-variable-mapping-in-callable">Callable</a>
        </li>
      
        
        <li class="sub-item">
          <a href="#activity-variable-mapping-in-filter-method">Filter method</a>
        </li>
      
        
        <li class="sub-item">
          <a href="#activity-variable-mapping-in-keyword-arguments">Keyword arguments</a>
        </li>
      
    
      <li>
        <a href="#activity-variable-mapping-out-">
          <i class="fas fa-arrow-right"></i>
          Out()
        </a>
      </li>
      
        
        <li class="sub-item">
          <a href="#activity-variable-mapping-out-limiting-array">Limiting array</a>
        </li>
      
        
        <li class="sub-item">
          <a href="#activity-variable-mapping-out-mapping-hash">Mapping hash</a>
        </li>
      
        
        <li class="sub-item">
          <a href="#activity-variable-mapping-out-callable">Callable</a>
        </li>
      
        
        <li class="sub-item">
          <a href="#activity-variable-mapping-out-keyword-arguments">Keyword arguments</a>
        </li>
      
        
        <li class="sub-item">
          <a href="#activity-variable-mapping-out-outer-context">Outer context</a>
        </li>
      
    
      <li>
        <a href="#activity-variable-mapping-inject-">
          <i class="fas fa-arrow-right"></i>
          Inject()
        </a>
      </li>
      
        
        <li class="sub-item">
          <a href="#activity-variable-mapping-inject-array-style">Array style</a>
        </li>
      
        
        <li class="sub-item">
          <a href="#activity-variable-mapping-inject-defaulting">Defaulting</a>
        </li>
      
    
      <li>
        <a href="#activity-variable-mapping-macro">
          <i class="fas fa-arrow-right"></i>
          Macro
        </a>
      </li>
      
    
      <li>
        <a href="#activity-variable-mapping-inheritance">
          <i class="fas fa-arrow-right"></i>
          Inheritance
        </a>
      </li>
      
    
      <li>
        <a href="#activity-variable-mapping-introspect">
          <i class="fas fa-arrow-right"></i>
          Introspect
        </a>
      </li>
      
    
      <li>
        <a href="#activity-variable-mapping-input-output">
          <i class="fas fa-arrow-right"></i>
          Input / Output
        </a>
      </li>
      
        
        <li class="sub-item">
          <a href="#activity-variable-mapping-input-output-overview">Overview</a>
        </li>
      
        
        <li class="sub-item">
          <a href="#activity-variable-mapping-input-output-callable">Callable</a>
        </li>
      
        
        <li class="sub-item">
          <a href="#activity-variable-mapping-input-output-filter-methods">Filter Methods</a>
        </li>
      
        
        <li class="sub-item">
          <a href="#activity-variable-mapping-input-output-keyword-arguments">Keyword Arguments</a>
        </li>
      
        
        <li class="sub-item">
          <a href="#activity-variable-mapping-input-output-with-outer-ctx">With Outer Ctx</a>
        </li>
      
        
        <li class="sub-item">
          <a href="#activity-variable-mapping-input-output-notes">Notes</a>
        </li>
      
    
  </ul>
</div>

<div class="features" id="activity-dependency-injection-features">
  <h3>
    <i class="fas fa-times"></i>
    <span>Dependency Injection</span>
  </h3>

  <ul class="vertical menu">
    
      <li>
        <a href="#activity-dependency-injection-overview">
          <i class="fas fa-arrow-right"></i>
          Overview
        </a>
      </li>
      
    
      <li>
        <a href="#activity-dependency-injection-inject">
          <i class="fas fa-arrow-right"></i>
          Inject
        </a>
      </li>
      
        
        <li class="sub-item">
          <a href="#activity-dependency-injection-inject-qualified-pass-through">Qualified Pass-through</a>
        </li>
      
        
        <li class="sub-item">
          <a href="#activity-dependency-injection-inject-array-style">array style</a>
        </li>
      
        
        <li class="sub-item">
          <a href="#activity-dependency-injection-inject-defaulting">defaulting</a>
        </li>
      
    
      <li>
        <a href="#activity-dependency-injection-mapping">
          <i class="fas fa-arrow-right"></i>
          Mapping
        </a>
      </li>
      
    
      <li>
        <a href="#activity-dependency-injection-dry-container">
          <i class="fas fa-arrow-right"></i>
          Dry container
        </a>
      </li>
      
    
  </ul>
</div>

<div class="features" id="activity-macro-api-features">
  <h3>
    <i class="fas fa-times"></i>
    <span>Macro API</span>
  </h3>

  <ul class="vertical menu">
    
      <li>
        <a href="#activity-macro-api-definition">
          <i class="fas fa-arrow-right"></i>
          Definition
        </a>
      </li>
      
    
      <li>
        <a href="#activity-macro-api-usage">
          <i class="fas fa-arrow-right"></i>
          Usage
        </a>
      </li>
      
    
      <li>
        <a href="#activity-macro-api-options">
          <i class="fas fa-arrow-right"></i>
          Options
        </a>
      </li>
      
        
        <li class="sub-item">
          <a href="#activity-macro-api-options-subprocess">Subprocess</a>
        </li>
      
    
  </ul>
</div>

<div class="features" id="activity-internals-features">
  <h3>
    <i class="fas fa-times"></i>
    <span>Internals</span>
  </h3>

  <ul class="vertical menu">
    
      <li>
        <a href="#activity-internals-introspection-api">
          <i class="fas fa-arrow-right"></i>
          Introspection API
        </a>
      </li>
      
        
        <li class="sub-item">
          <a href="#activity-internals-introspection-api-find">Find</a>
        </li>
      
        
        <li class="sub-item">
          <a href="#activity-internals-introspection-api-node-api">Node API</a>
        </li>
      
        
        <li class="sub-item">
          <a href="#activity-internals-introspection-api-outgoing">Outgoing</a>
        </li>
      
        
        <li class="sub-item">
          <a href="#activity-internals-introspection-api-outputs">Outputs</a>
        </li>
      
    
      <li>
        <a href="#activity-internals-build-structures">
          <i class="fas fa-arrow-right"></i>
          Build Structures
        </a>
      </li>
      
        
        <li class="sub-item">
          <a href="#activity-internals-build-structures-intermediate">Intermediate</a>
        </li>
      
        
        <li class="sub-item">
          <a href="#activity-internals-build-structures-implementation">Implementation</a>
        </li>
      
        
        <li class="sub-item">
          <a href="#activity-internals-build-structures-compilation">Compilation</a>
        </li>
      
    
      <li>
        <a href="#activity-internals-circuit-interface">
          <i class="fas fa-arrow-right"></i>
          Circuit Interface
        </a>
      </li>
      
        
        <li class="sub-item">
          <a href="#activity-internals-circuit-interface-invocation">Invocation</a>
        </li>
      
        
        <li class="sub-item">
          <a href="#activity-internals-circuit-interface-signature">Signature</a>
        </li>
      
        
        <li class="sub-item">
          <a href="#activity-internals-circuit-interface-circuit-options">Circuit options</a>
        </li>
      
        
        <li class="sub-item">
          <a href="#activity-internals-circuit-interface-start_task">Start_task</a>
        </li>
      
        
        <li class="sub-item">
          <a href="#activity-internals-circuit-interface-exec_context">Exec_context</a>
        </li>
      
        
        <li class="sub-item">
          <a href="#activity-internals-circuit-interface-dsl">DSL</a>
        </li>
      
    
      <li>
        <a href="#activity-internals-step-interface">
          <i class="fas fa-arrow-right"></i>
          Step Interface
        </a>
      </li>
      
        
        <li class="sub-item">
          <a href="#activity-internals-step-interface-keyword-arguments">Keyword Arguments</a>
        </li>
      
        
        <li class="sub-item">
          <a href="#activity-internals-step-interface-return-value">Return Value</a>
        </li>
      
        
        <li class="sub-item">
          <a href="#activity-internals-step-interface-return-signal">Return Signal</a>
        </li>
      
        
        <li class="sub-item">
          <a href="#activity-internals-step-interface-instance-method">Instance Method</a>
        </li>
      
        
        <li class="sub-item">
          <a href="#activity-internals-step-interface-class-method">Class Method</a>
        </li>
      
        
        <li class="sub-item">
          <a href="#activity-internals-step-interface-callable">Callable</a>
        </li>
      
        
        <li class="sub-item">
          <a href="#activity-internals-step-interface-module">Module</a>
        </li>
      
    
  </ul>
</div>

<div class="features" id="activity-taskwrap-features">
  <h3>
    <i class="fas fa-times"></i>
    <span>TaskWrap</span>
  </h3>

  <ul class="vertical menu">
    
      <li>
        <a href="#activity-taskwrap-runtime">
          <i class="fas fa-arrow-right"></i>
          Runtime
        </a>
      </li>
      
        
        <li class="sub-item">
          <a href="#activity-taskwrap-runtime-taskwrap-step">taskWrap step</a>
        </li>
      
        
        <li class="sub-item">
          <a href="#activity-taskwrap-runtime-extension">Extension</a>
        </li>
      
        
        <li class="sub-item">
          <a href="#activity-taskwrap-runtime-invoke">Invoke</a>
        </li>
      
    
      <li>
        <a href="#activity-taskwrap-static">
          <i class="fas fa-arrow-right"></i>
          Static
        </a>
      </li>
      
    
  </ul>
</div>

<div class="features" id="activity-troubleshooting-features">
  <h3>
    <i class="fas fa-times"></i>
    <span>Troubleshooting</span>
  </h3>

  <ul class="vertical menu">
    
      <li>
        <a href="#activity-troubleshooting-type-error">
          <i class="fas fa-arrow-right"></i>
          Type Error
        </a>
      </li>
      
    
      <li>
        <a href="#activity-troubleshooting-wrong-circuit">
          <i class="fas fa-arrow-right"></i>
          Wrong circuit
        </a>
      </li>
      
    
      <li>
        <a href="#activity-troubleshooting-illegal-signal-error">
          <i class="fas fa-arrow-right"></i>
          Illegal Signal Error
        </a>
      </li>
      
    
  </ul>
</div>

              </div>
            </div>
          </div>
        </section>
      </main>

      <footer class="trailblazer-footer">
  <div class="container">
    <div class="row align-items-center">
      <div class="col-md-3 col-lg-2">
        <a href="/2.1/index.html" class="logo-footer">Trailblazer</a>
      </div>
      <div class="col-md-6 col-lg-8">
        <nav>
          <ul class="navbar-nav documentation-nav-items">
  <li>
    <a class="nav-item nav-link active" href="/2.1/docs/trailblazer.html">
      <i class="fas fa-arrow-right"></i>
      DOCS
    </a>
  </li>

  <li>
    <a class="nav-item nav-link " href="https://dev.to/trailblazer">BLOG</a>
  </li>

  <li class="">
    <a class="nav-item nav-link " href="/2.1/about_us.html">ABOUT US</a>
  </li>

  <li>
    <a class="nav-item nav-link " href="/2.1/learn.html">LEARN</a>
  </li>

  <li class="">
    <a class="nav-item nav-link" href="/2.0/index.html">
      <i class="fas fa-arrow-right"></i>
      2.0
    </a>
  </li>

  <li>
    <a class="nav-item nav-link" href="https://trailblazer.zulipchat.com" target="_blank">
      <i class="fas fa-comments"></i>
      CHAT
    </a>
  </li>

  <!--
  
  -->
</ul>

        </nav>
      </div>
      <div class="col-md-3 col-lg-2">
        <ul class="social purple">
          <li>
            <a href="https://github.com/trailblazer" target="_blank"><i class="fab fa-github-square"></i></a>
          </li>
          <li>
            <a href="https://www.facebook.com/trailblazer.to" target="_blank"><i class="fab fa-facebook-square"></i></a>
          </li>
          <li>
            <a href="https://twitter.com/trailblazer_to" target="_blank"><i class="fab fa-twitter-square"></i></a>
          </li>
        </ul>
      </div>
    </div>
  </div>
</footer>

    </div>
  </body>
</html>
