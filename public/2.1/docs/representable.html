<!DOCTYPE html>
<html lang="en" data-theme="dark">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, shrink-to-fit=no">

    <title>Trailblazer - Representable</title>

    <script src="/vite-dev/@vite/client" type="module"></script>
    <script src="/vite-dev/entrypoints/documentation.js" crossorigin="anonymous" type="module"></script>

    <link
      href="https://fonts.googleapis.com/css?family=Raleway:200,300,400,500,600,700,800"
      rel="stylesheet"
    >
    <link
      href="https://fonts.googleapis.com/icon?family=Material+Icons"
      rel="stylesheet"
    >
    <link
      rel="preconnect"
      href="https://R2IYF7ETH7-dsn.algolia.net" crossorigin
    >
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/@docsearch/css@3"
    >

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script
      async
      src="https://www.googletagmanager.com/gtag/js?id=UA-69514939-1"
    ></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag() {
        dataLayer.push(arguments);
      }
      gtag("js", new Date());

      gtag("config", "UA-69514939-1");
    </script>

    <link rel="icon" type="image/png" sizes="32x32" href="/vite-dev/images/favicon.ico">
  </head>
  <body>
    <div class="alert alert-primary m-0 rounded-0 text-center" role="alert">
      <span class="alert-text text-center">
        <!-- The new TRB 2.1 book series has begun - 82 pages are <a class="alert-link" href="https://leanpub.com/buildalib">waiting for you</a>! -->
        Dear Russian friends, please watch President Zelenskyy's
        <a href="https://twitter.com/PMoelleken/status/1496941845812760577">speech addressed to you</a>.
        üá∫üá¶ Help our brave mates in Ukraine
        <a
          href="https://actions.sumofus.org/a/give-to-ukrainians-who-need-an-urgent-lifeline"
        >
          with a donation
        </a>.
      </span>
    </div>

    <div class="lg-bg">
      <!-- Add class="session-show" if you need a header with dark background -->
      <header
        id="header"
        class="trailblazer-header documentation-navbar navbar navbar-expand-lg flex-column flex-md-row"
      >
        <h1 class="m-2">
          <a class="navbar-brand mr-0 mr-md-2" href="/2.1/index.html">Trailblazer</a>
        </h1>

        <div class="navbar-nav-scroll ml-md-auto">
          <ul class="navbar-nav documentation-nav-items">
  <li>
    <a class="nav-item nav-link active" href="/2.1/docs/trailblazer.html">
      <i class="fas fa-arrow-right"></i>
      DOCS
    </a>
  </li>

  <li>
    <a class="nav-item nav-link " href="https://dev.to/trailblazer">BLOG</a>
  </li>

  <li class="d-none d-md-block">
    <a class="nav-item nav-link " href="/2.1/about_us.html">ABOUT US</a>
  </li>

  <li>
    <a class="nav-item nav-link " href="/2.1/learn.html">LEARN</a>
  </li>

  <li class="d-none d-md-block">
    <a class="nav-item nav-link" href="/2.0">
      <i class="fas fa-arrow-right"></i>
      2.0
    </a>
  </li>

  <li>
    <a class="nav-item nav-link" href="https://trailblazer.zulipchat.com" target="_blank">
      <i class="fas fa-comments"></i>
      CHAT
    </a>
  </li>

  <li>
    <div id="docsearch"></div> <!-- https://docsearch.algolia.com/docs/DocSearch-v3 -->
  </li>
</ul>

        </div>
      </header>

      <main>
        <section class="documentation-main">
          <div class="container-fluid">
            <div class="row flex-xl-nowrap">
              <div class="col-md-3 col-xl-2 border-bottom order-1 sidebar-accordion sidebar-scroll">
                <form class="d-md-none d-flex align-items-center position-relative py-3 mx-n3 border-bottom">
                  <button
                    class="navbar-toggler collapsed"
                    type="button"
                    data-toggle="collapse"
                    data-target="#navBarTrailBlazer"
                    aria-controls="navBarTrailBlazer"
                    aria-expanded="false"
                    aria-label="Toggle navigation"
                  >
                    <i class="far fa-lg fa-bars"></i>
                  </button>
                </form>
                <div class="collapse d-md-block py-3 mx-n3" id="navBarTrailBlazer">
                  <div class="border-bottom">
  <div class="my-4">
    <div class="sidebar-accordion-wrapper">
  <div id="trailblazer">
    <h2 class="mb-0 mt-1 sidebar-accordion-item">
      <a href="/2.1/docs/trailblazer.html">
        <button
          class="collapsed"
          data-toggle="collapse"
          data-target="#trailblazer-collapse"
          aria-expanded="false"
          aria-controls="trailblazer-collapse"
        >
          <i class="fas fa-chevron-right"></i>
          <i class="fas fa-times"></i>
          <span>Trailblazer</span>
        </button>
      </a>
    </h2>
  </div>

  
</div>

<div class="sidebar-accordion-wrapper">
  <div id="test">
    <h2 class="mb-0 mt-1 sidebar-accordion-item">
      <a href="/2.1/docs/test.html">
        <button
          class="collapsed"
          data-toggle="collapse"
          data-target="#test-collapse"
          aria-expanded="false"
          aria-controls="test-collapse"
        >
          <i class="fas fa-chevron-right"></i>
          <i class="fas fa-times"></i>
          <span>Test</span>
        </button>
      </a>
    </h2>
  </div>

  
</div>

  </div>
</div>

<div class="border-bottom">
  <div class="my-4">
    <div class="sidebar-accordion-wrapper">
  <div id="activity">
    <h2 class="mb-0 mt-1 sidebar-accordion-item">
      <a href="/2.1/docs/activity.html">
        <button
          class="collapsed"
          data-toggle="collapse"
          data-target="#activity-collapse"
          aria-expanded="false"
          aria-controls="activity-collapse"
        >
          <i class="fas fa-chevron-right"></i>
          <i class="fas fa-times"></i>
          <span>Activity</span>
        </button>
      </a>
    </h2>
  </div>

  
</div>

<div class="sidebar-accordion-wrapper">
  <div id="operation">
    <h2 class="mb-0 mt-1 sidebar-accordion-item">
      <a href="/2.1/docs/operation.html">
        <button
          class="collapsed"
          data-toggle="collapse"
          data-target="#operation-collapse"
          aria-expanded="false"
          aria-controls="operation-collapse"
        >
          <i class="fas fa-chevron-right"></i>
          <i class="fas fa-times"></i>
          <span>Operation</span>
        </button>
      </a>
    </h2>
  </div>

  
</div>

<div class="sidebar-accordion-wrapper">
  <div id="workflow">
    <h2 class="mb-0 mt-1 sidebar-accordion-item">
      <a href="/2.1/docs/workflow.html">
        <button
          class="collapsed"
          data-toggle="collapse"
          data-target="#workflow-collapse"
          aria-expanded="false"
          aria-controls="workflow-collapse"
        >
          <i class="fas fa-chevron-right"></i>
          <i class="fas fa-times"></i>
          <span>Workflow</span>
        </button>
      </a>
    </h2>
  </div>

  
</div>

<div class="sidebar-accordion-wrapper">
  <div id="endpoint">
    <h2 class="mb-0 mt-1 sidebar-accordion-item">
      <a href="/2.1/docs/endpoint.html">
        <button
          class="collapsed"
          data-toggle="collapse"
          data-target="#endpoint-collapse"
          aria-expanded="false"
          aria-controls="endpoint-collapse"
        >
          <i class="fas fa-chevron-right"></i>
          <i class="fas fa-times"></i>
          <span>Endpoint</span>
        </button>
      </a>
    </h2>
  </div>

  
</div>

  </div>
</div>

<div class="border-bottom">
  <div class="my-4">
    <div class="sidebar-accordion-wrapper">
  <div id="reform">
    <h2 class="mb-0 mt-1 sidebar-accordion-item">
      <a href="/2.1/docs/reform.html">
        <button
          class="collapsed"
          data-toggle="collapse"
          data-target="#reform-collapse"
          aria-expanded="false"
          aria-controls="reform-collapse"
        >
          <i class="fas fa-chevron-right"></i>
          <i class="fas fa-times"></i>
          <span>Reform</span>
        </button>
      </a>
    </h2>
  </div>

  
</div>

<div class="sidebar-accordion-wrapper">
  <div id="cells">
    <h2 class="mb-0 mt-1 sidebar-accordion-item">
      <a href="/2.1/docs/cells.html">
        <button
          class="collapsed"
          data-toggle="collapse"
          data-target="#cells-collapse"
          aria-expanded="false"
          aria-controls="cells-collapse"
        >
          <i class="fas fa-chevron-right"></i>
          <i class="fas fa-times"></i>
          <span>Cells</span>
        </button>
      </a>
    </h2>
  </div>

  
</div>

<div class="sidebar-accordion-wrapper">
  <div id="representable">
    <h2 class="mb-0 mt-1 sidebar-accordion-item">
      <a href="/2.1/docs/representable.html">
        <button
          class=""
          data-toggle="collapse"
          data-target="#representable-collapse"
          aria-expanded="true"
          aria-controls="representable-collapse"
        >
          <i class="fas fa-chevron-right"></i>
          <i class="fas fa-times"></i>
          <span>Representable</span>
        </button>
      </a>
    </h2>
  </div>

  
    <div
      id="representable-collapse"
      class="collapse show"
      aria-labelledby="representable"
      data-parent="#accordion"
    >
      <ul class="nav vertical menu navbar-light">
        
          <li class="nav-item">
            <a class="nav-link active" href="#representable-api">
              API
            </a>
          </li>
        
          <li class="nav-item">
            <a class="nav-link " href="#representable-function-api">
              Function API
            </a>
          </li>
        
          <li class="nav-item">
            <a class="nav-link " href="#representable-xml">
              XML
            </a>
          </li>
        
          <li class="nav-item">
            <a class="nav-link " href="#representable-yaml">
              YAML
            </a>
          </li>
        
          <li class="nav-item">
            <a class="nav-link " href="#representable-debugging">
              Debugging
            </a>
          </li>
        
          <li class="nav-item">
            <a class="nav-link " href="#representable-upgrading-guide">
              Upgrading Guide
            </a>
          </li>
        
      </ul>
    </div>
  
</div>

<div class="sidebar-accordion-wrapper">
  <div id="disposable">
    <h2 class="mb-0 mt-1 sidebar-accordion-item">
      <a href="/2.1/docs/disposable.html">
        <button
          class="collapsed"
          data-toggle="collapse"
          data-target="#disposable-collapse"
          aria-expanded="false"
          aria-controls="disposable-collapse"
        >
          <i class="fas fa-chevron-right"></i>
          <i class="fas fa-times"></i>
          <span>Disposable</span>
        </button>
      </a>
    </h2>
  </div>

  
</div>

<div class="sidebar-accordion-wrapper">
  <div id="roar">
    <h2 class="mb-0 mt-1 sidebar-accordion-item">
      <a href="/2.1/docs/roar.html">
        <button
          class="collapsed"
          data-toggle="collapse"
          data-target="#roar-collapse"
          aria-expanded="false"
          aria-controls="roar-collapse"
        >
          <i class="fas fa-chevron-right"></i>
          <i class="fas fa-times"></i>
          <span>Roar</span>
        </button>
      </a>
    </h2>
  </div>

  
</div>

  </div>
</div>

<div class="border-bottom">
  <div class="my-4">
    <div class="sidebar-accordion-wrapper">
  <div id="tutorials">
    <h2 class="mb-0 mt-1 sidebar-accordion-item">
      <a href="/2.1/docs/tutorials/activity.html">
        <button
          class="collapsed"
          data-toggle="collapse"
          data-target="#tutorials-collapse"
          aria-expanded="false"
          aria-controls="tutorials-collapse"
        >
          <i class="fas fa-chevron-right"></i>
          <i class="fas fa-times"></i>
          <span>Tutorials</span>
        </button>
      </a>
    </h2>
  </div>

  
</div>

<div class="sidebar-accordion-wrapper">
  <div id="pro">
    <h2 class="mb-0 mt-1 sidebar-accordion-item">
      <a href="/2.1/docs/pro.html">
        <button
          class="collapsed"
          data-toggle="collapse"
          data-target="#pro-collapse"
          aria-expanded="false"
          aria-controls="pro-collapse"
        >
          <i class="fas fa-chevron-right"></i>
          <i class="fas fa-times"></i>
          <span>PRO</span>
        </button>
      </a>
    </h2>
  </div>

  
</div>

  </div>
</div>

                </div>
              </div>

              <main
                class="col-md-9 col-xl-8 py-md-5 pl-md-5 order-2"
                role="main"
              >
                <div class="doc-block section-name session-show">
                  <h1 class="w-100">Representable</h1>
                  <ul>
                    <li>
                      <i class="far fa-clock pink"></i>
                      <span>Last updated 27 Jun 22</span>
                    </li>
                  </ul>
                </div>

                <div class="doc-block">
<p>Representable maps objects to documents (rendering) and documents to objects (parsing) using <em>representers</em>. Representers define the document structure and the transformation to/from objects.</p>

<p>Representers can define deeply nested object graphs‚Ä¶.</p>

<p>It is very popular amongst REST API developers as it tackles both sides of exposing APIs: rendering documents and deserializing incoming documents to object graphs using a very generic approach.</p>

<p>But it‚Äôs also very helpful as a generic data transformer. ‚Ä¶</p>

<p>In case you‚Äôre looking towards implementing a REST API, check out <a href="/2.1/docs/roar.html">Roar</a> first, which adds hypermedia semantics, media formats and more to Representable</p>

<p><span class="divider"></span></p>

<h2 id="representable-api">API</h2>
<p><!-- {representable-api-toc} --></p>

<p>In Representable, we differentiate between three APIs.</p>

<p>The <a href="#representable-api">declarative API</a> is how we define representers. You can learn how to use those representers by reading about the very brief <a href="#representable-api-public-api">public API</a>. Representable is extendable without having to hack existing code: the <a href="#representable-function-api">function API</a> documents how to use its options to achieve what you need.</p>

<p><span class="divider"></span></p>

<h3 id="representable-api-declarative-api">Declarative API</h3>
<p><!-- {representable-api-declarative-api-toc} --></p>

<p>To render objects to documents or parse documents to objects, you need to define a representer.</p>

<p>A representer can either be a class (called <em>decorator</em>) or a module (called <em>representer module</em>). Throughout the docs, we will use decorators as they are cleaner and faster, but keep in mind you can also use modules.</p>

<pre><code>require 'representable/json'

class SongRepresenter &lt; Representable::Decorator
  include Representable::JSON

  property :id
  property :title
end
</code></pre>

<p>A representer simply defines the fields that will be mapped to the document using <code>property</code> or <code>collection</code>. You can then decorate an object and render or parse. Here‚Äôs an example.</p>

<pre><code># Given a Struct like this
Song = Struct.new(:id, :title) #=&gt; Song

# You can instantiate it with the following
song = Song.new(1, "Fallout") #=&gt; #&lt;struct Song id=1, title="Fallout"&gt;

# This object doesn't know how to represent itself in JSON
song.to_json #=&gt; NoMethodError: undefined method `to_json'

# But you can decorate it with the above defined representer
song_representer = SongRepresenter.new(song)

# Relax and let the representer do its job
song_representer.to_json #=&gt; {"id":1,"title":"Fallout"}
</code></pre>

<p>The details are being discussed in the <a href="#representable-api">public API</a> section.</p>

<h3 id="representer-modules">Representer Modules</h3>

<p>Instead of using classes as representers, you can also leverage modules which will then get mixed into the represented object.</p>

<p>A representer module is also a good way to share configuration and logic across decorators.</p>

<pre><code>module SongRepresenter
  include Representable::JSON

  property :id
  property :title
end
</code></pre>

<p>The API in a module representer is identical to decorators. However, the way you apply them is different.</p>

<pre><code>song.extend(SongRepresenter).to_json #=&gt; {"id":1,"title":"Fallout"}
</code></pre>

<p>There‚Äôs two drawbacks with this approach.</p>

<ol>
  <li>You pollute the represented object with the imported representer methods (e.g. <code>to_json</code>).</li>
  <li>Extending an object at run-time is costly and with many <code>extend</code>s there will be a notable performance decrease.</li>
</ol>

<p>Throughout this documentation, we will use decorator as examples to encourage this cleaner and faster approach.</p>

<h4 id="collections">Collections</h4>

<p>Not everything is a scalar value. Sometimes an object‚Äôs property can be a collection of values. Use <code>collection</code> to represent arrays.</p>

<pre><code>class SongRepresenter &lt; Representable::Decorator
  include Representable::JSON

  property :id
  property :title
  collection :composer_ids
end
</code></pre>

<p>The new collection <code>composer_ids</code> has to be enumeratable object, like an array.</p>

<pre><code>Song = Struct.new(:id, :title, :composer_ids)
song = Song.new(1, "Fallout", [2, 3])

song_representer = SongRepresenter.new(song)
song_representer.to_json #=&gt; {"id":1,"title":"Fallout","composer_ids":[2,3]}
</code></pre>

<p>Of course, this works also for parsing. The incoming <code>composer_ids</code> will override the old collection on the represented object.</p>

<h4 id="nesting">Nesting</h4>

<p>Representable can also handle compositions of objects. This works for both <code>property</code> and <code>collection</code>.</p>

<p>For example, a song could nest an artist object.</p>

<pre><code>Song   = Struct.new(:id, :title, :artist)
Artist = Struct.new(:id, :name)

artist = Artist.new(2, "The Police")
song   = Song.new(1, "Fallout", artist)
</code></pre>

<p>Here‚Äôs a better view of that object graph.</p>

<pre><code>#&lt;struct Song
  id=1,
  title="Fallout",
  artist=#&lt;struct Artist
    id=2,
    name="The Police"&gt;&gt;
</code></pre>

<h4 id="inline-representer">Inline Representer</h4>

<p>The easiest way to nest representers is by using an inline representer.</p>

<pre><code>class SongRepresenter &lt; Representable::Decorator
  include Representable::JSON

  property :id
  property :title

  property :artist do
    property :id
    property :name
  end
end
</code></pre>

<p>Note that you can have any levels of nesting.</p>

<h4 id="explicit-representer">Explicit Representer</h4>

<p>Sometimes you want to compose two existing, stand-alone representers.</p>

<pre><code>class ArtistRepresenter &lt; Representable::Decorator
  include Representable::JSON

  property :id
  property :name
end
</code></pre>

<p>To maximize reusability of representers, you can reference a nested representer using the <code>:decorator</code> option.</p>

<pre><code>class SongRepresenter &lt; Representable::Decorator
  include Representable::JSON

  property :id
  property :title

  property :artist, decorator: ArtistRepresenter
end
</code></pre>

<p>This is identical to an inline representer, but allows you to reuse <code>ArtistRepresenter</code> elsewhere.</p>

<p>Note that the <code>:extend</code> and <code>:decorator</code> options are identical. They can both reference a decorator or a module.</p>

<h4 id="nested-rendering">Nested Rendering</h4>

<p>Regardless of the representer types you use, rendering will result in a nested document.</p>

<pre><code>SongRepresenter.new(song).to_json
#=&gt; {"id":1,"title":"Fallout","artist":{"id":2,"name":"The Police"}}
</code></pre>

<h4 id="nested-parsing">Nested Parsing</h4>

<p>When parsing, per default Representable will want to instantiate an object for every nested, typed fragment.</p>

<p>You have to tell Representable what object to instantiate for the nested <code>artist:</code> fragment.</p>

<pre><code>class SongRepresenter &lt; Representable::Decorator
  # ..
  property :artist, decorator: ArtistRepresenter, class: Artist
end
</code></pre>

<p>This happens via the <code>:class</code> option. Now, the document can be parsed and a nested <code>Artist</code> will be created by the parsing.</p>

<pre><code>song = Song.new # nothing set.

SongRepresenter.new(song).
  from_json('{"id":1,"title":"Fallout","artist":{"id":2,"name":"The Police"}}')

song.artist.name #=&gt; "The Police"
</code></pre>

<p>The default behavior is - admittedly - very primitive. Representable‚Äôs parsing allow rich mapping, object creation and runtime checks.</p>

<h3 id="document-nesting">Document Nesting</h3>

<p>Not always does the structure of the desired document map to your objects. The <code>::nested</code> method allows structuring properties within a separate section while still mapping the properties to the outer object.</p>

<p>Imagine the following document.</p>

<pre><code>json_fragment = &lt;&lt;END
{"title": "Roxanne",
 "details":
   {"track": 3,
    "length": "4:10"}
}
END
</code></pre>

<p>However, in the <code>Song</code> class, there‚Äôs no such concept as <code>details</code>.</p>

<pre><code>Song = Struct.new(:title, :track, :length)

song = Song.new #=&gt; #&lt;struct Song title=nil, track=nil, length=nil&gt;
</code></pre>

<p>Both track and length are properties of the song object itself. Representable gives you ::nested to map the virtual <code>details</code> section to the song instance.</p>

<pre><code>class SongRepresenter &lt; Representable::Decorator
  include Representable::JSON

  property :title

  nested :details do
    property :track
    property :length
  end
end

song_representer = SongRepresenter.new(song)
song_representer.from_json(json_fragment)
</code></pre>

<p>Accessors for the nested properties will still be called on the song object. And as always, this works both ways - for rendering and parsing.</p>

<h4 id="wrapping">Wrapping</h4>

<p>You can automatically wrap a document.</p>

<pre><code>class SongRepresenter &lt; Representable::Decorator
  include Representable::JSON

  self.representation_wrap= :song

  property :title
  property :id
end
</code></pre>

<p>This will add a container for rendering and parsing.</p>

<pre><code>SongRepresenter.new(song).to_json
#=&gt; {"song":{"title":"Fallout","id":1}}
</code></pre>

<p>Setting <code>self.representation_wrap = true</code> will advice representable to figure out the wrap itself by inspecting the represented object class.</p>

<p>Note that <code>representation_wrap</code> is a dynamic function option.</p>

<pre><code>self.representation_wrap = -&gt;(user_options:) { user_options[:my_wrap] }
</code></pre>

<p>This would allow to provide the wrap manually.</p>

<pre><code>song_representer.to_json(user_options: { my_wrap: "hit" })
</code></pre>

<h4 id="suppressing-nested-wraps">Suppressing Nested Wraps</h4>

<p>When reusing a representer for a nested document, you might want to suppress its <code>representation_wrap=</code> for the nested fragment.</p>

<p>Reusing <code>SongRepresenter</code> from the last section in a nested setup allows suppressing the wrap via the <code>:wrap</code> option.</p>

<pre><code>class AlbumRepresenter &lt; Representable::Decorator
  include Representable::JSON

  collection :songs,
    decorator: SongRepresenter, # SongRepresenter defines representation_wrap.
    wrap:      false            # turn off :song wrap.
end
</code></pre>

<p>The <code>representation_wrap</code> from the nested representer now won‚Äôt be rendered or parsed‚Ä¶</p>

<pre><code>Album = Struct.new(:songs)
album = Album.new
album.songs = [song]
AlbumRepresenter.new(album).to_json
</code></pre>

<p>.. and will result in:</p>

<pre><code class="language-json">{"songs":[{"title":"Fallout","id":1}]}
</code></pre>

<p>Otherwise it would respect the <code>representation_wrap=</code> set in the nested decorator (SongRepresenter) and will render:</p>

<pre><code class="language-json">{"songs":[{"song":{"title":"Fallout","id":1}}]}
</code></pre>

<p>Note that this only works for JSON and Hash at the moment.</p>

<h4 id="inheritance">Inheritance</h4>

<p>Properties can be inherited across representer classes and modules.</p>

<pre><code>class SongRepresenter &lt; Representable::Decorator
  include Representable::JSON

  property :id
  property :title
end
</code></pre>

<p>What if you need a refined representer to also add the artist. Use inheritance.</p>

<pre><code>class SongWithArtistRepresenter &lt; SongRepresenter
  property :artist do
    property :name
  end
end
</code></pre>

<p>All configuration from <code>SongRepresenter</code> will be inherited, making the properties on <code>SongWithArtistRepresenter</code>: <code>id</code>, <code>title</code>, and <code>artist</code>. The original <code>SongRepresenter</code> will stay as it is.</p>

<pre><code>Artist         = Struct.new(:name)
SongWithArtist = Struct.new(:id, :title, :artist)

artist           = Artist.new("Ivan Lins")
song_with_artist = SongWithArtist.new(1, "Novo Tempo", artist)

# Using the same object with the two representers
song_representer             = SongRepresenter.new(song_with_artist)
song_with_artist_representer = SongWithArtistRepresenter.new(song_with_artist)

song_representer.to_json
#=&gt; {"id":1,"title":"Novo Tempo"}

song_with_artist_representer.to_json
#=&gt; {"id":1,"title":"Novo Tempo","artist":{"name":"Ivan Lins"}}
</code></pre>

<h4 id="composition">Composition</h4>

<p>You can also use modules and decorators together to compose representers.</p>

<pre><code>module GenericRepresenter
  include Representable::JSON

  property :id
end
</code></pre>

<p>This can be included in other representers and will extend their configuration.</p>

<pre><code>class SongRepresenter &lt; Representable::Decorator
  include GenericRepresenter

  property :title
end
</code></pre>

<p>As a result, <code>SongRepresenter</code> will contain the good old <code>id</code> and <code>title</code> property.</p>

<h4 id="overriding-properties">Overriding Properties</h4>

<p>You might want to override a particular property in an inheriting representer. Successively calling <code>property(name)</code> will override the former definition - exactly as you know it from overriding methods in Ruby.</p>

<pre><code>class CoverSongRepresenter &lt; SongRepresenter
  include Representable::JSON

  property :title, as: :name # overrides that definition.
end
</code></pre>

<h4 id="partly-overriding-properties">Partly Overriding Properties</h4>

<p>Instead of fully replacing a property, you can extend it with <code>:inherit</code>. This will <em>add</em> your new options and override existing options in case the one you provided already existed.</p>

<pre><code>class SongRepresenter &lt; Representable::Decorator
  include Representable::JSON

  property :title, as: :name, render_nil: true
end
</code></pre>

<p>You can now inherit properties but still override or add options.</p>

<pre><code>class CoverSongRepresenter &lt; SongRepresenter
  include Representable::JSON

  property :title, as: :songTitle, default: "n/a", inherit: true
end
</code></pre>

<p>Using the :inherit, this will result in a property having the following options.</p>

<pre><code>property :title,
  as:         :songTitle, # overridden in CoverSongRepresenter.
  render_nil: true        # inherited from SongRepresenter.
  default:    "n/a"       # defined in CoverSongRepresenter.
</code></pre>

<p>The <code>:inherit</code> option works for both inheritance and module composition.</p>

<h4 id="inherit-with-inline-representers">Inherit With Inline Representers</h4>

<p><code>:inherit</code> also works applied with inline representers.</p>

<pre><code>class SongRepresenter &lt; Representable::Decorator
  include Representable::JSON

  property :title
  property :artist do
    property :name
  end
end
</code></pre>

<p>You can now override or add properties within the inline representer.</p>

<pre><code>class HitRepresenter &lt; SongRepresenter
  include Representable::JSON

  property :artist, inherit: true do
    property :email
  end
end
</code></pre>

<p>Results in a combined inline representer as it inherits.</p>

<pre><code>property :artist do
  property :name
  property :email
end
</code></pre>

<p>Naturally, <code>:inherit</code> can be used within the inline representer block.</p>

<p>Note that the following also works.</p>

<pre><code>class HitRepresenter &lt; SongRepresenter
  include Representable::JSON

  property :artist, as: :composer, inherit: true
end
</code></pre>

<p>This renames the property but still inherits all the inlined configuration.</p>

<p>Basically, <code>:inherit</code> copies the configuration from the parent property, then merges in your options from the inheriting representer. It exposes the same behaviour as <code>super</code> in Ruby - when using <code>:inherit</code> the property must exist in the parent representer.</p>

<p><span class="divider"></span></p>

<h3 id="representable-api-feature">Feature</h3>
<p><!-- {representable-api-feature-toc} --></p>

<p>If you need to include modules in all inline representers automatically, register it as a feature.</p>

<pre><code>class AlbumRepresenter &lt; Representable::Decorator
  include Representable::JSON
  feature Link # imports ::link

  link "/album/1"

  property :hit do
    link "/hit/1" # link method imported automatically.
  end
end
</code></pre>

<p>Nested representers will <code>include</code> the provided module automatically.</p>

<p><span class="divider"></span></p>

<h3 id="representable-api-execution-context">Execution Context</h3>
<p><!-- {representable-api-execution-context-toc} --></p>

<p>Readers and Writers for properties will usually be called on the <code>represented</code> object. If you want to change that, so the accessors get called on the decorator instead, use <code>:exec_context</code>.</p>

<pre><code>class SongRepresenter &lt; Representable::Decorator
  property :title, exec_context: :decorator

  def title
    represented.name
  end
end
</code></pre>

<p><span class="divider"></span></p>

<h3 id="representable-api-callable-options">Callable Options</h3>
<p><!-- {representable-api-callable-options-toc} --></p>

<p>While lambdas are one option for dynamic options, you might also pass a ‚Äúcallable‚Äù object to a directive.</p>

<pre><code>class Sanitizer
  include Uber::Callable

  def call(represented, fragment, doc, *args)
    fragment.sanitize
  end
end
</code></pre>

<p>Note how including <code>Uber::Callable</code> marks instances of this class as callable. No <code>respond_to?</code> or other magic takes place here.</p>

<pre><code>property :title, parse_filter: Santizer.new
</code></pre>

<p>This is enough to have the <code>Sanitizer</code> class run with all the arguments that are usually passed to the lambda (preceded by the represented object as first argument).</p>

<p><span class="divider"></span></p>

<h3 id="representable-api-read-write-restrictions">Read/Write Restrictions</h3>
<p><!-- {representable-api-read-write-restrictions-toc} --></p>

<p>Using the <code>:readable</code> and <code>:writeable</code> options access to properties can be restricted.</p>

<pre><code>property :title, readable: false
</code></pre>

<p>This will leave out the <code>title</code> property in the rendered document. Vice-versa, <code>:writeable</code> will skip the property when parsing and does not assign it.</p>

<p><span class="divider"></span></p>

<h3 id="representable-api-coercion">Coercion</h3>
<p><!-- {representable-api-coercion-toc} --></p>

<p>If you need coercion when parsing a document you can use the Coercion module which uses <a href="https://github.com/solnic/virtus">virtus</a> for type conversion.</p>

<p>Include Virtus in your Gemfile, first.</p>

<pre><code>gem 'virtus', "&gt;= 0.5.0"
</code></pre>

<p>Use the <code>:type</code> option to specify the conversion target. Note that <code>:default</code> still works.</p>

<pre><code>class SongRepresenter &lt; Representable::Decorator
  include Representable::JSON
  include Representable::Coercion

  property :recorded_at, type: DateTime, default: "May 12th, 2012"
end
</code></pre>

<p>Coercing values only happens when rendering or parsing a document. Representable does not create accessors in your model as <code>virtus</code> does.</p>

<p>Note that we think coercion in the representer is wrong, and should happen on the underlying object. We have a rich <a href="/2.1/docs/disposable.html#disposable-twin-api-coercion">coercion/constraint API for twins</a>.</p>

<p><span class="divider"></span></p>

<h3 id="representable-api-symbol-keys">Symbol Keys</h3>
<p><!-- {representable-api-symbol-keys-toc} --></p>

<p>When parsing, Representable reads properties from hashes using their string keys.</p>

<pre><code>song.from_hash("title" =&gt; "Road To Never")
</code></pre>

<p>To allow symbol keys also include the <code>AllowSymbols</code> module.</p>

<pre><code>class SongRepresenter &lt; Representable::Decorator
  include Representable::Hash
  include Representable::Hash::AllowSymbols
  # ..
end
</code></pre>

<p>This will give you a behavior close to Rails‚Äô <code>HashWithIndifferentAccess</code> by stringifying the incoming hash internally.</p>

<p><span class="divider"></span></p>

<h3 id="representable-api-defaults">Defaults</h3>
<p><!-- {representable-api-defaults-toc} --></p>

<p>The <code>defaults</code> method allows setting options that will be applied to all property definitions of a representer.</p>

<pre><code>class SongRepresenter &lt; Representable::Decorator
  include Representable::JSON

  defaults render_nil: true

  property :id
  property :title
end
</code></pre>

<p>This will include <code>render_nil: true</code> in both <code>id</code> and <code>title</code> definitions, as if you‚Äôd provided that option each time.</p>

<p>You can also have dynamic option computation at compile-time.</p>

<pre><code>class SongRepresenter &lt; Representable::Decorator
  include Representable::JSON

  defaults do |name, options|
    { as: name.camelize }
  end
</code></pre>

<p>The <code>options</code> hash combines the user‚Äôs and Representable computed options.</p>

<pre><code>property :id, skip: true

defaults do |name, options|
  options[:skip] ? { as: name.camelize } : {}
end
</code></pre>

<p>Note that the dynamic <code>defaults</code> block always has to return a hash.</p>

<p>Combining those two forms also works.</p>

<pre><code>class SongRepresenter &lt; Representable::Decorator
  include Representable::JSON

  defaults render_nil: true do |name|
    { as: name.camelize }
  end
</code></pre>

<p>All defaults are inherited to subclasses or including modules.</p>

<p><span class="divider"></span></p>

<h3 id="representable-api-standalone-hash">Standalone Hash</h3>
<p><!-- {representable-api-standalone-hash-toc} --></p>

<p>If it‚Äôs required to represent a bare hash object, use <code>Representable::JSON::Hash</code> instead of <code>Representable::JSON</code>.</p>

<p>This is sometimes called a <em>lonely hash</em>.</p>

<pre><code>require "representable/json/hash"

class SongsRepresenter &lt; Representable::Decorator
  include Representable::JSON::Hash
end
</code></pre>

<p>You can then use this hash decorator on instances of <code>Hash</code>.</p>

<pre><code>hash = {"Nick" =&gt; "Hyper Music", "El" =&gt; "Blown In The Wind"}
SongsRepresenter.new(hash).to_json
#=&gt; {"Nick":"Hyper Music","El":"Blown In The Wind"}
</code></pre>

<p>This works both ways.</p>

<p>A lonely hash starts to make sense especially when the values are nested objects that need to be represented, too. You can configure the nested value objects using the <code>values</code> method. This works exactly as if you were defining an inline representer, accepting the same options.</p>

<pre><code>class SongsRepresenter &lt; Representable::Decorator
  include Representable::JSON::Hash

  values class: Song do
    property :title
  end
end
</code></pre>

<p>You can now represents nested objects in the hash, both rendering and parsing-wise.</p>

<pre><code>hash = {"Nick" =&gt; Song.new("Hyper Music")}
SongsRepresenter.new(hash).to_json
</code></pre>

<p>In XML, use <code>XML::Hash</code>. If you want to store hash attributes in tag attributes instead of dedicated nodes, use <code>XML::AttributeHash</code>.</p>

<p><span class="divider"></span></p>

<h3 id="representable-api-standalone-collection">Standalone Collection</h3>
<p><!-- {representable-api-standalone-collection-toc} --></p>

<p>Likewise, you can represent <em>lonely collections</em>, instances of <code>Array</code>.</p>

<pre><code>require "representable/json/collection"

class SongsRepresenter &lt; Representable::Decorator
  include Representable::JSON::Collection

  items class: Song do
    property :title
  end
end
</code></pre>

<p>Here, you define how to represent items in the collection using <code>items</code>.</p>

<p>Note that the items can be simple scalar values or deeply nested objects.</p>

<pre><code>ary = [Song.new("Hyper Music"), Song.new("Screenager")]
SongsRepresenter.new(ary).to_json
#=&gt; [{"title":"Hyper Music"},{"title":"Screenager"}]
</code></pre>

<p>Note that this also works for XML.</p>

<p><span class="divider"></span></p>

<h3 id="representable-api-standalone-collection-to_a">Standalone Collection: to_a</h3>
<p><!-- {representable-api-standalone-collection-to_a-toc} --></p>

<p>Another trick to represent collections is using a normal representer with exactly one collection property named <code>to_a</code>.</p>

<pre><code>class SongsRepresenter &lt; Representable::Decorator
  include Representable::JSON # note that this is a plain representer.

  collection :to_a, class: Song do
    property :title
  end
end
</code></pre>

<p>You can use this representer the way you already know and appreciate, but directly on an array.</p>

<pre><code>ary = []
SongsRepresenter.new(ary).from_json('[{"title": "Screenager"}]')
</code></pre>

<p>In order to grab the collection for rendering or parsing, Representable will now call <code>array.to_a</code>, which returns the array itself.</p>

<p><span class="divider"></span></p>

<h3 id="representable-api-automatic-collection-representer">Automatic Collection Representer</h3>
<p><!-- {representable-api-automatic-collection-representer-toc} --></p>

<p>Instead of explicitly defining representers for collections using a <a href="#representable-api-standalone-collection">‚Äúlonely collection‚Äù</a>, you can let Representable  do that for you.</p>

<p>You define a singular representer, Representable will infer the collection representer.</p>

<p>Rendering a collection of objects comes for free, using <code>for_collection</code>.</p>

<pre><code>songs = Song.all
SongRepresenter.for_collection.new(songs).to_json
#=&gt; '[{"title": "Sevens"}, {"title": "Eric"}]'
</code></pre>

<p><code>SongRepresenter.for_collection</code> will return a collection representer class.</p>

<p>For parsing, you need to provide the class for the nested items. This happens via <code>collection_representer</code> in the representer class.</p>

<pre><code>class SongRepresenter &lt; Representable::Decorator
  include Representable::JSON
  property :title

  collection_representer class: Song
end
</code></pre>

<p>You can now parse collections to <code>Song</code> instances.</p>

<pre><code>json  = '[{"title": "Sevens"}, {"title": "Eric"}]'

SongRepresenter.for_collection.new([]).from_json(json)
</code></pre>

<p>Note: the implicit collection representer internally is implemented using a lonely collection. Everything you pass to <code>::collection_representer</code> is simply provided to the <code>::items</code> call in the lonely collection. That allows you to use <code>:populator</code> and all the other goodies, too.</p>

<p><span class="divider"></span></p>

<h3 id="representable-api-automatic-singular-and-collection">Automatic Singular and Collection</h3>
<p><!-- {representable-api-automatic-singular-and-collection-toc} --></p>

<p>In case you don‚Äôt want to know whether or not you‚Äôre working with a collection or singular model, use <code>represent</code>.</p>

<pre><code># singular
SongRepresenter.represent(Song.find(1)).to_json
#=&gt; '{"title": "Sevens"}'

# collection
SongRepresenter.represent(Song.all).to_json
#=&gt; '[{"title": "Sevens"}, {"title": "Eric"}]'
</code></pre>

<p><code>represent</code> figures out the correct representer for you. This works for parsing, too.</p>

<p><span class="divider"></span></p>

<h3 id="representable-api-public-api">Public API</h3>
<p><!-- {representable-api-public-api-toc} --></p>

<p>When decorating an object with a representer, the object needs to provide readers for every defined <code>property</code> - and writers, if you‚Äôre planning to parse.</p>

<h4 id="accessors">Accessors</h4>

<p>In our small <code>SongRepresenter</code> example, the represented object has to provide <code>#id</code> and <code>#title</code> for rendering.</p>

<pre><code>Song = Struct.new(:id, :title)
song = Song.new(1, "Fallout")
</code></pre>

<h4 id="rendering">Rendering</h4>

<p>You can render the document by decorating the object and calling the serializer method.</p>

<pre><code>SongRepresenter.new(song).to_json #=&gt; {"id":1, title":"Fallout"}
</code></pre>

<p>When rendering, the document fragment is read from the represented object using the getter (e.g. <code>Song#id</code>).</p>

<p>Since we use <code>Representable::JSON</code> the serializer method is <code>#to_json</code>.</p>

<p>For other format engines the serializer method will have the following name.</p>

<ul>
  <li><code>Representable::JSON#to_json</code></li>
  <li><code>Representable::JSON#to_hash</code> (provides a hash instead of string)</li>
  <li><code>Representable::Hash#to_hash</code></li>
  <li><code>Representable::XML#to_xml</code></li>
  <li><code>Representable::YAML#to_yaml</code></li>
</ul>

<h4 id="parsing">Parsing</h4>

<p>Likewise, parsing will read values from the document and write them to the represented object.</p>

<pre><code>song = Song.new
SongRepresenter.new(song).from_json('{"id":1, "title":"Fallout"}')
song.id    #=&gt; 1
song.title #=&gt; "Fallout"
</code></pre>

<p>When parsing, the read fragment is written to the represented object using the setter (e.g. <code>Song#id=</code>).</p>

<p>For other format engines, the deserializing method is named analogue to the serializing counterpart, where <code>to</code> becomes <code>from</code>. For example, <code>Representable::XML#from_xml</code> will parse XML if the format engine is mixed into the representer.</p>

<h4 id="user-options">User Options</h4>

<p>You can provide options when representing an object using the <code>user_options:</code> option.</p>

<pre><code>song_representer.to_json(user_options: { is_admin: true })
</code></pre>

<p>Note that the <code>:user_options</code> will be accessible on all levels in a nested representer. They act like a ‚Äúglobal‚Äù configuration and are passed to all option functions.</p>

<p>Here‚Äôs an example where the <code>:if</code> option function evaluates a dynamic user option.</p>

<pre><code>property :id, if: -&gt;(options) { options[:user_options][:is_admin] }
</code></pre>

<p>This property is now only rendered or parsed when <code>:is_admin</code> is true.</p>

<p>Using Ruby 2.1‚Äôs keyword arguments is highly recommended - to make that look a bit nicer.</p>

<pre><code>property :id, if: -&gt;(user_options:, **) { user_options[:is_admin] }
</code></pre>

<h4 id="nested-user-options">Nested User Options</h4>

<p>Representable also allows passing nested options to particular representers. You have to provide the property‚Äôs name to do so.</p>

<pre><code>song_representer.to_json(artist: { user_options: { is_admin: true } })
</code></pre>

<p>This will pass the option to the nested <code>artist</code>, only. Note that this works with any level of nesting.</p>

<h4 id="include-and-exclude">Include and Exclude</h4>

<p>Representable supports two top-level options.</p>

<p><code>:include</code> allows defining a set of properties to represent. The remaining will be skipped.</p>

<pre><code>song_representer.to_json(include: [:id])  #=&gt; {"id":1}
</code></pre>

<p>The other, <code>:exclude</code>, will - you might have guessed it already - skip the provided properties and represent the remaining.</p>

<pre><code>song_representer.to_json(exclude: [:id, :artist])
#=&gt; {"title":"Fallout"}
</code></pre>

<p>As always, these options work both ways, for rendering <em>and</em> parsing.</p>

<p>Note that you can also nest <code>:include</code> and <code>:exclude</code>.</p>

<pre><code>song_representer.to_json(artist: { include: [:name] })
#=&gt; {"id":1, "title":"Fallout", "artist":{"name":"Sting"}}
</code></pre>

<h4 id="tohash-and-fromhash">to_hash and from_hash</h4>

<p><span class="divider"></span></p>

<h2 id="representable-function-api">Function API</h2>
<p><!-- {representable-function-api-toc} --></p>

<p>Both rendering and parsing have a rich API that allows you to hook into particular steps and change behavior.</p>

<p>If that still isn‚Äôt enough, you can create your own pipeline.</p>

<p><span class="divider"></span></p>

<h3 id="representable-function-api-overview">Overview</h3>
<p><!-- {representable-function-api-overview-toc} --></p>

<p>Function option are passed to <code>property</code>.</p>

<pre><code class="language-ruby">property :id, default: "n/a"
</code></pre>

<p>Most options accept a static value, like a string, or a dynamic lambda.</p>

<pre><code class="language-ruby">property :id, if: -&gt;(options) { options[:fragment].nil? }
</code></pre>

<p>The <code>options</code> hash is passed to <strong>all options</strong> and has the following members.</p>

<pre><code>{doc: doc, options: options, represented: represented, decorator: self}

options[:doc] | When rendering, the document as it gets created. When parsing, the entire document.
options[:fragment] | When parsing, this is the fragment read from the document corresponding to this property.
options[:input] | When rendering, this is the value read from the represented object corresponding to this property.
options[:represented] | The currently represented object.
options[:decorator] | The current decorator instance.
options[:binding] | The current binding instance. This allows to access the currently used definition, e.g. `options[:binding][:name]`.
options[:options] | All options that have been passed into the render or parse method.
options[:user_options] | The `:user_options` for the current representer. These are only the [nested options](#nested-user-options) from the user, for a particular representer.
</code></pre>

<p>In your option function, you can either receive the entire options hash and use it in the block.</p>

<pre><code class="language-ruby">if: -&gt;(options) { options[:fragment].nil? }
</code></pre>

<p>Or, and that is the preferred way, use Ruby‚Äôs keyword arguments.</p>

<pre><code class="language-ruby">if: -&gt;(fragment:, **) { fragment.nil? }
</code></pre>

<p><span class="divider"></span></p>

<h3 id="representable-function-api-options">Options</h3>
<p><!-- {representable-function-api-options-toc} --></p>

<p>Here‚Äôs a list of all available options.</p>

<table>
  <tbody>
    <tr>
      <td><code>:as</code></td>
      <td><a href="#representable-function-api-as">Renames</a> property</td>
    </tr>
    <tr>
      <td><code>:getter</code></td>
      <td>Custom <a href="#representable-function-api-getter">getter</a> logic for rendering</td>
    </tr>
    <tr>
      <td><code>:setter</code></td>
      <td>Custom <a href="#representable-function-api-setter">setter</a> logic after parsing</td>
    </tr>
    <tr>
      <td><code>:if</code></td>
      <td><a href="#representable-function-api-if">Includes</a> property when rendering/parsing when evaluated to true</td>
    </tr>
    <tr>
      <td><code>:reader</code></td>
      <td>Overrides entire <a href="#representable-function-api-reader">parsing</a> process for property</td>
    </tr>
    <tr>
      <td><code>:writer</code></td>
      <td>Overrides entire <a href="#representable-function-api-writer">rendering</a> process for property</td>
    </tr>
    <tr>
      <td><code>:skip_parse</code></td>
      <td><a href="#representable-function-api-skip-parse">Skips parsing</a> when evaluated to true</td>
    </tr>
    <tr>
      <td><code>:skip_render</code></td>
      <td><a href="#representable-function-api-skip-render">Skips rendering</a> when evaluated to true</td>
    </tr>
    <tr>
      <td><code>:parse_filter</code></td>
      <td>Pipeline to process <a href="#representable-function-api-parse-filter">parsing result</a></td>
    </tr>
    <tr>
      <td><code>:render_filter</code></td>
      <td>Pipeline to process <a href="#representable-function-api-render-filter">rendering result</a></td>
    </tr>
    <tr>
      <td><code>:deserialize</code></td>
      <td>Override <a href="#representable-function-api-deserialize">deserialization</a> of nested object</td>
    </tr>
    <tr>
      <td><code>:serialize</code></td>
      <td>Override <a href="#representable-function-api-serialize">serialization</a> of nested object</td>
    </tr>
    <tr>
      <td><code>:extend</code></td>
      <td><a href="#representable-function-api-extend">Representer</a> to use for parsing or rendering</td>
    </tr>
    <tr>
      <td><code>:prepare</code></td>
      <td><a href="#representable-function-api-prepare">Decorate</a> the represented object</td>
    </tr>
    <tr>
      <td><code>:class</code></td>
      <td><a href="#representable-function-api-class">Class</a> to instantiate when parsing nested fragment</td>
    </tr>
    <tr>
      <td><code>:instance</code></td>
      <td><a href="#representable-function-api-class">Instantiate</a> object directly when parsing nested fragment</td>
    </tr>
    <tr>
      <td><code>:render_nil</code></td>
      <td><a href="#representable-function-api-render-nil">Render nil</a> values</td>
    </tr>
    <tr>
      <td><code>:render_empty</code></td>
      <td><a href="#representable-function-api-render-empty">Render empty </a> collections</td>
    </tr>
  </tbody>
</table>

<p><span class="divider"></span></p>

<h3 id="representable-function-api-as">As</h3>
<p><!-- {representable-function-api-as-toc} --></p>

<p>If your property name doesn‚Äôt match the name in the document, use the :as option.</p>

<pre><code class="language-ruby">property :title, as: :name
</code></pre>

<p>This will render using the <code>:as</code> value. Vice-versa for parsing</p>

<pre><code class="language-ruby">song.to_json #=&gt; {"name":"Fallout","track":1}
</code></pre>

<p><span class="divider"></span></p>

<h3 id="representable-function-api-getter">Getter</h3>
<p><!-- {representable-function-api-getter-toc} --></p>

<p>When rendering, Representable calls the property‚Äôs getter on the represented object. For a property named <code>:id</code>, this will result in <code>represented.id</code> to retrieve the value for rendering.</p>

<p>You can override this, and instead of having Representable call the getter, run your own logic.</p>

<pre><code class="language-ruby">property :id, getter: -&gt;(represented:, **) { represented.uuid.human_readable }
</code></pre>

<p>In the rendered document, you will find the UUID now where should be the ID.</p>

<pre><code class="language-ruby">decorator.to_json #=&gt; {"id": "f81d4fae-7dec-11d0-a765-00a0c91e6bf6"}
</code></pre>

<p>As helpful as this option is, please do not overuse it. A representer is not a data mapper, but a document transformer. If your underlying data model and your representers diverge too much, consider using a <a href="/2.1/docs/disposable.html">twin</a> to simplify the representer.</p>

<p><span class="divider"></span></p>

<h3 id="representable-function-api-setter">Setter</h3>
<p><!-- {representable-function-api-setter-toc} --></p>

<p>After parsing has happened, the fragment is assigned to the represented object using the property‚Äôs setter. In the above example, Representable will call <code>represented.id=(fragment)</code>.</p>

<p>Override that using <code>:setter</code>.</p>

<pre><code class="language-ruby">property :id,
  setter: -&gt;(fragment:, represented:, **) { represented.uuid = fragment.upcase }
</code></pre>

<p>Again, don‚Äôt overuse this method and consider a twin if you find yourself using <code>:setter</code> for every property.</p>

<p><span class="divider"></span></p>

<h3 id="representable-function-api-if">If</h3>
<p><!-- {representable-function-api-if-toc} --></p>

<p>You can exclude properties when rendering or parsing, as if they were not defined at all. This works with <code>:if</code>.</p>

<pre><code class="language-ruby">property :id, if: -&gt;(user_options:,**) { user_options[:is_admin] }
</code></pre>

<p>When parsing (or rendering), the <code>id</code> property is only considered when <code>is_admin</code> has been passed in.</p>

<p>This will parse the <code>id</code> field.</p>

<pre><code class="language-ruby">decorator.from_json('{"id":1}', user_options: {is_admin: true})
</code></pre>

<p><span class="divider"></span></p>

<h3 id="representable-function-api-reader">Reader</h3>
<p><!-- {representable-function-api-reader-toc} --></p>

<p>To override the entire parsing process, use <code>:reader</code>. You won‚Äôt have access to <code>:fragment</code> here since parsing hasn‚Äôt happened, yet.</p>

<pre><code class="language-ruby">property :id,
  reader: -&gt;(represented:,doc:,**) { represented.payload = doc[:uuid] || "n/a" }
</code></pre>

<p>With <code>:reader</code>, parsing is completely up to you. Representable will only invoke the function and do nothing else.</p>

<p><span class="divider"></span></p>

<h3 id="representable-function-api-writer">Writer</h3>
<p><!-- {representable-function-api-writer-toc} --></p>

<p>To override the entire rendering process, use <code>:writer</code>. You won‚Äôt have access to <code>:input</code> here since the value query to the represented object hasn‚Äôt happened, yet.</p>

<pre><code class="language-ruby">property :id,
  writer: -&gt;(represented:,doc:,**) { doc[:uuid] = represented.id }
</code></pre>

<p>With <code>:writer</code>, rendering is completely up to you. Representable will only invoke the function and do nothing else.</p>

<p><span class="divider"></span></p>

<h3 id="representable-function-api-skip-parse">Skip Parse</h3>
<p><!-- {representable-function-api-skip-parse-toc} --></p>

<p>To suppress parsing of a property, use <code>:skip_parse</code>.</p>

<pre><code class="language-ruby">property :id,
  skip_parse: -&gt;(fragment:,**) { fragment.nil? || fragment=="" }
</code></pre>

<p>No further processing happens with this property, should the option evaluate to true.</p>

<p><span class="divider"></span></p>

<h3 id="representable-function-api-skip-render">Skip Render</h3>
<p><!-- {representable-function-api-skip-render-toc} --></p>

<p>To suppress rendering of a property, use <code>:skip_render</code>.</p>

<pre><code class="language-ruby">property :id,
  skip_render: -&gt;(represented:,**) { represented.id.nil? }
</code></pre>

<p>No further processing happens with this property, should the option evaluate to true.</p>

<p><span class="divider"></span></p>

<h3 id="representable-function-api-parse-filter">Parse Filter</h3>
<p><!-- {representable-function-api-parse-filter-toc} --></p>

<p>Use <code>:parse_filter</code> to process the parsing result.</p>

<pre><code class="language-ruby">property :id,
  parse_filter: -&gt;(fragment, options) { fragment.strip }
</code></pre>

<p>Just before setting the fragment to the object via the setter, the <code>:parse_filter</code> is called.</p>

<p>Note that you can add multiple filters, the result from the last will be passed to the next.</p>

<p><span class="divider"></span></p>

<h3 id="representable-function-api-render-filter">Render Filter</h3>
<p><!-- {representable-function-api-render-filter-toc} --></p>

<p>Use <code>:render_filter</code> to process the rendered fragment.</p>

<pre><code class="language-ruby">property :id,
  render_filter: -&gt;(input, options) { input.strip }
</code></pre>

<p>Just before rendering the fragment into the document, the <code>:render_filter</code> is invoked.</p>

<p>Note that you can add multiple filters, the result from the last will be passed to the next.</p>

<p><span class="divider"></span></p>

<h3 id="representable-function-api-deserialize">Deserialize</h3>
<p><!-- {representable-function-api-deserialize-toc} --></p>

<p>When deserializing a nested fragment, the default mechanics after decorating the represented object are to call <code>represented.from_json(fragment)</code>.</p>

<p>Override this step using <code>:deserialize</code>.</p>

<pre><code class="language-ruby">property :artist,
  deserialize: -&gt;(input:,fragment:,**) { input.attributes = fragment }
</code></pre>

<p>The <code>:input</code> option provides the currently deserialized object.</p>

<p><span class="divider"></span></p>

<h3 id="representable-function-api-serialize">Serialize</h3>
<p><!-- {representable-function-api-serialize-toc} --></p>

<p>When serializing a nested object, the default mechanics after decorating the represented object are to call <code>represented.to_json</code>.</p>

<p>Override this step using <code>:serialize</code>.</p>

<pre><code class="language-ruby">property :artist,
  serialize: -&gt;(represented:,**) { represented.attributes.to_h }
</code></pre>

<p><span class="divider"></span></p>

<h3 id="representable-function-api-extend">Extend</h3>
<p><!-- {representable-function-api-extend-toc} --></p>

<p>Alias: <code>:decorator</code>.</p>

<p>When rendering or parsing a nested object, that represented object needs to get decorated, which is configured via the <code>:extend</code> option.</p>

<p>You can use <code>:extend</code> to configure an explicit representer module or decorator.</p>

<pre><code class="language-ruby">property :artist, extend: ArtistRepresenter
</code></pre>

<p>Alternatively, you could also compute that representer at run-time.</p>

<p>For parsing, this could look like this.</p>

<pre><code class="language-ruby">property :artist,
  extend: -&gt;(fragment:,**) do
    fragment["type"] == "rockstar" ? RockstarRepresenter : ArtistRepresenter
  end
</code></pre>

<p>For rendering, you could do something as follows.</p>

<pre><code class="language-ruby">property :artist,
  extend: -&gt;(input:,**) do
    input.is_a?(Rockstar) ? RockstarRepresenter : ArtistRepresenter
  end
</code></pre>

<p>This allows a dynamic polymorphic representer structure.</p>

<p><span class="divider"></span></p>

<h3 id="representable-function-api-prepare">Prepare</h3>
<p><!-- {representable-function-api-prepare-toc} --></p>

<p>The default mechanics when representing a nested object is decorating the object, then calling the serializer or deserializer method on it.</p>

<p>You can override this step using <code>:prepare</code>.</p>

<pre><code class="language-ruby">property :artist,
  prepare: -&gt;(represented:,**) { ArtistRepresenter.new(input) }
</code></pre>

<p>Just for fun, you could mimic the original behavior.</p>

<pre><code class="language-ruby">property :artist,
  prepare: -&gt;(represented:,binding:,**) { binding[:extend].new(represented) }
</code></pre>

<p><span class="divider"></span></p>

<h3 id="representable-function-api-class">Class</h3>
<p><!-- {representable-function-api-class-toc} --></p>

<p>When parsing a nested fragment, Representable per default creates an object for you. The class can be defined with <code>:class</code>.</p>

<pre><code class="language-ruby">property :artist,
  class: Artist
</code></pre>

<p>It could also be dynamic.</p>

<pre><code class="language-ruby">property :artist,
  class: -&gt;(fragment) { fragment["type"] == "rockstar" ? Rockstar : Artist }
</code></pre>

<p><span class="divider"></span></p>

<h3 id="representable-function-api-instance">Instance</h3>
<p><!-- {representable-function-api-instance-toc} --></p>

<p>Instead of using <code>:class</code> you can directly instantiate the represented object yourself using <code>:instance</code>.</p>

<pre><code class="language-ruby">property :artist,
  instance: -&gt;(fragment) do
    fragment["type"] == "rockstar" ? Rockstar.new : Artist.new
  end
</code></pre>

<p><span class="divider"></span></p>

<h3 id="representable-function-api-render-nil">Render Nil</h3>
<p><!-- {representable-function-api-render-nil-toc} --></p>

<p>In Representable, <code>false</code> values are considered as a valid value and will be rendered into the document or parsed.</p>

<p>If you want <code>nil</code> values to be included when rendering, use the <code>:render_nil</code> option.</p>

<pre><code class="language-ruby">property :title,
  render_nil: true
</code></pre>

<p><span class="divider"></span></p>

<h3 id="representable-function-api-render-empty">Render Empty</h3>
<p><!-- {representable-function-api-render-empty-toc} --></p>

<p>Per default, empty collections are rendered (unless they‚Äôre <code>nil</code>). You can suppress rendering.</p>

<pre><code class="language-ruby">collection :songs,
  render_empty: false
</code></pre>

<p><span class="divider"></span></p>

<h2 id="representable-xml">XML</h2>
<p><!-- {representable-xml-toc} --></p>

<p>If you‚Äôre enjoying the pleasure of working with XML, Representable can help you. It does render and parse XML, too, with an almost identical declarative API.</p>

<pre><code>require "representable/xml"

class SongRepresenter &lt; Representable::Decorator
  include Representable::XML

  property :title
  collection :composers
end
</code></pre>

<p>Note that you have to include the <code>Representable::XML</code> module.</p>

<p>The public API then gives you <code>to_xml</code> and <code>from_xml</code>.</p>

<pre><code class="language-ruby">Song = Struct.new(:title, :composers)
song = Song.new("Fallout", ["Stewart Copeland", "Sting"])
SongRepresenter.new(song).to_xml
</code></pre>

<pre><code class="language-xml">&lt;song&gt;
  &lt;title&gt;Fallout&lt;/title&gt;
  &lt;composers&gt;Stewart Copeland&lt;/composers&gt;
  &lt;composers&gt;Sting&lt;/composers&gt;
&lt;/song&gt;
</code></pre>

<p><span class="divider"></span></p>

<h3 id="representable-xml-tag-attributes">Tag Attributes</h3>
<p><!-- {representable-xml-tag-attributes-toc} --></p>

<p>You can also map properties to tag attributes in Representable. This works only for the top-level node, though (seen from the representer‚Äôs perspective).</p>

<pre><code>class SongRepresenter &lt; Representable::Decorator
  include Representable::XML

  property :title, attribute: true
  collection :composers
end

SongRepresenter.new(song).to_xml
</code></pre>

<pre><code class="language-xml">&lt;song title="Fallout"&gt;
  &lt;composers&gt;Stewart Copeland&lt;/composers&gt;
  &lt;composers&gt;Sting&lt;/composers&gt;
&lt;/song&gt;
</code></pre>

<p>Naturally, this works both ways.</p>

<p><span class="divider"></span></p>

<h3 id="representable-xml-mapping-content">Mapping Content</h3>
<p><!-- {representable-xml-mapping-content-toc} --></p>

<p>The same concept can also be applied to content. If you need to map a property to the top-level node‚Äôs content, use the <code>:content</code> option. Again, <em>top-level</em> refers to the document fragment that maps to the representer.</p>

<pre><code>class SongRepresenter &lt; Representable::Decorator
  include Representable::XML

  property :title, content: true
end

SongRepresenter.new(song).to_xml
</code></pre>

<pre><code class="language-xml">&lt;song&gt;Fallout&lt;/song&gt;
</code></pre>

<p><span class="divider"></span></p>

<h3 id="representable-xml-wrapping-collections">Wrapping Collections</h3>
<p><!-- {representable-xml-wrapping-collections-toc} --></p>

<p>It is sometimes unavoidable to wrap tag lists in a container tag.</p>

<pre><code>class AlbumRepresenter &lt; Representable::Decorator
  include Representable::XML

  collection :songs, as: :song, wrap: :songs
end

Album = Struct.new(:songs)
album = Album.new(["Laundry Basket", "Two Kevins", "Wright and Rong"])

album_representer = AlbumRepresenter.new(album)
album_representer.to_xml
</code></pre>

<p>Note that <code>:wrap</code> defines the container tag name.</p>

<pre><code class="language-xml">&lt;album&gt;
  &lt;songs&gt;
    &lt;song&gt;Laundry Basket&lt;/song&gt;
    &lt;song&gt;Two Kevins&lt;/song&gt;
    &lt;song&gt;Wright and Rong&lt;/song&gt;
  &lt;/songs&gt;
&lt;/album&gt;
</code></pre>

<p><span class="divider"></span></p>

<h3 id="representable-xml-namespace">Namespace</h3>
<p><!-- {representable-xml-namespace-toc} --></p>

<p>Namespaces in XML allow the use of different vocabularies, or set of names, in one document. <a href="http://books.xmlschemata.org/relaxng/relax-CHP-11-SECT-1.html">Read this great article</a> to share our fascination about them.</p>

<p><i class="fa fa-download" aria-hidden="true"></i> Where‚Äôs the <a href="https://github.com/trailblazer/representable/blob/master/test/xml_namespace_test.rb"><strong>EXAMPLE CODE?</strong></a></p>

<div class="bd-callout bd-callout-info">
<p>The <code>Namespace</code> module is available in Representable &gt;= 3.0.4. It doesn‚Äôt work with JRuby due to Nokogiri‚Äôs extremely complex implementation. Please wait for Representable 4.0 where we replace Nokogiri.</p>

<p>For future-compat: <code>Namespace</code> only works in decorator classes, not modules.</p>
</div>

<h4 id="namespace-default">Namespace: Default</h4>

<p>You can define <em>one</em> namespace per representer using <code>::namespace</code> to set the section‚Äôs default namespace.</p>

<pre><code>{{ "test/xml_namespace_test.rb:simple-class:../representable" | tsnippet }}
</code></pre>

<p>Nested representers can be inline or classes (referenced via <code>:decorator</code>). Each class can maintain its own namespace.</p>

<p>Without any mappings, the namespace will be used as the default one.</p>

<pre><code>{{ "test/xml_namespace_test.rb:simple-xml:../representable" | tsnippet }}
</code></pre>

<h4 id="namespace-prefix">Namespace: Prefix</h4>

<p>After defining the namespace URIs in the representers, you can map them to a document-wide <em>prefix</em> in the top representer via <code>::namespace_def</code>.</p>

<pre><code>{{ "test/xml_namespace_test.rb:map-class:../representable" | tsnippet }}
</code></pre>

<p>Note how you can also use <code>:namespace</code> to reference a certain differing prefix per property.</p>

<p>When rendering or parsing, the local property will be extended, e.g. <code>/library/book/isbn</code> will become <code>/lib:library/lib:book/lib:isbn</code>.</p>

<pre><code>{{ "test/xml_namespace_test.rb:map-xml:../representable" | tsnippet }}
</code></pre>

<p>The top representer will include all namespace definitions as <code>xmlns</code> attributes.</p>

<h4 id="namespace-parse">Namespace: Parse</h4>

<p>Namespaces also apply when parsing an XML document to an object structure. When defined, only the known, prefixed tags will be considered.</p>

<pre><code>{{ "test/xml_namespace_test.rb:parse-call:../representable" | tsnippet }}
</code></pre>

<p>In this example, only the <code>/lib:library/lib:book/lib:character/hr:name</code> was parsed.</p>

<pre><code>{{ "test/xml_namespace_test.rb:parse-res:../representable" | tsnippet }}
</code></pre>

<p>If your incoming document has namespaces, please do use and specify them properly.</p>

<h4 id="namespace-remove">Namespace: Remove</h4>

<p>If an incoming document contains namespaces, but you don‚Äôt want to define them in your representers, you can automatically remove them.</p>

<pre><code>class AlbumRepresenter &lt; Representable::Decorator
  include Representable::XML

  remove_namespaces!
end
</code></pre>

<p>This will ditch the namespace prefix and parse all properties as if they never had any prefix in the document, e.g. <code>lib:author</code> becomes <code>author</code>.</p>

<div class="bd-callout bd-callout-info">
<p>Removing namespaces is a Nokogiri hack. It‚Äôs absolutely not recommended as it defeats the purpose of XML namespaces and might result in wrong values being parsed and interpreted.</p>
</div>

<p><span class="divider"></span></p>

<h2 id="representable-yaml">YAML</h2>
<p><!-- {representable-yaml-toc} --></p>

<p>Representable also comes with a YAML representer. Like <a href="#representable-xml">XML</a>, the declarative API is almost identical.</p>

<p><span class="divider"></span></p>

<h3 id="representable-yaml-flow-style-lists">Flow Style Lists</h3>
<p><!-- {representable-yaml-flow-style-lists-toc} --></p>

<p>A nice feature is that <code>#collection</code> also accepts a <code>:style</code> option which helps having nicely formatted inline (or ‚Äúflow‚Äù) arrays in your YAML - if you want that!</p>

<pre><code>require 'representable/yaml'

class SongRepresenter &lt; Representable::Decorator
  include Representable::YAML

  property :title
  property :id
  collection :composers, style: :flow
end
</code></pre>

<h4 id="public-api">Public API</h4>

<p>To render and parse, you invoke <code>to_yaml</code> and <code>from_yaml</code>.</p>

<pre><code class="language-ruby">Song = Struct.new(:title, :id, :composers)
song = Song.new("Fallout", 1, ["Stewart Copeland", "Sting"])
SongRepresenter.new(song).to_yaml
</code></pre>

<pre><code class="language-ruby">---
title: Fallout
id: 1
composers: [Stewart Copeland, Sting]
</code></pre>

<p><span class="divider"></span></p>

<h2 id="representable-debugging">Debugging</h2>
<p><!-- {representable-debugging-toc} --></p>

<p>Representable is a generic mapper using recursions, pipelines and things that might be hard to understand from the outside. That‚Äôs why we got the <code>Debug</code> module which will give helpful output about what it‚Äôs doing when parsing or rendering.</p>

<p>You can extend objects on the run to see what they‚Äôre doing.</p>

<pre><code>SongRepresenter.new(song).extend(Representable::Debug).from_json("..")
SongRepresenter.new(song).extend(Representable::Debug).to_json
</code></pre>

<p>It‚Äôs probably a good idea not to do this in production.</p>

<p><span class="divider"></span></p>

<h2 id="representable-upgrading-guide">Upgrading Guide</h2>
<p><!-- {representable-upgrading-guide-toc} --></p>

<p>We try to make upgrading as smooth as possible. Here‚Äôs the generic documentation, but don‚Äôt hesitate to ask for <a href="https://gitter.im/trailblazer/chat">help on Gitter</a>.</p>

<p><span class="divider"></span></p>

<h3 id="representable-upgrading-guide-2-4-to-3-0">2.4 to 3.0</h3>
<p><!-- {representable-upgrading-guide-2-4-to-3-0-toc} --></p>

<ul>
  <li>The 3.0 line runs with Ruby &gt;2.0, only. This is to make extensive use of keyword arguments.</li>
  <li>All deprecations from 2.4 have been removed.</li>
</ul>

<p>to_hash(user_options: {})
-&gt;(options) { options[:user_options] }
-&gt;(user_options:,**) { user_options }</p>

<p><span class="divider"></span></p>

<h3 id="representable-upgrading-guide-2-3-to-2-4">2.3 to 2.4</h3>
<p><!-- {representable-upgrading-guide-2-3-to-2-4-toc} --></p>

<p>The 2.4 line contains many new features and got a major internal restructuring. It is a transitional release with deprecations for all changes.</p>

<h4 id="breakage">Breakage</h4>

<pre><code>:render_filter =&gt; lambda { |val, options| "#{val.upcase},#{options[:doc]},#{options[:options][:user_options]}" }
</code></pre>

<h4 id="deprecations">Deprecations</h4>

<p>Once your code is migrated to 2.4, you should upgrade to 3.0, which does <em>not</em> have deprecations anymore and only supports Ruby 2.0 and higher.</p>

<p>If you can‚Äôt upgrade to 3.0, you can disable slow and annoying deprecations as follows.</p>

<pre><code>Representable.deprecations = false
</code></pre>

<h4 id="positional-arguments">Positional Arguments</h4>

<p>For dynamic options like <code>:instance</code> or <code>:getter</code> we used to expose a positional API like <code>instance: -&gt;(fragment, options)</code> where every option has a slightly different signature. Even worse, for <code>collection</code>s this would result in a differing signature plus an index like <code>instance: -&gt;(fragment, index, options)</code>.</p>

<p>From Representable 2.4 onwards, only one argument is passed in for all options with an identical, easily memoizable API. Note that the old signatures will print deprecation warnings, but still work.</p>

<p>For parsing, this is as follows (<code>:instance</code> is just an example).</p>

<pre><code>property :artist, instance: -&gt;(options) do
  options[:input]
  options[:fragment] # the parsed fragment
  options[:doc]      # the entire document
  options[:result]   # whatever the former function returned,
                     # usually this is the deserialized object.
  options[:user_options] # options passed into the parse method (e.g. from_json).
  options[:index]    # index of the currently iterated fragment (only with collection)
end
</code></pre>

<p>We highly recommend to use keyword arguments if you‚Äôre using Ruby 2.1+.</p>

<pre><code>property :artist, instance: -&gt;(fragment:, user_options:, **) do
</code></pre>

<h4 id="user-options-1">User Options</h4>

<p>When passing dynamic options to <code>to_hash</code>/<code>from_hash</code> and friends, in older version you were allowed to pass in the options directly.</p>

<pre><code>decorator.to_hash(is_admin: true)
</code></pre>

<p>This is deprecated. You now have to use the <code>:user_options</code> key to make it compatible with library options.</p>

<pre><code>decorator.to_hash(user_options: { is_admin: true })
</code></pre>

<h4 id="pass-options">Pass Options</h4>

<p>The <code>:pass_options</code> option is deprecated and you should simply remove it, even though it still works in &lt; 3.0. You have access to all the environmental object via <code>options[:binding]</code>.</p>

<p>In older version, you might have done as follows.</p>

<pre><code>property :artist, pass_options: true,
  instance: -&gt;(fragment, options) { options.represented }
</code></pre>

<p>Runtime information such as <code>represented</code> or <code>decorator</code> is now available via the generic options.</p>

<pre><code>property :artist, instance: -&gt;(options) do
  options[:binding]              # property Binding instance.
  options[:binding].represented  # the represented object
  options[:user_options]         # options from user.
end
</code></pre>

<p>The same with keyword arguments.</p>

<pre><code>property :artist, instance: -&gt;(binding:, user_options:, **) do
  binding.represented  # the represented object
end
</code></pre>

<h4 id="parse-strategy">Parse Strategy</h4>

<p>The <code>:parse_strategy</code> option is deprecated in favor of <code>:populator</code>. Please replace all occurrences with the new populator style to stay cool.</p>

<p>If you used a <code>:class</code> proc with <code>:parse_strategy</code>, the new API is <code>class: -&gt;(options)</code>. It used to be <code>class: -&gt;(fragment, user_options)</code>.</p>

<h4 id="class-and-instance">Class and Instance</h4>

<p>In older versions you could use <code>:class</code> and <code>:instance</code> in combination, which resulted in hard-to-follow behavior. These options work exclusively now.</p>

<h4 id="skiprender">SkipRender</h4>

<pre><code>skip_render: lambda { |options|
# raise options[:represented].inspect
        options[:user_options][:skip?] and options[:input].name == "Rancid"
</code></pre>

<h4 id="binding">Binding</h4>

<p>The <code>:binding</code> option is deprecated and will be removed in 3.0. You can use your own pipeline and replace the <code>WriteFragment</code> function with your own.</p>

</div>

                <aside>
                  <span class="deco-purple-cross wow fadeIn"></span>
                </aside>
              </main>

              <div class="d-none d-xl-block col-xl-2 list-group sidebar-scroll order-3">
                <img alt="Trailblazer" class="wow fadeIn" src="/vite-dev/images/deco1.png" />
                <div class="features" id="representable-api-features">
  <h3>
    <i class="fas fa-times"></i>
    <span>API</span>
  </h3>

  <ul class="vertical menu">
    
      <li>
        <a href="#representable-api-declarative-api">
          <i class="fas fa-arrow-right"></i>
          Declarative API
        </a>
      </li>
      
    
      <li>
        <a href="#representable-api-feature">
          <i class="fas fa-arrow-right"></i>
          Feature
        </a>
      </li>
      
    
      <li>
        <a href="#representable-api-execution-context">
          <i class="fas fa-arrow-right"></i>
          Execution Context
        </a>
      </li>
      
    
      <li>
        <a href="#representable-api-callable-options">
          <i class="fas fa-arrow-right"></i>
          Callable Options
        </a>
      </li>
      
    
      <li>
        <a href="#representable-api-read-write-restrictions">
          <i class="fas fa-arrow-right"></i>
          Read/Write Restrictions
        </a>
      </li>
      
    
      <li>
        <a href="#representable-api-coercion">
          <i class="fas fa-arrow-right"></i>
          Coercion
        </a>
      </li>
      
    
      <li>
        <a href="#representable-api-symbol-keys">
          <i class="fas fa-arrow-right"></i>
          Symbol Keys
        </a>
      </li>
      
    
      <li>
        <a href="#representable-api-defaults">
          <i class="fas fa-arrow-right"></i>
          Defaults
        </a>
      </li>
      
    
      <li>
        <a href="#representable-api-standalone-hash">
          <i class="fas fa-arrow-right"></i>
          Standalone Hash
        </a>
      </li>
      
    
      <li>
        <a href="#representable-api-standalone-collection">
          <i class="fas fa-arrow-right"></i>
          Standalone Collection
        </a>
      </li>
      
    
      <li>
        <a href="#representable-api-standalone-collection-to_a">
          <i class="fas fa-arrow-right"></i>
          Standalone Collection: to_a
        </a>
      </li>
      
    
      <li>
        <a href="#representable-api-automatic-collection-representer">
          <i class="fas fa-arrow-right"></i>
          Automatic Collection Representer
        </a>
      </li>
      
    
      <li>
        <a href="#representable-api-automatic-singular-and-collection">
          <i class="fas fa-arrow-right"></i>
          Automatic Singular and Collection
        </a>
      </li>
      
    
      <li>
        <a href="#representable-api-public-api">
          <i class="fas fa-arrow-right"></i>
          Public API
        </a>
      </li>
      
    
  </ul>
</div>

<div class="features" id="representable-function-api-features">
  <h3>
    <i class="fas fa-times"></i>
    <span>Function API</span>
  </h3>

  <ul class="vertical menu">
    
      <li>
        <a href="#representable-function-api-overview">
          <i class="fas fa-arrow-right"></i>
          Overview
        </a>
      </li>
      
    
      <li>
        <a href="#representable-function-api-options">
          <i class="fas fa-arrow-right"></i>
          Options
        </a>
      </li>
      
    
      <li>
        <a href="#representable-function-api-as">
          <i class="fas fa-arrow-right"></i>
          As
        </a>
      </li>
      
    
      <li>
        <a href="#representable-function-api-getter">
          <i class="fas fa-arrow-right"></i>
          Getter
        </a>
      </li>
      
    
      <li>
        <a href="#representable-function-api-setter">
          <i class="fas fa-arrow-right"></i>
          Setter
        </a>
      </li>
      
    
      <li>
        <a href="#representable-function-api-if">
          <i class="fas fa-arrow-right"></i>
          If
        </a>
      </li>
      
    
      <li>
        <a href="#representable-function-api-reader">
          <i class="fas fa-arrow-right"></i>
          Reader
        </a>
      </li>
      
    
      <li>
        <a href="#representable-function-api-writer">
          <i class="fas fa-arrow-right"></i>
          Writer
        </a>
      </li>
      
    
      <li>
        <a href="#representable-function-api-skip-parse">
          <i class="fas fa-arrow-right"></i>
          Skip Parse
        </a>
      </li>
      
    
      <li>
        <a href="#representable-function-api-skip-render">
          <i class="fas fa-arrow-right"></i>
          Skip Render
        </a>
      </li>
      
    
      <li>
        <a href="#representable-function-api-parse-filter">
          <i class="fas fa-arrow-right"></i>
          Parse Filter
        </a>
      </li>
      
    
      <li>
        <a href="#representable-function-api-render-filter">
          <i class="fas fa-arrow-right"></i>
          Render Filter
        </a>
      </li>
      
    
      <li>
        <a href="#representable-function-api-deserialize">
          <i class="fas fa-arrow-right"></i>
          Deserialize
        </a>
      </li>
      
    
      <li>
        <a href="#representable-function-api-serialize">
          <i class="fas fa-arrow-right"></i>
          Serialize
        </a>
      </li>
      
    
      <li>
        <a href="#representable-function-api-extend">
          <i class="fas fa-arrow-right"></i>
          Extend
        </a>
      </li>
      
    
      <li>
        <a href="#representable-function-api-prepare">
          <i class="fas fa-arrow-right"></i>
          Prepare
        </a>
      </li>
      
    
      <li>
        <a href="#representable-function-api-class">
          <i class="fas fa-arrow-right"></i>
          Class
        </a>
      </li>
      
    
      <li>
        <a href="#representable-function-api-instance">
          <i class="fas fa-arrow-right"></i>
          Instance
        </a>
      </li>
      
    
      <li>
        <a href="#representable-function-api-render-nil">
          <i class="fas fa-arrow-right"></i>
          Render Nil
        </a>
      </li>
      
    
      <li>
        <a href="#representable-function-api-render-empty">
          <i class="fas fa-arrow-right"></i>
          Render Empty
        </a>
      </li>
      
    
  </ul>
</div>

<div class="features" id="representable-xml-features">
  <h3>
    <i class="fas fa-times"></i>
    <span>XML</span>
  </h3>

  <ul class="vertical menu">
    
      <li>
        <a href="#representable-xml-tag-attributes">
          <i class="fas fa-arrow-right"></i>
          Tag Attributes
        </a>
      </li>
      
    
      <li>
        <a href="#representable-xml-mapping-content">
          <i class="fas fa-arrow-right"></i>
          Mapping Content
        </a>
      </li>
      
    
      <li>
        <a href="#representable-xml-wrapping-collections">
          <i class="fas fa-arrow-right"></i>
          Wrapping Collections
        </a>
      </li>
      
    
      <li>
        <a href="#representable-xml-namespace">
          <i class="fas fa-arrow-right"></i>
          Namespace
        </a>
      </li>
      
    
  </ul>
</div>

<div class="features" id="representable-yaml-features">
  <h3>
    <i class="fas fa-times"></i>
    <span>YAML</span>
  </h3>

  <ul class="vertical menu">
    
      <li>
        <a href="#representable-yaml-flow-style-lists">
          <i class="fas fa-arrow-right"></i>
          Flow Style Lists
        </a>
      </li>
      
    
  </ul>
</div>

<div class="features" id="representable-debugging-features">
  <h3>
    <i class="fas fa-times"></i>
    <span>Debugging</span>
  </h3>

  <ul class="vertical menu">
    
  </ul>
</div>

<div class="features" id="representable-upgrading-guide-features">
  <h3>
    <i class="fas fa-times"></i>
    <span>Upgrading Guide</span>
  </h3>

  <ul class="vertical menu">
    
      <li>
        <a href="#representable-upgrading-guide-2-4-to-3-0">
          <i class="fas fa-arrow-right"></i>
          2.4 to 3.0
        </a>
      </li>
      
    
      <li>
        <a href="#representable-upgrading-guide-2-3-to-2-4">
          <i class="fas fa-arrow-right"></i>
          2.3 to 2.4
        </a>
      </li>
      
    
  </ul>
</div>

              </div>
            </div>
          </div>
        </section>
      </main>

      <footer class="trailblazer-footer">
  <div class="container">
    <div class="row align-items-center">
      <div class="col-md-3 col-lg-2">
        <a href="/2.1/index.html" class="logo-footer">Trailblazer</a>
      </div>
      <div class="col-md-6 col-lg-8">
        <nav>
          <ul class="navbar-nav documentation-nav-items">
  <li>
    <a class="nav-item nav-link active" href="/2.1/docs/trailblazer.html">
      <i class="fas fa-arrow-right"></i>
      DOCS
    </a>
  </li>

  <li>
    <a class="nav-item nav-link " href="https://dev.to/trailblazer">BLOG</a>
  </li>

  <li class="d-none d-md-block">
    <a class="nav-item nav-link " href="/2.1/about_us.html">ABOUT US</a>
  </li>

  <li>
    <a class="nav-item nav-link " href="/2.1/learn.html">LEARN</a>
  </li>

  <li class="d-none d-md-block">
    <a class="nav-item nav-link" href="/2.0">
      <i class="fas fa-arrow-right"></i>
      2.0
    </a>
  </li>

  <li>
    <a class="nav-item nav-link" href="https://trailblazer.zulipchat.com" target="_blank">
      <i class="fas fa-comments"></i>
      CHAT
    </a>
  </li>

  <li>
    <div id="docsearch"></div> <!-- https://docsearch.algolia.com/docs/DocSearch-v3 -->
  </li>
</ul>

        </nav>
      </div>
      <div class="col-md-3 col-lg-2">
        <ul class="social purple">
          <li>
            <a href="https://github.com/trailblazer" target="_blank"><i class="fab fa-github-square"></i></a>
          </li>
          <li>
            <a href="https://www.facebook.com/trailblazer.to" target="_blank"><i class="fab fa-facebook-square"></i></a>
          </li>
          <li>
            <a href="https://twitter.com/trailblazer_to" target="_blank"><i class="fab fa-twitter-square"></i></a>
          </li>
        </ul>
      </div>
    </div>
  </div>
</footer>

    </div>
  </body>
</html>
