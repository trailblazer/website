<!DOCTYPE html>
<html lang="en" data-theme="dark">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, shrink-to-fit=no">

    <title>Trailblazer - Reform</title>

    
    <script src="/vite/assets/documentation.cf6dc4c3.js" crossorigin="anonymous" type="module"></script><link rel="modulepreload" href="/vite/assets/main.34ffa703.js" as="script" crossorigin="anonymous">
<link rel="modulepreload" href="/vite/assets/initAnchor.41728d3b.js" as="script" crossorigin="anonymous"><link rel="stylesheet" href="/vite/assets/main.a6472465.css" media="screen" />
<link rel="stylesheet" href="/vite/assets/initAnchor.b31c4ff7.css" media="screen" />

    <link
      href="https://fonts.googleapis.com/css?family=Raleway:200,300,400,500,600,700,800"
      rel="stylesheet"
    >
    <link
      href="https://fonts.googleapis.com/icon?family=Material+Icons"
      rel="stylesheet"
    >
    <link
      rel="preconnect"
      href="https://R2IYF7ETH7-dsn.algolia.net" crossorigin
    >
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/@docsearch/css@3"
    >

    
      <!-- Global site tag (gtag.js) - Google Analytics -->
      <script
        async
        src="https://www.googletagmanager.com/gtag/js?id=UA-69514939-1"
      ></script>
      <script>
        window.dataLayer = window.dataLayer || [];
        function gtag() {
          dataLayer.push(arguments);
        }
        gtag("js", new Date());

        gtag("config", "UA-69514939-1");
      </script>
    

    <link rel="icon" type="image/png" sizes="32x32" href="/vite/assets/favicon.39e9303e.ico">
  </head>
  <body>
    <div class="alert alert-primary m-0 rounded-0 text-center" role="alert">
      <span class="alert-text text-center">
        <!-- The new TRB 2.1 book series has begun - 82 pages are <a class="alert-link" href="https://leanpub.com/buildalib">waiting for you</a>! -->
        Dear Russian friends, please watch President Zelenskyy's
        <a href="https://twitter.com/PMoelleken/status/1496941845812760577">speech addressed to you</a>.
        üá∫üá¶ Help our brave mates in Ukraine
        <a
          href="https://actions.sumofus.org/a/give-to-ukrainians-who-need-an-urgent-lifeline"
        >
          with a donation
        </a>.
      </span>
    </div>

    <div class="lg-bg">
      <!-- Add class="session-show" if you need a header with dark background -->
      <header
        id="header"
        class="trailblazer-header documentation-navbar navbar navbar-expand-lg flex-column flex-md-row"
      >
        <h1 class="m-2">
          <a class="navbar-brand mr-0 mr-md-2" href="/2.1/index.html">Trailblazer</a>
        </h1>

        <div class="navbar-nav-scroll ml-md-auto">
          <ul class="navbar-nav documentation-nav-items">
  <li>
    <a class="nav-item nav-link active" href="/2.1/docs/trailblazer.html">
      <i class="fas fa-arrow-right"></i>
      DOCS
    </a>
  </li>

  <li>
    <a class="nav-item nav-link " href="https://dev.to/trailblazer">BLOG</a>
  </li>

  <li class="d-none d-md-block">
    <a class="nav-item nav-link " href="/2.1/about_us.html">ABOUT US</a>
  </li>

  <li>
    <a class="nav-item nav-link " href="/2.1/learn.html">LEARN</a>
  </li>

  <li class="d-none d-md-block">
    <a class="nav-item nav-link" href="/2.0/index.html">
      <i class="fas fa-arrow-right"></i>
      2.0
    </a>
  </li>

  <li>
    <a class="nav-item nav-link" href="https://trailblazer.zulipchat.com" target="_blank">
      <i class="fas fa-comments"></i>
      CHAT
    </a>
  </li>

  <!--
  
    <li>
      <div id="docsearch"></div> https://docsearch.algolia.com/docs/DocSearch-v3
    </li>
  
  -->
</ul>

        </div>
      </header>

      <main>
        <section class="documentation-main">
          <div class="container-fluid">
            <div class="row flex-xl-nowrap">
              <div class="col-md-3 col-xl-2 border-bottom order-1 sidebar-accordion sidebar-scroll">
                <form class="d-md-none d-flex align-items-center position-relative py-3 mx-n3 border-bottom">
                  <button
                    class="navbar-toggler collapsed"
                    type="button"
                    data-toggle="collapse"
                    data-target="#navBarTrailBlazer"
                    aria-controls="navBarTrailBlazer"
                    aria-expanded="false"
                    aria-label="Toggle navigation"
                  >
                    <i class="far fa-lg fa-bars"></i>
                  </button>
                </form>
                <div class="collapse d-md-block py-3 mx-n3" id="navBarTrailBlazer">
                  <div class="border-bottom">
  <div class="my-4">
    <div class="sidebar-accordion-wrapper">
  <div id="trailblazer">
    <h2 class="mb-0 mt-1 sidebar-accordion-item">
      <a href="/2.1/docs/trailblazer.html">
        <button
          class="collapsed"
          data-toggle="collapse"
          data-target="#trailblazer-collapse"
          aria-expanded="false"
          aria-controls="trailblazer-collapse"
        >
          <i class="fas fa-chevron-right"></i>
          <i class="fas fa-times"></i>
          <span>Trailblazer</span>
        </button>
      </a>
    </h2>
  </div>

  
</div>

<div class="sidebar-accordion-wrapper">
  <div id="rails-integration">
    <h2 class="mb-0 mt-1 sidebar-accordion-item">
      <a href="/2.1/docs/rails.html">
        <button
          class="collapsed"
          data-toggle="collapse"
          data-target="#rails-integration-collapse"
          aria-expanded="false"
          aria-controls="rails-integration-collapse"
        >
          <i class="fas fa-chevron-right"></i>
          <i class="fas fa-times"></i>
          <span>Rails Integration</span>
        </button>
      </a>
    </h2>
  </div>

  
</div>

<div class="sidebar-accordion-wrapper">
  <div id="test">
    <h2 class="mb-0 mt-1 sidebar-accordion-item">
      <a href="/2.1/docs/test.html">
        <button
          class="collapsed"
          data-toggle="collapse"
          data-target="#test-collapse"
          aria-expanded="false"
          aria-controls="test-collapse"
        >
          <i class="fas fa-chevron-right"></i>
          <i class="fas fa-times"></i>
          <span>Test</span>
        </button>
      </a>
    </h2>
  </div>

  
</div>

  </div>
</div>

<div class="border-bottom">
  <div class="my-4">
    <div class="sidebar-accordion-wrapper">
  <div id="activity">
    <h2 class="mb-0 mt-1 sidebar-accordion-item">
      <a href="/2.1/docs/activity.html">
        <button
          class="collapsed"
          data-toggle="collapse"
          data-target="#activity-collapse"
          aria-expanded="false"
          aria-controls="activity-collapse"
        >
          <i class="fas fa-chevron-right"></i>
          <i class="fas fa-times"></i>
          <span>Activity</span>
        </button>
      </a>
    </h2>
  </div>

  
</div>

<div class="sidebar-accordion-wrapper">
  <div id="operation">
    <h2 class="mb-0 mt-1 sidebar-accordion-item">
      <a href="/2.1/docs/operation.html">
        <button
          class="collapsed"
          data-toggle="collapse"
          data-target="#operation-collapse"
          aria-expanded="false"
          aria-controls="operation-collapse"
        >
          <i class="fas fa-chevron-right"></i>
          <i class="fas fa-times"></i>
          <span>Operation</span>
        </button>
      </a>
    </h2>
  </div>

  
</div>

<div class="sidebar-accordion-wrapper">
  <div id="workflow">
    <h2 class="mb-0 mt-1 sidebar-accordion-item">
      <a href="/2.1/docs/workflow.html">
        <button
          class="collapsed"
          data-toggle="collapse"
          data-target="#workflow-collapse"
          aria-expanded="false"
          aria-controls="workflow-collapse"
        >
          <i class="fas fa-chevron-right"></i>
          <i class="fas fa-times"></i>
          <span>Workflow</span>
        </button>
      </a>
    </h2>
  </div>

  
</div>

<div class="sidebar-accordion-wrapper">
  <div id="endpoint">
    <h2 class="mb-0 mt-1 sidebar-accordion-item">
      <a href="/2.1/docs/endpoint.html">
        <button
          class="collapsed"
          data-toggle="collapse"
          data-target="#endpoint-collapse"
          aria-expanded="false"
          aria-controls="endpoint-collapse"
        >
          <i class="fas fa-chevron-right"></i>
          <i class="fas fa-times"></i>
          <span>Endpoint</span>
        </button>
      </a>
    </h2>
  </div>

  
</div>

  </div>
</div>

<div class="border-bottom">
  <div class="my-4">
    <div class="sidebar-accordion-wrapper">
  <div id="reform">
    <h2 class="mb-0 mt-1 sidebar-accordion-item">
      <a href="/2.1/docs/reform.html">
        <button
          class=""
          data-toggle="collapse"
          data-target="#reform-collapse"
          aria-expanded="true"
          aria-controls="reform-collapse"
        >
          <i class="fas fa-chevron-right"></i>
          <i class="fas fa-times"></i>
          <span>Reform</span>
        </button>
      </a>
    </h2>
  </div>

  
    <div
      id="reform-collapse"
      class="collapse show"
      aria-labelledby="reform"
      data-parent="#accordion"
    >
      <ul class="nav vertical menu navbar-light">
        
          <li class="nav-item">
            <a class="nav-link active" href="#reform-overview">
              Overview
            </a>
          </li>
        
          <li class="nav-item">
            <a class="nav-link " href="#reform-api">
              API
            </a>
          </li>
        
          <li class="nav-item">
            <a class="nav-link " href="#reform-options">
              Options
            </a>
          </li>
        
          <li class="nav-item">
            <a class="nav-link " href="#reform-data-types">
              Data Types
            </a>
          </li>
        
          <li class="nav-item">
            <a class="nav-link " href="#reform-populators">
              Populators
            </a>
          </li>
        
          <li class="nav-item">
            <a class="nav-link " href="#reform-prepopulating">
              Prepopulating
            </a>
          </li>
        
          <li class="nav-item">
            <a class="nav-link " href="#reform-validation">
              Validation
            </a>
          </li>
        
          <li class="nav-item">
            <a class="nav-link " href="#reform-rails">
              Rails
            </a>
          </li>
        
          <li class="nav-item">
            <a class="nav-link " href="#reform-upgrading-guide">
              Upgrading Guide
            </a>
          </li>
        
      </ul>
    </div>
  
</div>

<div class="sidebar-accordion-wrapper">
  <div id="cells">
    <h2 class="mb-0 mt-1 sidebar-accordion-item">
      <a href="/2.1/docs/cells.html">
        <button
          class="collapsed"
          data-toggle="collapse"
          data-target="#cells-collapse"
          aria-expanded="false"
          aria-controls="cells-collapse"
        >
          <i class="fas fa-chevron-right"></i>
          <i class="fas fa-times"></i>
          <span>Cells</span>
        </button>
      </a>
    </h2>
  </div>

  
</div>

<div class="sidebar-accordion-wrapper">
  <div id="representable">
    <h2 class="mb-0 mt-1 sidebar-accordion-item">
      <a href="/2.1/docs/representable.html">
        <button
          class="collapsed"
          data-toggle="collapse"
          data-target="#representable-collapse"
          aria-expanded="false"
          aria-controls="representable-collapse"
        >
          <i class="fas fa-chevron-right"></i>
          <i class="fas fa-times"></i>
          <span>Representable</span>
        </button>
      </a>
    </h2>
  </div>

  
</div>

<div class="sidebar-accordion-wrapper">
  <div id="disposable">
    <h2 class="mb-0 mt-1 sidebar-accordion-item">
      <a href="/2.1/docs/disposable.html">
        <button
          class="collapsed"
          data-toggle="collapse"
          data-target="#disposable-collapse"
          aria-expanded="false"
          aria-controls="disposable-collapse"
        >
          <i class="fas fa-chevron-right"></i>
          <i class="fas fa-times"></i>
          <span>Disposable</span>
        </button>
      </a>
    </h2>
  </div>

  
</div>

<div class="sidebar-accordion-wrapper">
  <div id="roar">
    <h2 class="mb-0 mt-1 sidebar-accordion-item">
      <a href="/2.1/docs/roar.html">
        <button
          class="collapsed"
          data-toggle="collapse"
          data-target="#roar-collapse"
          aria-expanded="false"
          aria-controls="roar-collapse"
        >
          <i class="fas fa-chevron-right"></i>
          <i class="fas fa-times"></i>
          <span>Roar</span>
        </button>
      </a>
    </h2>
  </div>

  
</div>

  </div>
</div>

<div class="border-bottom">
  <div class="my-4">
    <div class="sidebar-accordion-wrapper">
  <div id="tutorials">
    <h2 class="mb-0 mt-1 sidebar-accordion-item">
      <a href="/2.1/docs/tutorials/activity.html">
        <button
          class="collapsed"
          data-toggle="collapse"
          data-target="#tutorials-collapse"
          aria-expanded="false"
          aria-controls="tutorials-collapse"
        >
          <i class="fas fa-chevron-right"></i>
          <i class="fas fa-times"></i>
          <span>Tutorials</span>
        </button>
      </a>
    </h2>
  </div>

  
</div>

<div class="sidebar-accordion-wrapper">
  <div id="pro">
    <h2 class="mb-0 mt-1 sidebar-accordion-item">
      <a href="/2.1/docs/pro.html">
        <button
          class="collapsed"
          data-toggle="collapse"
          data-target="#pro-collapse"
          aria-expanded="false"
          aria-controls="pro-collapse"
        >
          <i class="fas fa-chevron-right"></i>
          <i class="fas fa-times"></i>
          <span>PRO</span>
        </button>
      </a>
    </h2>
  </div>

  
</div>

  </div>
</div>

                </div>
              </div>

              <main
                class="col-md-9 col-xl-8 py-md-5 pl-md-5 order-2"
                role="main"
              >
                <div class="doc-block section-name session-show">
                  <h1 class="w-100">Reform</h1>
                  <ul>
                    <li>
                      <i class="far fa-clock pink"></i>
                      <span>Last updated 27 Sep 22</span>
                    </li>
                  </ul>
                </div>

                <div class="doc-block">
<p>Reform provides form objects to run validations for one or multiple models.</p>

<p><span class="divider"></span></p>

<h2 id="reform-overview">Overview</h2>
<p><!-- {reform-overview-toc} --></p>

<p>Validations no longer sit in model classes, but in forms. Once the data is coerced and validated, it can be written to the model.</p>

<p>A <em>model</em> can be any kind of Ruby object. Reform is completely framework-agnostic and doesn‚Äôt care about your database.</p>

<p>A <em>form</em> doesn‚Äôt have to be a UI component, necessarily! It can be an intermediate validation before writing data to the persistence layer. While form objects may be used to render graphical web forms, Reform is used in many pure-API applications for deserialization and validation.</p>

<ul>
  <li><strong>API</strong> In Reform, form classes define fields and validations for the input. This input can be validated using <code>validate</code> and written to the model using <code>sync</code> or <code>save</code>. <a href="#reform-api">‚Üí API</a></li>
  <li><strong>DATA TYPES</strong> Reform can map model attributes, compositions of objects, nested models, hash fields and more. <a href="#reform-data-types">‚Üí DATA TYPES</a></li>
  <li><strong>COERCION</strong> When validating, the form can coerce input to arbitrary values using the dry-types gem. <a href="#reform-options-coercion">‚Üí COERCION</a></li>
  <li><strong>POPULATOR</strong> Deserialization of the incoming data can be customized using populators. <a href="#reform-populators">‚Üí POPULATOR</a></li>
  <li><strong>VALIDATION GROUPS</strong> Validations can be chained or run when certain criteria match, only. <a href="#reform-validation">‚Üí VALIDATION GROUPS</a></li>
</ul>

<p>For a technical architecture overview, read the <a href="#reform-overview-architecture">Architecture</a> section.</p>

<p><span class="divider"></span></p>

<h3 id="reform-overview-api">API</h3>
<p><!-- {reform-overview-api-toc} --></p>

<p>Forms are defined in classes. Often, these classes partially map to a model.</p>

<ul id="app/concepts/documentation/page/snippet/reform/overview.md.erb-22" class="nav nav-tabs"> <li class="nav-item"> <a href="#" class="nav-link pink active active" data-toggle="tab" data-tag="#app-concepts-documentation-page-snippet-reform-overview-md-erb-22-dry-validation"> dry-validation </a> </li><li class="nav-item"> <a href="#" class="nav-link pink " data-toggle="tab" data-tag="#app-concepts-documentation-page-snippet-reform-overview-md-erb-22-ActiveModel"> ActiveModel </a> </li> </ul>
<div class="tab-content"> <div id="app-concepts-documentation-page-snippet-reform-overview-md-erb-22-dry-validation" class="tab-pane fade show active"> 
<pre><code>class AlbumForm &lt; Reform::Form
  feature Reform::Form::Dry

  property :name

  validation do
    params do
      required(:name).filled
    end
  end
end
</code></pre>

 </div><div id="app-concepts-documentation-page-snippet-reform-overview-md-erb-22-ActiveModel" class="tab-pane fade show "> 
<pre><code>class AlbumForm &lt; Reform::Form
  property :title

  validates :title, presence: true
end
</code></pre>

 </div> </div>

<p>Form fields are specified using <code>property</code> and <code>collection</code>, validations for the fields using the respective validation engine‚Äôs API.</p>

<p>Forms can also be nested and map to more complex object graphs.</p>

<ul id="app/concepts/documentation/page/snippet/reform/overview.md.erb-40" class="nav nav-tabs"> <li class="nav-item"> <a href="#" class="nav-link pink active active" data-toggle="tab" data-tag="#app-concepts-documentation-page-snippet-reform-overview-md-erb-40-dry-validation"> dry-validation </a> </li><li class="nav-item"> <a href="#" class="nav-link pink " data-toggle="tab" data-tag="#app-concepts-documentation-page-snippet-reform-overview-md-erb-40-ActiveModel"> ActiveModel </a> </li> </ul>
<div class="tab-content"> <div id="app-concepts-documentation-page-snippet-reform-overview-md-erb-40-dry-validation" class="tab-pane fade show active"> 
<pre><code>class AlbumForm &lt; Reform::Form
  feature Reform::Form::Dry

  property :name

  validation do
    params { required(:name).filled }
  end

  property :artist do
    property :name

    validation do
      params { required(:name).filled }
    end
  end
end
</code></pre>

 </div><div id="app-concepts-documentation-page-snippet-reform-overview-md-erb-40-ActiveModel" class="tab-pane fade show "> 
<pre><code>class AlbumForm &lt; Reform::Form
  property :title

  validates :title, presence: true

  property :artist do
    property :name

    validates :name, presence: true
  end
end
</code></pre>

 </div> </div>

<p>While Reform is perfectly suited to map nested models with associations, it also allows mapping via composition, to hash fields, and more. Check out the <a href="#reform-data-types">supported data types</a>.</p>

<p><span class="divider"></span></p>

<h3 id="reform-overview-setup">Setup</h3>
<p><!-- {reform-overview-setup-toc} --></p>

<p>In your controller or operation you create a form instance and pass in the models you want to validate data against.</p>

<pre><code>class AlbumsController &lt; ApplicationController
  def new
    @form = AlbumForm.new(Album.new)
  end
</code></pre>

<p>This will also work as an editing form with an existing album.</p>

<pre><code>def edit
  @form = AlbumForm.new(Album.find(1))
end
</code></pre>

<p>In setup, Reform will read values from the model.</p>

<pre><code class="language-ruby">model = Album.find(1)
model.title #=&gt; "The Aristocrats"

@form = AlbumForm.new(model)
@form.title #=&gt; "The Aristocrats"
</code></pre>

<p>Once read, the original model‚Äôs values will never be accessed.</p>

<p><span class="divider"></span></p>

<h3 id="reform-overview-rendering">Rendering</h3>
<p><!-- {reform-overview-rendering-toc} --></p>

<p>Your <code>@form</code> is now ready to be rendered, either do it yourself or use something like Rails‚Äô <code>#form_for</code>, <code>simple_form</code> or <code>formtastic</code>.</p>

<pre><code>= form_for @form do |f|
  = f.input :title
</code></pre>

<p>Nested forms and collections can be easily rendered with <code>fields_for</code>, etc. Note that you no longer pass the model to the form builder, but the Reform instance.</p>

<p>Optionally, you might want to use the <code>#prepopulate!</code> method to pre-populate fields and prepare the form for rendering.</p>

<p><span class="divider"></span></p>

<h3 id="reform-overview-validation">Validation</h3>
<p><!-- {reform-overview-validation-toc} --></p>

<p>A submitted form is processed via <code>validate</code>.</p>

<pre><code class="language-ruby">result = @form.validate(title: "Greatest Hits")
</code></pre>

<p>By passing the incoming hash to <code>validate</code>, the input is written to the form and validated.</p>

<p>This usually happens in a processing controller action.</p>

<pre><code>def create
  @form = AlbumForm.new(Album.new)

  if @form.validate(params[:album])
    # persist data
    @form.save
  end
end
</code></pre>

<p>After validation, the form‚Äôs values reflect the validated data.</p>

<pre><code class="language-ruby">@form.validate(title: "Greatest Hits")
@form.title #=&gt; "Greatest Hits"
</code></pre>

<p>Note that the model remains untouched - validation solely happens on the form object.</p>

<pre><code class="language-ruby">model.title #=&gt; "The Aristocrats"
</code></pre>

<p>Reform never writes anything to the models, until you tell it to do so.</p>

<p><span class="divider"></span></p>

<h3 id="reform-overview-persisting">Persisting</h3>
<p><!-- {reform-overview-persisting-toc} --></p>

<p>The easiest way to persist validated data is to call <code>#save</code> on the form.</p>

<pre><code class="language-ruby">if form.validate(params[:song])
  form.save
end
</code></pre>

<p>This will write the data to the model(s) using <code>sync</code> and then call <code>album.save</code>.</p>

<p>You may save data manually using <a href="#reform-api-save"><code>save</code> with a block</a>.</p>

<pre><code>form.save do |nested_hash|
  Album.create(title: nested_hash["title"])
end
</code></pre>

<p>Or you can let Reform write the validated data to the model(s) without saving anything.</p>

<pre><code class="language-ruby">form.sync # the album is unsaved!
</code></pre>

<p>This will updated the model‚Äôs attributes using its setter methods, but not <code>save</code> anything.</p>

<p><span class="divider"></span></p>

<h3 id="reform-overview-installation">Installation</h3>
<p><!-- {reform-overview-installation-toc} --></p>

<ul id="app/concepts/documentation/page/snippet/reform/overview.md.erb-164" class="nav nav-tabs"> <li class="nav-item"> <a href="#" class="nav-link pink active active" data-toggle="tab" data-tag="#app-concepts-documentation-page-snippet-reform-overview-md-erb-164-dry-validation"> dry-validation </a> </li><li class="nav-item"> <a href="#" class="nav-link pink " data-toggle="tab" data-tag="#app-concepts-documentation-page-snippet-reform-overview-md-erb-164-ActiveModel"> ActiveModel </a> </li> </ul>
<div class="tab-content"> <div id="app-concepts-documentation-page-snippet-reform-overview-md-erb-164-dry-validation" class="tab-pane fade show active"> 
<p>Add this your Gemfile.</p>

<pre><code>gem "reform"
gem "dry-validation"
</code></pre>

<p>Please use <a href="http://dry-rb.org/gems/dry-validation">dry-validation</a>, which is our recommended validation engine. Put the following snippet into an initializer.</p>

<pre><code>require "reform/form/dry"

Reform::Form.class_eval do
  include Reform::Form::Dry
end
</code></pre>

 </div><div id="app-concepts-documentation-page-snippet-reform-overview-md-erb-164-ActiveModel" class="tab-pane fade show "> 
<p>Add this to your Gemfile.</p>

<pre><code>gem "reform"
gem "reform-rails"
</code></pre>

<p>To use <code>ActiveModel</code> for validations put this into an initializer.</p>

<pre><code>require "reform/form/active_model/validations"

Reform::Form.class_eval do
  include Reform::Form::ActiveModel::Validations
end
</code></pre>

<p>Things you should know when using ActiveModel with Reform.</p>

<ul>
  <li><code>ActiveModel</code> support is provided by the <code>reform-rails</code> gem. You have to add it to your <code>Gemfile</code>.</li>
  <li>The above last step of including <code>ActiveModel::Validations</code> is done automatically in a Rails environment.</li>
  <li>Reform works fine with Rails 3.1-4.2. However, inheritance of validations with <code>ActiveModel::Validations</code> is broken in Rails 3.2 and 4.0.</li>
</ul>

 </div> </div>

<p><span class="divider"></span></p>

<h3 id="reform-overview-design-concepts">Design Concepts</h3>
<p><!-- {reform-overview-design-concepts-toc} --></p>

<ul>
  <li>
    <p><strong>FRAMEWORK-AGNOSTIC</strong> Reform is completely framework-agnostic and is used in many projects with Rails, Sinatra, Hanami and more.</p>

    <p>For Rails, the <a href="#reform-rails">reform-rails gem</a> provides convenient glue code to make Reform work with Rails‚Äô form builders and <code>ActiveModel::Validations</code>.</p>
  </li>
  <li>
    <p><strong>ORMs</strong> Reform works with any ORM or PORO - it has zero knowledge about underlying databases per design. The only requirements are reader and writer methods on the model(s) for defined properties.</p>
  </li>
  <li>
    <p><strong>DATA MAPPING</strong> Reform helps mapping one or many models to a form object. Nevertheless, Reform is <em>not</em> a full-blown data mapper. It still is a form object. Simple data mapping like composition, delegation or hash fields come from the <a href="/2.1/docs/disposable.html">Disposable</a> gem.</p>

    <p>Should you require more complex mapping, use something such as ROM and pass it to the form object.</p>
  </li>
  <li>
    <p><strong>SECURITY</strong> Reform simply ignores unsolicited input in <code>validate</code>. It does so by only accepting values for defined <code>property</code>s. This makes half-baked solutions like <code>strong_parameter</code> or <code>attr_accessible</code> obsolete.</p>
  </li>
</ul>

<p><span class="divider"></span></p>

<h3 id="reform-overview-architecture">Architecture</h3>
<p><!-- {reform-overview-architecture-toc} --></p>

<p>When experiencing Reform for the first time, it might seem to do a lot, too much: It decorates a model, parses the incoming data into some object graph, validates the data somehow and supports writing this data back to the model.</p>

<p>Actually, Reform is very simple and consists of several smaller objects. Each object has a very specific scope one does exactly one thing, where the actual form object orchestrates between those.</p>

<p><img class="mx-auto d-block" src="/vite/assets/reform-architecture.ccccd2f1.webp" /></p>

<p><strong>SETUP</strong> : When instantiating the form object with a model, it will read its properties‚Äô values from the model. Internally, this happens because a <a href="https://github.com/apotonick/reform/blob/777ea4730bec913582bae78fece78bbb76fb22c4/lib/reform/contract.rb#L6">form is simply a <code>Twin</code></a>. <a href="/2.1/docs/disposable.html#disposable-twin-api">Twins are light-weight decorator objects</a> from the Disposable gem.</p>

<p>For nested properties or collections, nested form objects will be created and wrap the respective contained models.</p>

<p><strong>DESERIALIZATION</strong> : In the <code>validate</code> method, the incoming hash or document is parsed. Each known field is assigned to the form object, each nested fragment will be mapped to a nested form. This process is known as <em>deserialization</em>.</p>

<p>The internal deserializer used for this is actually a <em>representer</em> from the Representable gem. It is <a href="https://github.com/apotonick/reform/blob/777ea4730bec913582bae78fece78bbb76fb22c4/lib/reform/form/validate.rb#L43">inferred automatically by Reform</a>, but theoretically, you could provide your own deserializer that goes through the document and then calls setters on the form.</p>

<p><strong>POPULATOR</strong> Nested fragments in the document often need to be mapped to existing or new models. This is where <em>populators</em> in Reform help to find the respective model(s), wrap them in a nested form object, and create a virtual object graph of the parsed data.</p>

<p>Populators are code snippets you define in the form class, but they are called from the deserializing representer and help parsing the document into a graph of objects.</p>

<p><strong>VIRTUAL OBJECT GRAPH</strong> : After deserialization, the form object graph represents the input. All data in <code>validate</code> has been written to the virtual graph, <strong>not to the model</strong>. Once this graph is setup, it can be validated.</p>

<p>The deserialization process is the pivotal part in Reform. Where simple validation engines only allow formal validations, Reform allows rich business validations such as <em>‚ÄúWhen user signed in, and it‚Äôs the first order, allow maximum 10 items in the shopping cart!‚Äù</em>.</p>

<p><strong>VALIDATION</strong> : For the actual validation, Reform uses existing solutions such as dry-validation or <code>ActiveModel::Validations</code>. It passes the data to the validation engine in the appropriate format - usually, this is a hash representing the virtual object graph and its data.</p>

<p>The validation is then completely up to the engine. Reform doesn‚Äôt know what is happening, it is only interested in the result and error messages. Both are exposed via the form object after validation has been finished.</p>

<p>The decoupled validation is why Reform provides multiple validation engines.</p>

<p><strong>SYNC/SAVE</strong></p>

<p>After the <code>validate</code> call, nothing has been written to the model(s), yet. This has to be explicitly invoked via <code>sync</code> or <code>save</code>. Now, Reform will use its basic twin functionality again and write the virtual data to the models using public setter methods. Again, Reform knows nothing about ORMs or model specifics.</p>

<p><span class="divider"></span></p>

<h2 id="reform-api">API</h2>
<p><!-- {reform-api-toc} --></p>

<p>This document discusses Reform‚Äôs declarative API to define form classes and the instance API that is used at run-time on the form object, e.g. to validate an incoming hash.</p>

<p>More specific documentation about options to be passed to the <code>property</code> and <code>collection</code> method are to be found in the <a href="#reform-options">options documentation</a>.</p>

<p><span class="divider"></span></p>

<h3 id="reform-api-overview">Overview</h3>
<p><!-- {reform-api-overview-toc} --></p>

<p>Forms have a ridiculously simple API with only a handful of public methods.</p>

<ol>
  <li><code>#initialize</code> always requires a model that the form represents.</li>
  <li><code>#validate(params)</code> updates the form‚Äôs fields with the input data (only the form, <em>not</em> the model) and then runs all validations. The return value is the boolean result of the validations.</li>
  <li><code>#errors</code> returns validation messages in a classic ActiveModel style.</li>
  <li><code>#sync</code> writes form data back to the model. This will only use setter methods on the model(s). It returns the underlying model.</li>
  <li><code>#save</code> (optional) will call <code>#save</code> on the model and nested models. Note that this implies a <code>#sync</code> call. It returns the result of <code>model.save</code>.</li>
  <li><code>#prepopulate!</code> (optional) will run pre-population hooks to ‚Äúfill out‚Äù your form before rendering.</li>
</ol>

<p>In addition to the main API, forms expose accessors to the defined properties. This is used for rendering or manual operations.</p>

<h4 id="disposable-api">Disposable API</h4>

<p>Every Reform form object inherits from <code>Disposable::Twin</code>, making every form a twin and giving each form the entire twin API such as.</p>

<ul>
  <li>Defaults using <code>:default</code>.</li>
  <li>Coercion using <code>:type</code> and <code>:nilify</code>.</li>
  <li>Nesting</li>
  <li>Composition</li>
  <li>Hash fields</li>
</ul>

<p>If you‚Äôre looking for a specific feature, make sure to check the <a href="/2.1/docs/disposable.html">Disposable documentation</a></p>

<p><span class="divider"></span></p>

<h3 id="reform-api-form-class">Form Class</h3>
<p><!-- {reform-api-form-class-toc} --></p>

<p>Forms are defined in classes. Often, these classes partially map to one or many model(s).</p>

<ul id="app/concepts/documentation/page/snippet/reform/api.md.erb-36" class="nav nav-tabs"> <li class="nav-item"> <a href="#" class="nav-link pink active active" data-toggle="tab" data-tag="#app-concepts-documentation-page-snippet-reform-api-md-erb-36-dry-validation"> dry-validation </a> </li><li class="nav-item"> <a href="#" class="nav-link pink " data-toggle="tab" data-tag="#app-concepts-documentation-page-snippet-reform-api-md-erb-36-ActiveModel"> ActiveModel </a> </li> </ul>
<div class="tab-content"> <div id="app-concepts-documentation-page-snippet-reform-api-md-erb-36-dry-validation" class="tab-pane fade show active"> 
<pre><code>class AlbumForm &lt; Reform::Form
  feature Reform::Form::Dry

  property :name

  validation do
    params do
      required(:name).filled
    end
  end
end
</code></pre>

 </div><div id="app-concepts-documentation-page-snippet-reform-api-md-erb-36-ActiveModel" class="tab-pane fade show "> 
<pre><code>class AlbumForm &lt; Reform::Form
  property :title

  validates :title, presence: true
end
</code></pre>

 </div> </div>

<p>Form fields are declared using <code>::property</code>.</p>

<p>Validations leverage the respective validation engine‚Äôs API, which be either <code>ActiveModel</code> or dry-validations.</p>

<p><span class="divider"></span></p>

<h3 id="reform-api-property">Property</h3>
<p><!-- {reform-api-property-toc} --></p>

<p>Use <code>property</code> to map scalar fields of your model to the form.</p>

<pre><code>class AlbumForm &lt; Reform::Form
  property :title
end
</code></pre>

<p>This will create accessors on the form and read the initial value from the model in <a href="#reform-api-setup">setup</a>.</p>

<pre><code>model = Album.new(title: "Greatest Hits")
form  = AlbumForm.new(model)

form.title #=&gt; "Greatest Hits"
</code></pre>

<h4 id="overriding-accessors">Overriding Accessors</h4>

<p>You‚Äôre free to override the form‚Äôs accessors for presentation or coercion.</p>

<pre><code>class AlbumForm &lt; Reform::Form
  property :title

  def title
    super.capitalize
  end
end
</code></pre>

<p>As always, use <code>super</code> for the original method.</p>

<p>This can also be used to provide a default value.</p>

<pre><code>def title
  super || "not available"
end
</code></pre>

<p><span class="divider"></span></p>

<h3 id="reform-api-collection">Collection</h3>
<p><!-- {reform-api-collection-toc} --></p>

<p>When mapping an array field of the model, use <code>collection</code>.</p>

<pre><code>class AlbumForm &lt; Reform::Form
  collection :song_titles
end
</code></pre>

<p>This will create accessors on the form and read the initial</p>

<pre><code>model = Album.new(song_titles: ["The Reflex", "Wild Boys"])

form = AlbumForm.new(model)
form.song_titles[0] #=&gt; "The Reflex"
</code></pre>

<p><span class="divider"></span></p>

<h3 id="reform-api-nesting">Nesting</h3>
<p><!-- {reform-api-nesting-toc} --></p>

<p>To create forms for nested objects, both <code>property</code> and <code>collection</code> accept a block for the nested form definition.</p>

<pre><code>class AlbumForm &lt; Reform::Form
  property :artist do
    property :name
  end

  collection :songs do
    property :title
  end
end
</code></pre>

<p>Nesting will simply create an anonymous, nested <code>Reform::Form</code> class for the nested property.</p>

<p>It‚Äôs often helpful with <code>has_many</code> or <code>belongs_to</code> associations.</p>

<pre><code>artist = Artist.new(name: "Duran Duran")
songs  = [Song.new(title: "The Reflex"), Song.new(title: "Wild Boys")]
model  = Album.new(artist: artist, songs: songs)
</code></pre>

<p>The accessors will now be nested.</p>

<pre><code>form   = AlbumForm.new(model)
form.artist.name #=&gt; "Duran Duran"
form.songs[0].title #=&gt; "The Reflex"
</code></pre>

<p>All API semantics explained here may be applied to both the top form and nested forms.</p>

<h4 id="nesting-explicit-form">Nesting: Explicit Form</h4>

<p>Sometimes you want to specify an explicit form constant rather than an inline form. Use the <code>form:</code> option here.</p>

<pre><code>property :song, form: SongForm
</code></pre>

<p>The nested <code>SongForm</code> refers to a stand-alone form class you have to provide.</p>

<p><span class="divider"></span></p>

<h3 id="reform-api-setup">Setup</h3>
<p><!-- {reform-api-setup-toc} --></p>

<p>Injecting Objects: safe args can be passed in constructor</p>

<p><span class="divider"></span></p>

<h3 id="reform-api-validate">Validate</h3>
<p><!-- {reform-api-validate-toc} --></p>

<p>You can define validation for every form property and for nested forms.</p>

<ul id="app/concepts/documentation/page/snippet/reform/api.md.erb-151" class="nav nav-tabs"> <li class="nav-item"> <a href="#" class="nav-link pink active active" data-toggle="tab" data-tag="#app-concepts-documentation-page-snippet-reform-api-md-erb-151-dry-validation"> dry-validation </a> </li><li class="nav-item"> <a href="#" class="nav-link pink " data-toggle="tab" data-tag="#app-concepts-documentation-page-snippet-reform-api-md-erb-151-ActiveModel"> ActiveModel </a> </li> </ul>
<div class="tab-content"> <div id="app-concepts-documentation-page-snippet-reform-api-md-erb-151-dry-validation" class="tab-pane fade show active"> 
<pre><code>class AlbumForm &lt; Reform::Form
  feature Reform::Form::Dry

  property :name

  validation do
    params { required(:name).filled }
  end

  property :artist do
    property :name

    validation do
      params { required(:name).filled }
    end
  end
end
</code></pre>

 </div><div id="app-concepts-documentation-page-snippet-reform-api-md-erb-151-ActiveModel" class="tab-pane fade show "> 
<pre><code>class AlbumForm &lt; Reform::Form
  property :title

  validates :title, presence: true

  property :artist do
    property :name

    validates :name, presence: true
  end
end
</code></pre>

 </div> </div>

<p>Validations will be run in <code>validate</code>.</p>

<pre><code>form.validate(
  {
    title: "Best Of",
    artist: {
      name: "Billy Joel"
    }
  }
) #=&gt; true
</code></pre>

<p>The returned value is the boolean result of the validations.</p>

<p>Reform will read all values it knows from the incoming hash, and it <strong>will ignore any unknown key/value pairs</strong>. This makes <code>strong_parameters</code> redundant. Accepted values will be written to the form using the public setter, e.g. <code>form.title = "Best Of"</code>.</p>

<p>After <code>validate</code>, the form‚Äôs values will be overwritten.</p>

<pre><code>form.artist.name #=&gt; "Billy Joel"
</code></pre>

<p>The model won‚Äôt be touched, its values are still the original ones.</p>

<pre><code>model.artist.name #=&gt; "Duran Duran"
</code></pre>

<h4 id="deserialization-and-populator">Deserialization and Populator</h4>

<p>Very often, you need to give Reform some information how to create or find nested objects when <code>validate</code>ing. This directive is called <em>populator</em> and <a href="#reform-populators">documented here</a>.</p>

<p><span class="divider"></span></p>

<h3 id="reform-api-errors">Errors</h3>
<p><!-- {reform-api-errors-toc} --></p>

<p>After <code>validate</code>, you can access validation errors via <code>errors</code>.</p>

<pre><code>form.errors #=&gt; {title: ["must be filled"]}
</code></pre>

<p>The returned <code>Errors</code> object exposes the following methods.</p>

<p><span class="divider"></span></p>

<h3 id="reform-api-save">Save</h3>
<p><!-- {reform-api-save-toc} --></p>

<p>Calling <code>#save</code> with a block will provide a nested hash of the form‚Äôs properties and values. This does <strong>not call <code>#save</code> on the models</strong> and allows you to implement the saving yourself.</p>

<p>The block parameter is a nested hash of the form input.</p>

<pre><code>@form.save do |hash|
  hash      #=&gt; {title: "Greatest Hits"}
  Album.create(hash)
end
</code></pre>

<p>You can always access the form‚Äôs model. This is helpful when you were using populators to set up objects when validating.</p>

<pre><code>@form.save do |hash|
  album = @form.model

  album.update_attributes(hash[:album])
end
</code></pre>

<p>Reform will wrap defined nested objects in their own forms. This happens automatically when instantiating the form.</p>

<pre><code>album.songs #=&gt; [&lt;Song name:"Run To The Hills"&gt;]

form = AlbumForm.new(album)
form.songs[0] #=&gt; &lt;SongForm model: &lt;Song name:"Run To The Hills"&gt;&gt;
form.songs[0].name #=&gt; "Run To The Hills"
</code></pre>

<h4 id="nested-saving">Nested Saving</h4>

<p><code>validate</code> will assign values to the nested forms. <code>sync</code> and <code>save</code> work analogue to the non-nested form, just in a recursive way.</p>

<p>The block form of <code>#save</code> would give you the following data.</p>

<pre><code>@form.save do |nested|
  nested #=&gt; {title:  "Greatest Hits",
         #    artist: {name: "Duran Duran"},
         #    songs: [{title: "Hungry Like The Wolf"},
         #            {title: "Last Chance On The Stairways"}]
         #   }
  end
</code></pre>

<p>The manual saving with block is not encouraged. You should rather check the Disposable docs to find out how to implement your manual tweak with the official API.</p>

<h4 id="turning-off-autosave">Turning Off Autosave</h4>

<p>You can assign Reform to <em>not</em> call <code>save</code> on a particular nested model (per default, it is called automatically on all nested models).</p>

<pre><code>class AlbumForm &lt; Reform::Form
  # ...

  collection :songs, save: false do
    # ..
  end
</code></pre>

<p>The <code>:save</code> options set to false won‚Äôt save models.</p>

<p><span class="divider"></span></p>

<h3 id="reform-api-inheritance">Inheritance</h3>
<p><!-- {reform-api-inheritance-toc} --></p>

<p>Forms can be derived from other forms and will inherit all properties and validations.</p>

<pre><code>class AlbumForm &lt; Reform::Form
  property :title

  collection :songs do
    property :title

    validates :title, presence: true
  end
end
</code></pre>

<p>Now, a simple inheritance can add fields.</p>

<pre><code>class CompilationForm &lt; AlbumForm
  property :composers do
    property :name
  end
end
</code></pre>

<p>This will <em>add</em> <code>composers</code> to the existing fields.</p>

<p>You can also partially override fields using <code>:inherit</code>.</p>

<pre><code>class CompilationForm &lt; AlbumForm
  property :songs, inherit: true do
    property :band_id
    validates :band_id, presence: true
  end
end
</code></pre>

<p>Using <code>inherit:</code> here will extend the existing <code>songs</code> form with the <code>band_id</code> field. Note that this simply uses <a href="https://github.com/apotonick/representable/#partly-overriding-properties">representable‚Äôs inheritance mechanism</a>.</p>

<p><span class="divider"></span></p>

<h3 id="reform-api-forms-in-modules">Forms In Modules</h3>
<p><!-- {reform-api-forms-in-modules-toc} --></p>

<p>To maximize reusability, you can also define forms in modules and include them in other modules or classes.</p>

<pre><code>module SongsForm
  include Reform::Form::Module

  collection :songs do
    property :title
    validates :title, presence: true
  end
end
</code></pre>

<p>This can now be included into a real form.</p>

<pre><code>class AlbumForm &lt; Reform::Form
  property :title

  include SongsForm
end
</code></pre>

<p>Note that you can also override properties <a href="#reform-api-inheritance">using inheritance</a> in Reform.</p>

<p>When using coercion, make sure the including form already contains the <code>Coercion</code> module.</p>

<p>If you want to provide accessors in the module, you have to define them in the <code>InstanceMethods</code> module.</p>

<pre><code>module SongForm
  include Reform::Form::Module

  property :title

  module InstanceMethods
    def title=(v)
      super(v.trim)
    end
  end
end
</code></pre>

<p>This is important so Reform can add your accessors after defining the default ones.</p>

<p><span class="divider"></span></p>

<h3 id="reform-api-dirty-tracker">Dirty Tracker</h3>
<p><!-- {reform-api-dirty-tracker-toc} --></p>

<p>Every form tracks changes in <code>#validate</code> and allows to check if a particular property value has changed using <code>#changed?</code>.</p>

<pre><code>form.title =&gt; "Button Up"

form.validate("title" =&gt; "Just Kiddin'")
form.changed?(:title) #=&gt; true
</code></pre>

<p>When including <code>Sync::SkipUnchanged</code>, the form won‚Äôt assign unchanged values anymore in <code>#sync</code>.</p>

<p><span class="divider"></span></p>

<h3 id="reform-api-deserialization">Deserialization</h3>
<p><!-- {reform-api-deserialization-toc} --></p>

<p>When invoking <code>validate</code>, Reform will parse the incoming hash and transform it into a graph of nested form objects that represent the input. This is called <em>deserialization</em>.</p>

<p>The deserialization is an important (and outstanding) feature of Reform and happens by using an internal <em>representer</em> that is automatically created for you. You can either configure that representer using the <a href="#reform-options-deserializer"><code>:deserializer</code> option</a> or provide code for deserialization yourself, bypassing any representer logic.</p>

<p>The <code>deserialize!</code> method is called before the actual validation of the graph is run and can be used for deserialization logic.</p>

<pre><code>  class AlbumForm &lt; Reform::Form
    property :title

    def deserialize!(document)
      hash = YAML.parse(document)

      self.title  = hash[:title]
      self.artist = Artist.new if hash[:artist]
    end
  end
</code></pre>

<p>We encourage you to use Reform‚Äôs deserialization using a representer, though. The representer is highly configurable and optimized for its job of parsing different data structures into Ruby objects.</p>

<p><span class="divider"></span></p>

<h3 id="reform-api-population">Population</h3>
<p><!-- {reform-api-population-toc} --></p>

<p>To hook into the <a href="#reform-api-deserialization">deserialization</a> process, the easiest way is using <a href="#reform-populators">the <code>:populator</code> option</a>. It allows manually creating, changing or adding nested objects to the form to represent the input.</p>

<p><span class="divider"></span></p>

<h3 id="reform-api-inflection">Inflection</h3>
<p><!-- {reform-api-inflection-toc} --></p>

<p>Properties can have arbitrary options that might become helpful, e.g. when rendering the form.</p>

<pre><code>property :title, type: String
</code></pre>

<p>Use <code>options_for</code> to access a property‚Äôs configuration.</p>

<pre><code>form.options_for(:title) # =&gt; {:readable=&gt;true, :coercion_type=&gt;String}
</code></pre>

<p>Note that Reform renames some options (e.g. <code>:type</code> internally becomes <code>:coercion_type</code>). Those names are private API and might be changed without deprecation.</p>

<p><span class="divider"></span></p>

<h2 id="reform-options">Options</h2>
<p><!-- {reform-options-toc} --></p>

<p>This document describes available options for Reform‚Äôs declarative API.</p>

<p><span class="divider"></span></p>

<h3 id="reform-options-disposable-api">Disposable API</h3>
<p><!-- {reform-options-disposable-api-toc} --></p>

<p>Every Reform form object inherits from <code>Disposable::Twin</code>, making every form a twin and giving each form the entire twin API such as.</p>

<ul>
  <li>Defaults using <code>:default</code>.</li>
  <li>Coercion using <code>:type</code> and <code>:nilify</code>.</li>
  <li>Nesting</li>
  <li>Composition</li>
  <li>Hash fields</li>
</ul>

<p>If you‚Äôre looking for a specific feature, make sure to check the <a href="/2.1/docs/disposable.html">Disposable documentation</a></p>

<p><span class="divider"></span></p>

<h3 id="reform-options-virtual-attributes">Virtual Attributes</h3>
<p><!-- {reform-options-virtual-attributes-toc} --></p>

<p>Virtual fields come in handy when there‚Äôs no direct mapping to a model attribute or when you plan on displaying but not processing a value.</p>

<h4 id="virtual">Virtual</h4>

<p>Often, fields like <code>password_confirmation</code> should neither be read from nor written back to the model. Reform comes with the <code>:virtual</code> option to handle that case.</p>

<pre><code>class PasswordForm &lt; Reform::Form
  property :password
  property :password_confirmation, virtual: true
</code></pre>

<p>Here, the model won‚Äôt be queried for a <code>password_confirmation</code> field when creating and rendering the form. When saving the form, the input value is not written to the decorated model. It is only readable in validations and when saving the form manually.</p>

<pre><code>form.validate("password" =&gt; "123", "password_confirmation" =&gt; "321")

form.password_confirmation #=&gt; "321"
</code></pre>

<p>The nested hash in the block-<code>#save</code> provides the same value.</p>

<pre><code>form.save do |nested|
  nested[:password_confirmation] #=&gt; "321"
</code></pre>

<h4 id="read-only">Read-Only</h4>

<p>Use <code>writeable: false</code> to display a value but skip processing it in <code>validate</code>.</p>

<pre><code>property :country, writeable: false
</code></pre>

<ol>
  <li>The form will invoke <code>model.country</code> to read the initial value.</li>
  <li>It will invoke <code>form.country=</code> in <code>validate</code>.</li>
  <li>The model‚Äôs setter <code>model.country</code> <strong>won‚Äôt</strong> be called in <code>sync</code>.</li>
</ol>

<p>Non-writeable values are still readable in the nested hash and through the form itself.</p>

<pre><code>form.save do |nested|
  nested[:country] #=&gt; "Australia"
</code></pre>

<h4 id="write-only">Write-Only</h4>

<p>Use <code>readable: false</code> to hide a value but still write it to the model.</p>

<pre><code>property :credit_card_number, readable: false
</code></pre>

<ol>
  <li>The form <strong>won‚Äôt</strong> invoke <code>model.credit_card_number</code> and will display an empty field.</li>
  <li>In <code>validate</code>, the form calls <code>form.credit_card_number=</code>.</li>
  <li>In <code>sync</code>, the setter <code>model.credit_card_number=</code> is called and the value written to the database.</li>
</ol>

<p><span class="divider"></span></p>

<h3 id="reform-options-access-protection">Access Protection</h3>
<p><!-- {reform-options-access-protection-toc} --></p>

<p>Use <code>parse: false</code> to protect the form setters from being called in <code>validate</code>.</p>

<pre><code>property :uuid, parse: false
</code></pre>

<ol>
  <li>This will call <code>model.uuid</code> to display the field via the form.</li>
  <li>In <code>validate</code>, the form‚Äôs setter <strong>won‚Äôt</strong> be called, leaving the value as it is.</li>
  <li>In <code>sync</code>, the setter <code>model.uuid</code> is called and restored to the original value.</li>
</ol>

<p>Note that the <code>:parse</code> option works by leveraging <a href="#reform-options-deserializer">:deserializer</a>.</p>

<p><span class="divider"></span></p>

<h3 id="reform-options-coercion">Coercion</h3>
<p><!-- {reform-options-coercion-toc} --></p>

<p>Incoming form data often needs conversion to a specific type, like timestamps. Reform uses <a href="http://dry-rb.org/gems/dry-types/">dry-types</a> for coercion. The DSL is seamlessly integrated with the <code>:type</code> option.</p>

<p>Be sure to add <code>dry-types</code> to your <code>Gemfile</code> when requiring coercion.</p>

<pre><code>gem "dry-types"
</code></pre>

<p>To use coercion, you need to include the <code>Coercion</code> module into your form class.</p>

<pre><code>require "reform/form/coercion"

class SongForm &lt; Reform::Form
  feature Coercion

  property :written_at, type: Types::Form::DateTime
end

form.validate("written_at" =&gt; "26 September")
</code></pre>

<p>Coercion only happens in <code>#validate</code>, <em>not</em> during construction.</p>

<pre><code>form.written_at #=&gt; &lt;DateTime "2014 September 26 00:00"&gt;
</code></pre>

<p>Available coercion types are <a href="http://dry-rb.org/gems/dry-types/built-in-types/">documented here</a>.</p>

<p><span class="divider"></span></p>

<h3 id="reform-options-manual-coercion">Manual Coercion</h3>
<p><!-- {reform-options-manual-coercion-toc} --></p>

<p>To filter values manually, you can override the setter in the form.</p>

<pre><code>class SongForm &lt; Reform::Form
  property :title

  def title=(value)
    super sanitize(value) # value is raw form input.
  end
end
</code></pre>

<p>Again, setters are only called in <code>validate</code>, <em>not</em> during construction.</p>

<p><span class="divider"></span></p>

<h3 id="reform-options-deserializer">Deserializer</h3>
<p><!-- {reform-options-deserializer-toc} --></p>

<p>A form object is just a twin. In <code>validate</code>, a representer is used to deserialize the incoming hash and populate the form twin graph. This means, you can use any representer you like and process data like JSON or XML, too.</p>

<h2 id="populator">Populator</h2>

<p>When deserializing the incoming input in <code>validate</code>, advanced logic might be necessary to find nested objects from the database, or populate the form with arbitrary nested objects.</p>

<p>The <code>:populator</code> and its short-hand <code>:populate_if_empty</code> options provide custom deserialization logic and are <a href="#reform-populators">documented here</a>.</p>

<p><span class="divider"></span></p>

<h3 id="reform-options-inheritance">Inheritance</h3>
<p><!-- {reform-options-inheritance-toc} --></p>

<p>Forms can be derived from other forms and will inherit all properties and validations.</p>

<pre><code>class AlbumForm &lt; Reform::Form
  property :title

  collection :songs do
    property :title

    validates :title, presence: true
  end
end
</code></pre>

<p>Now, a simple inheritance can add fields.</p>

<pre><code>class CompilationForm &lt; AlbumForm
  property :composers do
    property :name
  end
end
</code></pre>

<p>This will <em>add</em> <code>composers</code> to the existing fields.</p>

<p>You can also partially override fields using <code>:inherit</code>.</p>

<pre><code>class CompilationForm &lt; AlbumForm
  property :songs, inherit: true do
    property :band_id
    validates :band_id, presence: true
  end
end
</code></pre>

<p>Using <code>inherit:</code> here will extend the existing <code>songs</code> form with the <code>band_id</code> field. Note that this simply uses <a href="https://github.com/apotonick/representable/#partly-overriding-properties">representable‚Äôs inheritance mechanism</a>.</p>

<p><span class="divider"></span></p>

<h3 id="reform-options-skip_if">Skip_if</h3>
<p><!-- {reform-options-skip_if-toc} --></p>

<p>Use <code>:skip_if</code> to ignore properties in <code>#validate</code>.</p>

<pre><code>property :hit, skip_if: lambda { |fragment, *| fragment["title"].blank? }
</code></pre>

<p>This works for both properties and entire nested forms. The property will simply be ignored when deserializing, as if it had never been in the incoming hash/document.</p>

<p>For nested properties you can use <code>:skip_if: :all_blank</code> as a macro to ignore a nested form if all values are blank.</p>

<p>Note that this still runs validations for the property.</p>

<p><span class="divider"></span></p>

<h3 id="reform-options-multiparameter-dates">Multiparameter Dates</h3>
<p><!-- {reform-options-multiparameter-dates-toc} --></p>

<p>Composed multi-parameter dates as created by the Rails date helper are processed automatically when <code>multi_params: true</code> is set for the date property and the <code>MultiParameterAttributes</code> feature is included. As soon as Reform detects an incoming <code>release_date(i1)</code> or the like it is gonna be converted into a date.</p>

<pre><code>class AlbumForm &lt; Reform::Form
  feature Reform::Form::ActiveModel::FormBuilderMethods
  feature Reform::Form::MultiParameterAttributes

  collection :songs do
    feature Reform::Form::ActiveModel::FormBuilderMethods
    property :title
    property :release_date, :multi_params =&gt; true
    validates :title, :presence =&gt; true
  end
end
</code></pre>

<p>Note that the date will be <code>nil</code> when one of the components (year/month/day) is missing.</p>

<p><span class="divider"></span></p>

<h2 id="reform-data-types">Data Types</h2>
<p><!-- {reform-data-types-toc} --></p>

<p><span class="divider"></span></p>

<h3 id="reform-data-types-composition">Composition</h3>
<p><!-- {reform-data-types-composition-toc} --></p>

<p>Reform allows to map multiple models to one form. The <a href="https://github.com/apotonick/disposable#composition">complete documentation</a> is here, however, this is how it works.</p>

<pre><code>class AlbumForm &lt; Reform::Form
  include Composition

  property :id,    on: :album
  property :title, on: :album
  property :songs, on: :cd
  property :cd_id, on: :cd, from: :id

  validates :title, presence: true
end
</code></pre>

<p>Note that Reform now needs to know about the source of properties. You can configure that by using the <code>on:</code> option.</p>

<h4 id="composition-setup">Composition: Setup</h4>

<p>When initializing a composition, you have to pass a hash that contains the composees.</p>

<pre><code>form = AlbumForm.new(album: album, cd: CD.find(1))
</code></pre>

<p>The form now hides the fact that it represents more than one model. Accessors for properties are defined directly on the form.</p>

<pre><code>form.title #=&gt; "Greatest Hits"
</code></pre>

<h4 id="composition-savesync">Composition: Save/Sync</h4>

<p>On a composition form, <code>sync</code> will write data back to the composee models. <code>save</code> will additionally call <code>save</code> on all composee models.</p>

<p>When using `#save‚Äô with a block, here‚Äôs what the block parameters look like.</p>

<pre><code>form.save do |nested|
  nested #=&gt;
    {
      album:  {
        id:    9,
        title: "Rio"
      },
      cd:     {
        songs: [],
        id: 1
      }
    }
end
</code></pre>

<p>The hash is now keyed by composee name with the private property names.</p>

<h4 id="composition-activemodel">Composition: ActiveModel</h4>

<p>With ActiveModel, the form needs to have a main object configured. This is where ActiveModel-methods like <code>#persisted?</code> or ‚Äò#id‚Äô are delegated to. Use <code>::model</code> to define the main object.</p>

<pre><code>class AlbumForm &lt; Reform::Form
  include Composition

  property :id,    on: :album
  property :title, on: :album
  property :songs, on: :cd
  property :cd_id, on: :cd, from: :id

  model :album # only needed in ActiveModel context.

  validates :title, presence: true
end
</code></pre>

<p><span class="divider"></span></p>

<h3 id="reform-data-types-hash-fields">Hash Fields</h3>
<p><!-- {reform-data-types-hash-fields-toc} --></p>

<p>Reform can also handle deeply nested hash fields from serialized hash columns. This is <a href="https://github.com/apotonick/disposable#struct">documented here</a>.</p>

<p><span class="divider"></span></p>

<h2 id="reform-populators">Populators</h2>
<p><!-- {reform-populators-toc} --></p>

<p>Reform has two completely separated modes for form setup. One when rendering the form and one when populating the form in <code>validate</code>.</p>

<p><code>Prepopulating</code> is helpful when you want to fill out fields (aka. <em>defaults</em>) or add nested forms before rendering. <a href="#reform-populators">Populating</a> is invoked in <code>validate</code> and will add nested forms depending on the incoming hash.</p>

<p>This page discusses the latter.</p>

<p>Populators, matching by IDs, deleting items, and much more, is discussed in detail in the chapters <em>Nested Forms</em> and <em>Mastering Forms</em> of the <a href="/books/trailblazer.html">Trailblazer book</a>.</p>

<p><span class="divider"></span></p>

<h3 id="reform-populators-populators-the-problem">Populators: The Problem</h3>
<p><!-- {reform-populators-populators-the-problem-toc} --></p>

<p>Populators in Reform are only involved when validating the form.</p>

<p>In <code>#validate</code>, you pass a nested hash to the form. Reform per default will try to match nested hashes to nested forms. But often the incoming hash and the existing object graph are not matching 1-to-1. That‚Äôs where populators enter the stage.</p>

<p>Let‚Äôs say you have the following model.</p>

<pre><code>album = Album.new(songs: [])
</code></pre>

<p>The album contains an empty songs collection.</p>

<p>Your form looks like this.</p>

<pre><code>class AlbumForm &lt; Reform::Form
  collection :songs do
    property :name
  end
end
</code></pre>

<p>Here‚Äôs how you‚Äôd typically validate an incoming hash.</p>

<pre><code>form = AlbumForm.new(album)
form.validate({songs: [{name: "Midnight Rendezvous"}]})
</code></pre>

<p>Reform will now try to deserialize every nested <code>songs</code> item to a nested form. So, in pseudo-code, this happens in <code>validate</code>.</p>

<pre><code>form.songs[0].validate({name: "Midnight Rendezvous"})
</code></pre>

<p>Intuitively, you will expect Reform to create an additional song with the name ‚ÄúMidnight Rendezvous‚Äù.  However, this is not how it works and will crash, since <code>songs[0]</code> doesn‚Äôt exist. There is no nested form to represent that fragment, yet, since the original <code>songs</code> collection in the model was empty!</p>

<p>Reform per design makes no assumptions about how to create nested models. You have to tell it what to do in this <em>out-of-sync</em> case.</p>

<p>You need to configure a populator to engage Reform in the proper deserialization.</p>

<p><span class="divider"></span></p>

<h3 id="reform-populators-declarative-dsl">Declarative DSL</h3>
<p><!-- {reform-populators-declarative-dsl-toc} --></p>

<p>You have to declare a populator when the form has to deserialize nested input. This can happen via <code>:populate_if_empty</code> or the generic <code>:populator</code> option.</p>

<p>Both options accept either a proc, a method symbol, or a <code>Callable</code> instance.</p>

<p>The proc is the most popular version.</p>

<pre><code>property :artist, populator: -&gt;(options) { .. } # proc
</code></pre>

<p>However, note that you can also provide a proc constant (here <code>ArtistPopulator</code>).</p>

<pre><code>ArtistPopulator = -&gt;(options) { .. }

property :artist, populator: ArtistPopulator
</code></pre>

<p>You can also use a method defined on the same level as the populator property (here <code>#artist!</code>).</p>

<pre><code>property :artist, populator: :artist!

def artist!(options)
end
</code></pre>

<p>Or, a <code>Uber::Callable</code>-marked object.</p>

<pre><code>class ArtistPopulator
  def call(options)
  end
end

property :artist, populator: ArtistPopulator.new
</code></pre>

<p>This is especially helpful when the populator gets complex and could benefit from inheritance/mixins.</p>

<h4 id="populator-invocation">Populator Invocation</h4>

<p>Regardless of the populator type, keep in mind that a populator is only called if an incoming fragment for that property is present.</p>

<pre><code>form.validate({songs: [{name: "Midnight Rendezvous"}]}) # songs present.
</code></pre>

<p>Running with our example, the following validation will <em>not</em> trigger any populator.</p>

<pre><code>form.validate({})          # empty.
form.validate({songs: []}) # not empty, but no items!
</code></pre>

<p><span class="divider"></span></p>

<h3 id="reform-populators-populate_if_empty">Populate_if_empty</h3>
<p><!-- {reform-populators-populate_if_empty-toc} --></p>

<p>To let Reform create a new model wrapped by a nested form for you use <code>:populate_if_empty</code>. That‚Äôs the easiest form of population.</p>

<pre><code>class AlbumForm &lt; Reform::Form
  collection :songs, populate_if_empty: Song do
    property :name
  end
end
</code></pre>

<p>When traversing the incoming <code>songs:</code> collection, fragments without a counterpart nested form will be created for you with a new <code>Song</code> object.</p>

<pre><code>form.validate({songs: [{name: "Midnight Rendezvous"}]})
</code></pre>

<p>Reform now creates a <code>Song</code> instance and nests it in the form since it couldn‚Äôt find <code>form.songs[0]</code>.</p>

<p>Note that the matching from fragment to form works by index, any additional matching heuristic has to be implemented manually.</p>

<p><span class="divider"></span></p>

<h3 id="reform-populators-populate_if_empty-custom">Populate_if_empty: Custom</h3>
<p><!-- {reform-populators-populate_if_empty-custom-toc} --></p>

<p>You can also create the object yourself and leverage data from the traversed fragment, for instance, to try to find a <code>Song</code> object by name, first, before creating a new one.</p>

<pre><code>class AlbumForm &lt; Reform::Form
  collection :songs,
    populate_if_empty: -&gt;(fragment:, **) do
      Song.find_by(name: fragment["name"]) or Song.new
    end
</code></pre>

<p>The result from this block will be automatically added to the form graph.</p>

<p>You can also provide an instance method on the respective form.</p>

<pre><code>class AlbumForm &lt; Reform::Form
  collection :songs, populate_if_empty: :populate_songs! do
    property :name
  end

  def populate_songs!(fragment:, **)
    Song.find_by(name: fragment["name"]) or Song.new
  end
</code></pre>

<p><span class="divider"></span></p>

<h3 id="reform-populators-populate_if_empty-arguments">Populate_if_empty: Arguments</h3>
<p><!-- {reform-populators-populate_if_empty-arguments-toc} --></p>

<p>The only argument passed to <code>:populate_if_empty</code> block or method is an options hash. It contains currently traversed <code>:fragment</code>, the <code>:index</code> (collections, only) and several more options.</p>

<p>The result of the block will be automatically assigned to the form for you. Note that you can‚Äôt use the twin API in here, for example to reorder a collection. If you want more flexibility, use <code>:populator</code>.</p>

<p><span class="divider"></span></p>

<h3 id="reform-populators-populator">Populator</h3>
<p><!-- {reform-populators-populator-toc} --></p>

<p>While the <code>:populate_if_empty</code> option is only called when no matching form was found for the input, the <code>:populator</code> option is always invoked and gives you maximum flexibility for population. They‚Äôre exclusive, you can only use one of the two.</p>

<p>Again, note that populators won‚Äôt be invoked if there‚Äôs no incoming fragment(s) for the populator‚Äôs property.</p>

<p><span class="divider"></span></p>

<h3 id="reform-populators-populator-collections">Populator: Collections</h3>
<p><!-- {reform-populators-populator-collections-toc} --></p>

<p>A <code>:populator</code> for collections is executed for every collection fragment in the incoming hash.</p>

<pre><code>form.validate({
  songs: [
    {name: "Midnight Rendezvous"},
    {name: "Information Error"}
  ]
})
</code></pre>

<p>The following <code>:populator</code> will be executed twice.</p>

<pre><code>class AlbumForm &lt; Reform::Form
  collection :songs,
    populator: -&gt; (collection:, index:, **) do
      if item = collection[index]
        item
      else
        collection.insert(index, Song.new)
      end
    end
</code></pre>

<p>This populator checks if a nested form is already existing by using <code>collection[index]</code>. While the <code>index</code> keyword argument represents where we are in the incoming array traversal, <code>collection</code> is a convenience from Reform, and is identical to <code>self.songs</code>.</p>

<p>Note that you manually have to check whether or not a nested form is already available (by index or ID) and then need to add it using the form API writers.</p>

<p>BTW, the <code>:populator</code> option accepts blocks and instance method names.</p>

<p><span class="divider"></span></p>

<h3 id="reform-populators-populator-return-value">Populator: Return Value</h3>
<p><!-- {reform-populators-populator-return-value-toc} --></p>

<p>It is very important that each <code>:populator</code> invocation returns the <em>form</em> that represents the fragment, and not the model. Otherwise, deserialization will fail.</p>

<p>Here are some return values.</p>

<pre><code>populator: -&gt; (collection:, index:, **) do
  songs[index]              # works, unless nil
  collection[index]         # identical to above
  songs.insert(1, Song.new) # works, returns form
  songs.append(Song.new)    # works, returns form
  Song.new                  # crashes, that's no form
  Song.find(1)              # crashes, that's no form
</code></pre>

<p>Always make sure you return a form object, and not a model.</p>

<p><span class="divider"></span></p>

<h3 id="reform-populators-populator-avoiding-index">Populator: Avoiding Index</h3>
<p><!-- {reform-populators-populator-avoiding-index-toc} --></p>

<p>In many ORMs, the order of has_many associations doesn‚Äôt matter, and you don‚Äôt need to use the <code>index</code> for appending.</p>

<pre><code>collection :songs,
  populator: -&gt; (collection:, index:, **) do
    if item = collection[index]
      item
    else
      collection.append(Song.new)
    end
  end
</code></pre>

<p>Often, it is better to <a href="#reform-populators-populator-match-by-id">match by ID</a> instead of indexes.</p>

<p><span class="divider"></span></p>

<h3 id="reform-populators-populator-single-property">Populator: Single Property</h3>
<p><!-- {reform-populators-populator-single-property-toc} --></p>

<p>Naturally, a <code>:populator</code> for a single property is only called once.</p>

<pre><code>class AlbumForm &lt; Reform::Form
  property :composer,
    populator: -&gt; (model:, **) do
      model || self.composer= Artist.new
    end
</code></pre>

<p>A single populator works identical to a collection one, except for the <code>model</code> argument, which is equally to <code>self.composer</code>.</p>

<p><span class="divider"></span></p>

<h3 id="reform-populators-populator-match-by-id">Populator: Match by ID</h3>
<p><!-- {reform-populators-populator-match-by-id-toc} --></p>

<p>[This is described in chapter <em>Authentication</em> in the Trailblazer book.]</p>

<p>Per default, Reform matches incoming hash fragments and nested forms by their order. It doesn‚Äôt know anything about IDs, UUIDs or other persistence mechanics.</p>

<p>You can use <code>:populator</code> to write your own matching for IDs.</p>

<pre><code>collection :songs,
  populator: -&gt;(fragment:, **) {
    # find out if incoming song is already added.
    item = songs.find { |song| song.id == fragment["id"].to_i }

    item ? item : songs.append(Song.new)
  }
</code></pre>

<p>Note that a <code>:populator</code> requires you to add/replace/update/delete the model yourself. You have access to the form API here since the block is executed in form instance context.</p>

<p>Again, it is important to <a href="#reform-populators-populator-return-value">return the new form</a> and not the model.</p>

<p>This naturally works for single properties, too.</p>

<pre><code>property :artist,
  populator: -&gt;(fragment:, **) {
    artist ? artist : self.artist = Artist.find_by(id: fragment["id"])
  }
</code></pre>

<p><span class="divider"></span></p>

<h3 id="reform-populators-delete">Delete</h3>
<p><!-- {reform-populators-delete-toc} --></p>

<p>Populators can not only create, but also destroy. Let‚Äôs say the following input is passed in.</p>

<pre><code>form.validate({
  songs: [
    {"name"=&gt;"Midnight Rendezvous", "id"=&gt;2, "delete"=&gt;"1"},
    {"name"=&gt;"Information Error"}
  ]
})
</code></pre>

<p>You can implement your own deletion.</p>

<pre><code>collection :songs,
  populator: -&gt;(fragment:, **) {
    # find out if incoming song is already added.
    item = songs.find { |song| song.id.to_s == fragment["id"].to_s }

    if fragment["delete"] == "1"
      songs.delete(item)
      return skip!
    end

    item ? item : songs.append(Song.new)
  }
</code></pre>

<p>You can delete items from the graph using <code>delete</code>. To avoid this fragment being further deserialized, use <code>return skip!</code> to stop processing for this fragment.</p>

<p>Note that you can also use the twin‚Äôs <code>Collection</code> API for finding nested twins by any field.</p>

<pre><code>populator: -&gt;(fragment:, **) {
  item = songs.find_by(id: fragment["id"])
</code></pre>

<p><span class="divider"></span></p>

<h3 id="reform-populators-skip">Skip</h3>
<p><!-- {reform-populators-skip-toc} --></p>

<p>Since Reform 2.1, populators can skip processing of a fragment by returning <code>skip!</code>. This will ignore this fragment as if it wasn‚Äôt present in the incoming hash.</p>

<pre><code>collection :songs,
  populator: -&gt;(fragment:, **) do
    return skip! if fragment["id"]
    # ..
  end
</code></pre>

<p>To skip from a <code>Uber::Callable</code>-marked object, return <code>Representable::Pipeline::Stop</code></p>

<pre><code>class SongsPopulator
  def call(options)
    return Representable::Pipeline::Stop if fragment["id"]
    # ...
  end
end

collection :songs, populator: SongsPopulator.new
</code></pre>

<p>This won‚Äôt process items that have an <code>"id"</code> field in their corresponding fragment.</p>

<p><span class="divider"></span></p>

<h3 id="reform-populators-uninitialized-collections">Uninitialized Collections</h3>
<p><!-- {reform-populators-uninitialized-collections-toc} --></p>

<p>A problem with populators can be an uninitialized <code>collection</code> property.</p>

<pre><code>class AlbumForm &lt; Reform::Form
  collection :songs, populate_if_empty: Song do
    property :title
  end
end

album = Album.new
form  = AlbumForm.new(album)

album.songs #=&gt; nil
form.songs  #=&gt; nil

form.validate(songs: [{title: "Friday"}])
#=&gt; NoMethodError: undefined method `original' for nil:NilClass
</code></pre>

<p>What happens is as follows.</p>

<ol>
  <li>In <code>validate</code>, the form can‚Äôt find a corresponding nested songs form and calls the <code>populate_if_empty</code> code.</li>
  <li>The populator will create a <code>Song</code> model and assign it to the parent form via <code>form.songs &lt;&lt; Song.new</code>.</li>
  <li>This crashes, as <code>form.songs</code> is <code>nil</code>.</li>
</ol>

<p>The solution is to initialize your object correctly. This is per design. It is your job to do that as Reform/Disposable is likely to do it wrong.</p>

<pre><code>album = Album.new(songs: [])
form  = AlbumForm.new(album)
</code></pre>

<p>With ORMs, the setup happens automatically, this only appears when using <code>Struct</code> or other POROs as models.</p>

<p><span class="divider"></span></p>

<h2 id="reform-prepopulating">Prepopulating</h2>
<p><!-- {reform-prepopulating-toc} --></p>

<p>Reform has two completely separated modes for form setup. One when rendering the form and one when populating the form in <code>validate</code>.</p>

<p><a href="#reform-prepopulating">Prepopulating</a> is helpful when you want to fill out fields (aka. <em>defaults</em>) or add nested forms before rendering.</p>

<p><a href="#reform-populators">Populating</a> is invoked in <code>validate</code> and will add nested forms depending on the incoming hash.</p>

<p>This page explains prepopulation used to prepare the form for rendering.</p>

<p><span class="divider"></span></p>

<h3 id="reform-prepopulating-configuration">Configuration</h3>
<p><!-- {reform-prepopulating-configuration-toc} --></p>

<p>You can use the <code>:prepopulator</code> option on every property or collection.</p>

<pre><code>class AlbumForm &lt; Reform::Form
  property :artist, prepopulator: -&gt;(options) { self.artist = Artist.new } do
    property :name
  end
</code></pre>

<p>The option value can be a lambda or an instance method name.</p>

<p>In the block/method, you have access to the form API and can invoke any kind of logic to prepopulate your form. Note you need to assign models for nested form using their writers.</p>

<p><span class="divider"></span></p>

<h3 id="reform-prepopulating-invocation">Invocation</h3>
<p><!-- {reform-prepopulating-invocation-toc} --></p>

<p>Prepopulation must be invoked manually.</p>

<pre><code>form = AlbumForm.new(Album.new)
form.artist #=&gt; nil

form.prepopulate!

form.artist #=&gt; &lt;nested ArtistForm @model=&lt;Artist ..&gt;&gt;
</code></pre>

<p>This explicit call must happen before the form gets rendered. For instance, in Trailblazer, this happens in the controller action.</p>

<p><span class="divider"></span></p>

<h3 id="reform-prepopulating-prepopulate-is-not-populate">Prepopulate is not Populate</h3>
<p><!-- {reform-prepopulating-prepopulate-is-not-populate-toc} --></p>

<p><code>:populator</code> and <code>:populate_if_empty</code> will be run automatically in <code>validate</code>. Do not call <code>prepopulate!</code> before <code>validate</code> if you use the populator options. This will usually result in ‚Äúmore‚Äù nested forms being added as you wanted (unless you know what you‚Äôre doing).</p>

<p>Prepopulators are a concept designed to <strong>prepare a form for rendering</strong>, whereas populators are meant to <strong>set up the form in <code>validate</code></strong> when the input hash is deserialized.</p>

<p>This is explained in the <em>Nested Forms</em> chapter of the Trailblazer book. Please read it first if you have trouble understanding this, and then open an issue.</p>

<p><span class="divider"></span></p>

<h3 id="reform-prepopulating-options">Options</h3>
<p><!-- {reform-prepopulating-options-toc} --></p>

<p>Options may be passed. They will be available in the <code>:prepopulator</code> block.</p>

<pre><code>class AlbumForm &lt; Reform::Form
  property :title, prepopulator: -&gt;(options) { self.title = options[:def_title] }
end
</code></pre>

<p>You can then pass arbitrary arguments to <code>prepopulate!</code>.</p>

<pre><code>form.title #=&gt; nil

form.prepopulate!(def_title: "Roxanne")

form.title #=&gt; "Roxanne"
</code></pre>

<p>The arguments passed to the <code>prepopulate!</code> call will be passed straight to the block/method.</p>

<p>This call will be applied to the entire nested form graph recursively <em>after</em> the currently traversed form‚Äôs prepopulators were run.</p>

<p><span class="divider"></span></p>

<h3 id="reform-prepopulating-execution">Execution</h3>
<p><!-- {reform-prepopulating-execution-toc} --></p>

<p>The blocks are run in form instance context, meaning you have access to all possible data you might need. With a symbol, the same-named method will be called on the form instance, too.</p>

<p>Note that you have to assign the pre-populated values to the form by using setters. In turn, the form will automatically create nested forms for you.</p>

<p>This is especially cool when populating collections.</p>

<pre><code>property :songs,
  prepopulator: -&gt;(*) { self.songs &lt;&lt; Song.new if songs.size &lt; 3 } do
</code></pre>

<p>This will always add an empty song form to the nested <code>songs</code> collection until three songs are attached. You can use the <code>Twin::Collection</code> API when adding, changing or deleting items from a collection.</p>

<p>Note that when calling <code>#prepopulate!</code>, your <code>:prepopulate</code> code for all existing forms in the graph will <em>be executed</em> . It is up to you to add checks if you need that.</p>

<p><span class="divider"></span></p>

<h3 id="reform-prepopulating-overriding">Overriding</h3>
<p><!-- {reform-prepopulating-overriding-toc} --></p>

<p>You don‚Äôt have to use the <code>:prepopulator</code> option. Instead, you can simply override <code>#prepopulate!</code> itself.</p>

<pre><code>class AlbumForm &lt; Reform::Form
  def prepopulate!(options)
    self.title = "Roxanne"
    self.artist = Artist.new(name: "The Police")
  end
</code></pre>

<p><span class="divider"></span></p>

<h3 id="reform-prepopulating-defaults">Defaults</h3>
<p><!-- {reform-prepopulating-defaults-toc} --></p>

<p>There‚Äôs different alternatives for setting a default value for a formerly empty field.</p>

<ol>
  <li>Use <code>:prepopulator</code> as <a href="#reform-prepopulating-configuration">described here</a>. Don‚Äôt forget to call <code>prepopulate!</code> before rendering the form.</li>
  <li>
    <p>Override the reader of the property. This is not recommended as you might screw things up. Remember that the property reader is called for presentation (in the form builder) and for validation in <code>#validate</code>.</p>

    <pre><code>property :title

def title
  super or "Unnamed"
end
</code></pre>
  </li>
</ol>

<p><span class="divider"></span></p>

<h2 id="reform-validation">Validation</h2>
<p><!-- {reform-validation-toc} --></p>

<p>Validation in Reform happens in the <code>validate</code> method, and only there.</p>

<p>Reform will deserialize the fragments and their values to the form and its nested subforms, and once this is done, run validations.</p>

<p>It returns the result boolean, and provide potential errors via <code>errors</code>.</p>

<p><span class="divider"></span></p>

<h3 id="reform-validation-validation-engine">Validation Engine</h3>
<p><!-- {reform-validation-validation-engine-toc} --></p>

<p>Since Reform 2.0, you can pick your validation engine. This can either be <code>ActiveModel::Validations</code> or <code>dry-validation</code>. The validation examples included on this page are using <code>dry-validation</code>.</p>

<div class="callout secondary">
  <p>
    Reform 2.2 drops <code>ActiveModel</code>-support. You can still use it (and it will work!), but we won't maintain it actively, anymore. In other words, <code>ActiveModel::Validations</code> and Reform should be working until at least Reform 4.0.
  </p>
</div>

<p>Note that you are not limited to one validation engine. When switching from <code>ActiveModel::Validation</code> to <code>dry-validation</code>, you should set the first as the default validation engine.</p>

<ul id="app/concepts/documentation/page/snippet/reform/validation.md.erb-21" class="nav nav-tabs"> <li class="nav-item"> <a href="#" class="nav-link pink active active" data-toggle="tab" data-tag="#app-concepts-documentation-page-snippet-reform-validation-md-erb-21-Rails"> Rails </a> </li><li class="nav-item"> <a href="#" class="nav-link pink " data-toggle="tab" data-tag="#app-concepts-documentation-page-snippet-reform-validation-md-erb-21-Ruby"> Ruby </a> </li> </ul>
<div class="tab-content"> <div id="app-concepts-documentation-page-snippet-reform-validation-md-erb-21-Rails" class="tab-pane fade show active"> 
<p>The configuration assumes you have <code>reform-rails</code> installed.</p>

<pre><code>config.reform.validations = :active_model
</code></pre>

 </div><div id="app-concepts-documentation-page-snippet-reform-validation-md-erb-21-Ruby" class="tab-pane fade show "> 
<p>In a Ruby environment, you‚Äôd usually monkey-patch the <code>Form</code> class.</p>

<pre><code>  Reform::Form.send(:include, Reform::Form::ActiveModel::Validations)
</code></pre>

 </div> </div>

<p>In forms you‚Äôre upgrading to dry-validation, you can include the validation module explicitly.</p>

<pre><code>require 'reform/form/dry'
</code></pre>

<pre><code>class AlbumForm &lt; Reform::Form
  feature Reform::Form::Dry

  property :name

  validation do
    params do
      required(:name).filled
    end
  end
end
</code></pre>

<p>This replaces the ActiveModel backend with dry for this specific form class, only.</p>

<p><span class="divider"></span></p>

<h3 id="reform-validation-validation-groups">Validation Groups</h3>
<p><!-- {reform-validation-validation-groups-toc} --></p>

<p>Grouping validations enables you to run them conditionally, or in a specific order. You can use <code>:if</code> to specify what group had to be successful for it to be validated.</p>

<pre><code>validation name: :artist, if: :default do
  params { required(:artist).filled }
end

validation name: :famous, after: :default do
  params { optional(:artist) }

  rule(:artist) do
    if value
      key.failure('only famous artist') unless value =~ /famous/
    end
  end
end
</code></pre>

<p>This will only check for the <code>artist</code> presence as well only if the <code>:default</code> group was valid.
Chaining groups works via the <code>:after</code> option. This will run the group regardless of the former result. Note that it still can be combined with <code>:if</code>.</p>

<p>At any time you can extend an existing group using <code>:inherit</code> (this feature is not compatible with dry-validation 1.x, to avoid any hacky solution we are waiting dry-v authors to implement it from their end first).</p>

<pre><code>validation :email, inherit: true do
  params { required(:email).filled }
end
</code></pre>

<p>This appends validations to the existing <code>:email</code> group.</p>

<p><span class="divider"></span></p>

<h3 id="reform-validation-dry-validation">Dry-validation</h3>
<p><!-- {reform-validation-dry-validation-toc} --></p>

<p>Dry-validation is the preferred backend for defining and executing validations.</p>

<p>The purest form of defining validations with this backend is by using a <a href="#reform-validation-validation-groups">validation group</a>. A group provides the exact same API as a <code>Dry::Validation::Schema</code>. You can learn all the details on the <a href="https://github.com/dryrb/dry-validation">gem‚Äôs website</a>.</p>

<pre><code>class AlbumForm &lt; Reform::Form
  feature Reform::Form::Dry

  property :name

  validation name: :default do
    option :form

    params do
      required(:name).filled
    end

    rule(:name) do
      key.failure('must be unique') if Album.where.not(id: form.model.id).where(name: value).exists?
    end
  end
end
</code></pre>

<p>The validation block is what dry-v calls contract which can contains <code>params</code>, <code>rule</code> and <code>config</code>.</p>

<p><code>params</code> is a dry-v <code>Schema</code> and will contain all the basic built in predicates, instead in the <code>rule</code> block is where is possible to implement custom predicates.
Remember that the <code>rule</code> block will not be executed in case the relative schema does not pass the validations. The <code>form</code> object is always passed into the <code>validation</code> block and it can be exposed using <code>option :form</code>.</p>

<p>Make sure to read the <a href="http://dry-rb.org/gems/dry-validation">documentation</a> for dry-validation, as it contains some very powerful concepts like high-level rules that give you much richer validation semantics as compared to AM:V.</p>

<h4 id="dry-error-messages">Dry: Error Messages</h4>

<p>You need to provide custom error messages via dry-validation mechanics.</p>

<pre><code>validation :default do
  config.messages.load_paths &lt;&lt; 'config/error_messages.yml'
end
</code></pre>

<p>This is automatically configured to use the I18n gem if it‚Äôs available, which is true in a Rails environment.</p>

<p>A simple error messages file might look as follows.</p>

<pre><code>en:
  errors:
    same_password?: "passwords not equal"
</code></pre>

<p><span class="divider"></span></p>

<h3 id="reform-validation-activemodel">ActiveModel</h3>
<p><!-- {reform-validation-activemodel-toc} --></p>

<p>In Rails environments, the AM support will be automatically loaded.</p>

<p>In other frameworks, you need to include <code>Reform::Form::ActiveModel::Validations</code> either into a particular form class, or simply into <code>Reform::Form</code> and make it available for all subclasses.</p>

<pre><code>require "reform/form/active_model/validations"

Reform::Form.class_eval do
  feature Reform::Form::ActiveModel::Validations
end
</code></pre>

<h4 id="uniqueness-validation">Uniqueness Validation</h4>

<p>Both ActiveRecord and Mongoid modules will support ‚Äúnative‚Äù uniqueness support where the validation is basically delegated to the ‚Äúreal‚Äù model class. This happens when you use <code>validates_uniqueness_of</code> and will respect options like <code>:scope</code>, etc.</p>

<pre><code>class SongForm &lt; Reform::Form
  include Reform::Form::ActiveRecord
  model :song

  property :title
  validates_uniqueness_of :title, scope: [:album_id, :artist_id]
end
</code></pre>

<p>Be warned, though, that those validators write to the model instance. Even though this <em>usually</em> is not persisted, this will mess up your application state, as in case of an invalid validation your model will have unexpected values.</p>

<p>This is not Reform‚Äôs fault but a design flaw in ActiveRecord‚Äôs validators.</p>

<h4 id="unique-validation">Unique Validation</h4>

<p>You‚Äôre encouraged to use Reform‚Äôs non-writing <code>unique: true</code> validation, though.</p>

<pre><code>require "reform/form/validation/unique_validator"

class SongForm &lt; Reform::Form
  property :title
  validates :title, unique: true
end
</code></pre>

<p>This will only validate the uniqueness of <code>title</code>.</p>

<p>For uniqueness validation of multiple fields, use the <code>:scope</code> option.</p>

<pre><code class="language-ruby">validates :user_id, unique: { scope: [:user_id, :song_id] }
</code></pre>

<p>Feel free to <a href="https://github.com/trailblazer/reform-rails/blob/master/lib/reform/form/validation/unique_validator.rb">help us here</a>!</p>

<h4 id="confirm-validation">Confirm Validation</h4>

<p>Likewise, the <code>confirm: true</code> validation from ActiveResource is considered dangerous and should not be used. It also writes to the model and probably changes application state.</p>

<p>Instead, use your own virtual fields.</p>

<pre><code>class SignInForm &lt; Reform::Form
  property :password, virtual: true
  property :password_confirmation, virtual: true

  validate :password_ok? do
    errors.add(:password, "Password mismatch") if password != password_confirmation
  end
end
</code></pre>

<p>This is discussed in the <em>Authentication</em> chapter of the <a href="https://leanpub.com/trailblazer">Trailblazer book</a>.</p>

<p><span class="divider"></span></p>

<h3 id="reform-validation-validations-for-file-uploads">Validations For File Uploads</h3>
<p><!-- {reform-validation-validations-for-file-uploads-toc} --></p>

<p>In case you‚Äôre processing uploaded files with your form using CarrierWave, Paperclip, Dragonfly or Paperdragon we recommend using the awesome <a href="https://github.com/musaffa/file_validators">file_validators</a> gem for file type and size validations.</p>

<pre><code>class SongForm &lt; Reform::Form
  property :image

  validates :image, file_size: {less_than: 2.megabytes},
    file_content_type: {allow: ['image/jpeg', 'image/png', 'image/gif']}
</code></pre>

<p><span class="divider"></span></p>

<h2 id="reform-rails">Rails</h2>
<p><!-- {reform-rails-toc} --></p>

<p>Reform works with any framework, but comes with additional Rails glue code.</p>

<p><span class="divider"></span></p>

<h3 id="reform-rails-reform-rails">Reform-Rails</h3>
<p><!-- {reform-rails-reform-rails-toc} --></p>

<p>The <code>reform</code> gem itself doesn‚Äôt contain any Rails-specific code but will still work, e.g. for JSON APIs. For extensive Rails support, add the <a href="https://github.com/trailblazer/reform-rails"><code>reform-rails</code> gem</a>.</p>

<pre><code class="language-ruby">gem "reform", "&gt;= 2.2.0"
gem "reform-rails"
</code></pre>

<p>Per default, <code>reform-rails</code> will assume you want <code>ActiveModel::Validations</code> as the validation engine. This will include the following into <code>Reform::Form</code>.</p>

<ul>
  <li><code>Form::ActiveModel</code> for form builder compliance so your form works with <code>form_for</code> and friends.</li>
  <li><code>Reform::Form::ActiveModel::FormBuilderMethods</code> to make Reform consume Rails form builder‚Äôs weird parameters, e.g. <code>{song_attributes: { number: 1 }}</code>.</li>
  <li>Uniqueness validation for <code>ActiveRecord</code>.</li>
</ul>

<p>However, you can also use the new, <a href="#reform-validation-dry-validation">recommended <code>dry-validation</code></a> backend, and you should check that out!</p>

<p>To do so, add the gem to your Gemfile.</p>

<pre><code class="language-ruby">gem "reform", "&gt;= 2.2.0"
gem "reform-rails"
gem "dry-validation"
</code></pre>

<p>And configure Reform in an initializer, e.g. <code>config/initializer/reform.rb</code> to load the new validation backend.</p>

<pre><code class="language-ruby"> Rails.application.config.reform.validations = :dry
</code></pre>

<p>Make sure you use the API when writing dry validations.</p>

<p><span class="divider"></span></p>

<h3 id="reform-rails-uniqueness-validation">Uniqueness Validation</h3>
<p><!-- {reform-rails-uniqueness-validation-toc} --></p>

<p>Both ActiveRecord and Mongoid modules will support ‚Äúnative‚Äù uniqueness support from the model class when you use <code>validates_uniqueness_of</code>. They will provide options like <code>:scope</code>, etc.</p>

<p>You‚Äôre encouraged to use Reform‚Äôs non-writing <code>unique: true</code> validation, though. <a href="#reform-validation">Learn more</a></p>

<p><span class="divider"></span></p>

<h3 id="reform-rails-activemodel-compliance">ActiveModel Compliance</h3>
<p><!-- {reform-rails-activemodel-compliance-toc} --></p>

<p>Forms in Reform can easily be made ActiveModel-compliant.</p>

<p>Note that this step is <em>not</em> necessary in a Rails environment.</p>

<pre><code>class SongForm &lt; Reform::Form
  include Reform::Form::ActiveModel
end
</code></pre>

<p>If you‚Äôre not happy with the <code>model_name</code> result, configure it manually via <code>::model</code>.</p>

<pre><code>class CoverSongForm &lt; Reform::Form
  include Reform::Form::ActiveModel

  model :song
end
</code></pre>

<p><code>::model</code> will configure ActiveModel‚Äôs naming logic. With <code>Composition</code>, this configures the main model of the form and should be called once.</p>

<p>This is especially helpful when your framework tries to render <code>cover_song_path</code> although you want to go with <code>song_path</code>.</p>

<p><span class="divider"></span></p>

<h3 id="reform-rails-formbuilder-support">FormBuilder Support</h3>
<p><!-- {reform-rails-formbuilder-support-toc} --></p>

<p>To make your forms work with all Rails form gems like <code>simple_form</code> or Rails <code>form_for</code> don‚Äôt forget to include the <code>rails-reform</code> gem in your Gemfile.</p>

<pre><code class="language-ruby">gem "reform-rails"
</code></pre>

<p>When using <code>ActiveModel</code> validations, this is all you have to do.</p>

<p><span class="divider"></span></p>

<ul class="navigation">
    <li>FormBuilder Support</li>
    <li id="reform-rails-formbuilder-support-dry-validations">Dry-validations</li>
</ul>

<p>However, if you‚Äôve configured dry-validation as your validation framework you have to include at least the <code>FormBuilderMethods</code> module. This is necessary to translate Rails‚Äô suboptimal songs_attributes weirdness back to normal <code>songs: </code> naming in <code>#validate</code>.</p>

<p>You can configure <code>reform-rails</code> do enable form builder support with Dry-backed forms.</p>

<pre><code># config/development.rb
Rails.application.configure do
  config.reform.enable_active_model_builder_methods = true
end
</code></pre>

<p>The manual way would be as follows.</p>

<pre><code>class SongForm &lt; Reform::Form
  include Reform::Form::ActiveModel
  include Reform::Form::ActiveModel::FormBuilderMethods
end
</code></pre>

<h4 id="simple-form">Simple Form</h4>

<p>If you want full support for <code>simple_form</code> do as follows.</p>

<pre><code>class SongForm &lt; Reform::Form
  include Reform::Form::ActiveModel::ModelReflections
</code></pre>

<p>Including this module will add <code>#column_for_attribute</code> and other methods need by form builders to automatically guess the type of a property.</p>

<p><span class="divider"></span></p>

<h3 id="reform-rails-validation-shortform">Validation Shortform</h3>
<p><!-- {reform-rails-validation-shortform-toc} --></p>

<p>Luckily, this can be shortened as follows.</p>

<pre><code>class SongForm &lt; Reform::Form
  property :title, validates: {presence: true}
  property :length, validates: {numericality: true}
end
</code></pre>

<p>Use <code>properties</code> to bulk-specify fields.</p>

<pre><code>class SongForm &lt; Reform::Form
  properties :title, :length, validates: {presence: true} # both required!
  validates :length, numericality: true
end
</code></pre>

<p><span class="divider"></span></p>

<h3 id="reform-rails-validations-from-models">Validations From Models</h3>
<p><!-- {reform-rails-validations-from-models-toc} --></p>

<p>Sometimes when you still keep validations in your models (which you shouldn‚Äôt) copying them to a form might not feel right. In that case, you can let Reform automatically copy them.</p>

<pre><code>class SongForm &lt; Reform::Form
  property :title

  extend ActiveModel::ModelValidations
  copy_validations_from Song
end
</code></pre>

<p>Note how <code>copy_validations_from</code> copies over the validations allowing you to stay DRY.</p>

<p>This also works with Composition.</p>

<pre><code>class SongForm &lt; Reform::Form
  include Composition
  # ...

  extend ActiveModel::ModelValidations
  copy_validations_from song: Song, band: Band
end
</code></pre>

<p><span class="divider"></span></p>

<h3 id="reform-rails-activerecord-compatibility">ActiveRecord Compatibility</h3>
<p><!-- {reform-rails-activerecord-compatibility-toc} --></p>

<p>Reform provides the following <code>ActiveRecord</code> specific features. They‚Äôre mixed in automatically in a Rails/AR setup.</p>

<ul>
  <li>Uniqueness validations. Use <code>validates_uniqueness_of</code> in your form.</li>
</ul>

<p>As mentioned in the <a href="https://github.com/apotonick/reform#rails-integration">Rails Integration</a> section some Rails 4 setups do not properly load.</p>

<p>You may want to include the module manually then.</p>

<pre><code>class SongForm &lt; Reform::Form
  include Reform::Form::ActiveRecord
</code></pre>

<p><span class="divider"></span></p>

<h3 id="reform-rails-mongoid-compatibility">Mongoid Compatibility</h3>
<p><!-- {reform-rails-mongoid-compatibility-toc} --></p>

<p>Reform provides the following <code>Mongoid</code> specific features. They‚Äôre mixed in automatically in a Rails/Mongoid setup.</p>

<ul>
  <li>Uniqueness validations. Use <code>validates_uniqueness_of</code> in your form.</li>
</ul>

<p>You may want to include the module manually then.</p>

<pre><code>class SongForm &lt; Reform::Form
  include Reform::Form::Mongoid
</code></pre>

<p><span class="divider"></span></p>

<h3 id="reform-rails-troubleshooting">Troubleshooting</h3>
<p><!-- {reform-rails-troubleshooting-toc} --></p>

<ol>
  <li>In case you explicitly <em>don‚Äôt</em> want to have automatic support for <code>ActiveRecord</code> or <code>Mongoid</code> and form builder: <code>require reform/form</code>, only.</li>
  <li>In some setups around Rails 4 the <code>Form::ActiveRecord</code> module is not loaded properly, usually triggering a <code>NoMethodError</code> saying <code>undefined method 'model'</code>. If that happened to you, <code>require 'reform/rails'</code> manually at the bottom of your <code>config/application.rb</code>.</li>
  <li>Mongoid form gets loaded with the gem if <code>Mongoid</code> constant is defined.</li>
</ol>

<p><span class="divider"></span></p>

<h2 id="reform-upgrading-guide">Upgrading Guide</h2>
<p><!-- {reform-upgrading-guide-toc} --></p>

<p>We try to make upgrading as smooth as possible. Here‚Äôs the generic documentation, but don‚Äôt hesitate to ask for <a href="https://trailblazer.zulipchat.com/">help on Zulip</a>.</p>

<p><span class="divider"></span></p>

<h3 id="reform-upgrading-guide-2-2-to-2-3">2.2 to 2.3</h3>
<p><!-- {reform-upgrading-guide-2-2-to-2-3-toc} --></p>

<p>If you have been using dry-validation and you want to upgrade to version 1.x, get ready to change a lot of your code, unfortunately dry-validation API has been completely rewritten so we had to adapt. If instead you have ActiveModel/ActiveRecord the upgrade from 2.2 to 2.3 should be nice and easy.
Please refer to the <a href="https://github.com/trailblazer/reform/blob/master/CHANGES.md">CHANGES</a> in the repo.</p>

<p><span class="divider"></span></p>

<h3 id="reform-upgrading-guide-2-1-to-2-2">2.1 to 2.2</h3>
<p><!-- {reform-upgrading-guide-2-1-to-2-2-toc} --></p>

<p>In a Rails environment with ActiveModel/ActiveRecord, you have to include the <a href="https://github.com/trailblazer/reform-rails">reform-rails</a> gem.</p>

<pre><code>gem "reform"
gem "reform-rails"
</code></pre>

<p><span class="divider"></span></p>

<h3 id="reform-upgrading-guide-1-2-to-2-0">1.2 to 2.0</h3>
<p><!-- {reform-upgrading-guide-1-2-to-2-0-toc} --></p>

<h4 id="validations">Validations</h4>

<p>Validations like <code>validates_acceptance_of</code> are not available anymore, you have to use the new syntax.</p>

<pre><code>validates acceptance: true
</code></pre>

<h4 id="formvalid">Form#valid?</h4>

<p>Using <code>form.valid?</code> is a private concept and was never publicly documented. It is still available (private) but you are strongly recommended to use <code>#validate</code> instead.</p>

<h4 id="formupdate">Form#update!</h4>

<p>Apparently, some people used <code>form.update!({..})</code> to pre-fillout forms. <code>#update!</code> has never been publicly documented and got removed in Reform 2. However, you can achieve the same behavior using the following hack.</p>

<pre><code>Reform::Form.class_eval do
  alias_method :update!, :deserialize
  public :update!
</code></pre>

<h4 id="validation-backend">Validation Backend</h4>

<p>This only is necessary when <em>not</em> using <code>reform/rails</code>, which is automatically loaded in a Rails environment.</p>

<p>In an initializer, e.g. <code>config/initializers/reform.rb</code>.</p>

<pre><code>require "reform/form/active_model/validations"
Reform::Form.class_eval do
  include Reform::Form::ActiveModel::Validations
end
</code></pre>

</div>

                <aside>
                  <span class="deco-purple-cross wow fadeIn"></span>
                </aside>
              </main>

              <div class="d-none d-xl-block col-xl-2 list-group sidebar-scroll order-3">
                <img alt="Trailblazer" class="wow fadeIn" src="/vite/assets/deco1.51110a75.webp" />
                <div class="features" id="reform-overview-features">
  <h3>
    <i class="fas fa-times"></i>
    <span>Overview</span>
  </h3>

  <ul class="vertical menu">
    
      <li>
        <a href="#reform-overview-api">
          <i class="fas fa-arrow-right"></i>
          API
        </a>
      </li>
      
    
      <li>
        <a href="#reform-overview-setup">
          <i class="fas fa-arrow-right"></i>
          Setup
        </a>
      </li>
      
    
      <li>
        <a href="#reform-overview-rendering">
          <i class="fas fa-arrow-right"></i>
          Rendering
        </a>
      </li>
      
    
      <li>
        <a href="#reform-overview-validation">
          <i class="fas fa-arrow-right"></i>
          Validation
        </a>
      </li>
      
    
      <li>
        <a href="#reform-overview-persisting">
          <i class="fas fa-arrow-right"></i>
          Persisting
        </a>
      </li>
      
    
      <li>
        <a href="#reform-overview-installation">
          <i class="fas fa-arrow-right"></i>
          Installation
        </a>
      </li>
      
    
      <li>
        <a href="#reform-overview-design-concepts">
          <i class="fas fa-arrow-right"></i>
          Design Concepts
        </a>
      </li>
      
    
      <li>
        <a href="#reform-overview-architecture">
          <i class="fas fa-arrow-right"></i>
          Architecture
        </a>
      </li>
      
    
  </ul>
</div>

<div class="features" id="reform-api-features">
  <h3>
    <i class="fas fa-times"></i>
    <span>API</span>
  </h3>

  <ul class="vertical menu">
    
      <li>
        <a href="#reform-api-overview">
          <i class="fas fa-arrow-right"></i>
          Overview
        </a>
      </li>
      
    
      <li>
        <a href="#reform-api-form-class">
          <i class="fas fa-arrow-right"></i>
          Form Class
        </a>
      </li>
      
    
      <li>
        <a href="#reform-api-property">
          <i class="fas fa-arrow-right"></i>
          Property
        </a>
      </li>
      
    
      <li>
        <a href="#reform-api-collection">
          <i class="fas fa-arrow-right"></i>
          Collection
        </a>
      </li>
      
    
      <li>
        <a href="#reform-api-nesting">
          <i class="fas fa-arrow-right"></i>
          Nesting
        </a>
      </li>
      
    
      <li>
        <a href="#reform-api-setup">
          <i class="fas fa-arrow-right"></i>
          Setup
        </a>
      </li>
      
    
      <li>
        <a href="#reform-api-validate">
          <i class="fas fa-arrow-right"></i>
          Validate
        </a>
      </li>
      
    
      <li>
        <a href="#reform-api-errors">
          <i class="fas fa-arrow-right"></i>
          Errors
        </a>
      </li>
      
    
      <li>
        <a href="#reform-api-save">
          <i class="fas fa-arrow-right"></i>
          Save
        </a>
      </li>
      
    
      <li>
        <a href="#reform-api-inheritance">
          <i class="fas fa-arrow-right"></i>
          Inheritance
        </a>
      </li>
      
    
      <li>
        <a href="#reform-api-forms-in-modules">
          <i class="fas fa-arrow-right"></i>
          Forms In Modules
        </a>
      </li>
      
    
      <li>
        <a href="#reform-api-dirty-tracker">
          <i class="fas fa-arrow-right"></i>
          Dirty Tracker
        </a>
      </li>
      
    
      <li>
        <a href="#reform-api-deserialization">
          <i class="fas fa-arrow-right"></i>
          Deserialization
        </a>
      </li>
      
    
      <li>
        <a href="#reform-api-population">
          <i class="fas fa-arrow-right"></i>
          Population
        </a>
      </li>
      
    
      <li>
        <a href="#reform-api-inflection">
          <i class="fas fa-arrow-right"></i>
          Inflection
        </a>
      </li>
      
    
  </ul>
</div>

<div class="features" id="reform-options-features">
  <h3>
    <i class="fas fa-times"></i>
    <span>Options</span>
  </h3>

  <ul class="vertical menu">
    
      <li>
        <a href="#reform-options-disposable-api">
          <i class="fas fa-arrow-right"></i>
          Disposable API
        </a>
      </li>
      
    
      <li>
        <a href="#reform-options-virtual-attributes">
          <i class="fas fa-arrow-right"></i>
          Virtual Attributes
        </a>
      </li>
      
    
      <li>
        <a href="#reform-options-access-protection">
          <i class="fas fa-arrow-right"></i>
          Access Protection
        </a>
      </li>
      
    
      <li>
        <a href="#reform-options-coercion">
          <i class="fas fa-arrow-right"></i>
          Coercion
        </a>
      </li>
      
    
      <li>
        <a href="#reform-options-manual-coercion">
          <i class="fas fa-arrow-right"></i>
          Manual Coercion
        </a>
      </li>
      
    
      <li>
        <a href="#reform-options-deserializer">
          <i class="fas fa-arrow-right"></i>
          Deserializer
        </a>
      </li>
      
    
      <li>
        <a href="#reform-options-inheritance">
          <i class="fas fa-arrow-right"></i>
          Inheritance
        </a>
      </li>
      
    
      <li>
        <a href="#reform-options-skip_if">
          <i class="fas fa-arrow-right"></i>
          Skip_if
        </a>
      </li>
      
    
      <li>
        <a href="#reform-options-multiparameter-dates">
          <i class="fas fa-arrow-right"></i>
          Multiparameter Dates
        </a>
      </li>
      
    
  </ul>
</div>

<div class="features" id="reform-data-types-features">
  <h3>
    <i class="fas fa-times"></i>
    <span>Data Types</span>
  </h3>

  <ul class="vertical menu">
    
      <li>
        <a href="#reform-data-types-composition">
          <i class="fas fa-arrow-right"></i>
          Composition
        </a>
      </li>
      
    
      <li>
        <a href="#reform-data-types-hash-fields">
          <i class="fas fa-arrow-right"></i>
          Hash Fields
        </a>
      </li>
      
    
  </ul>
</div>

<div class="features" id="reform-populators-features">
  <h3>
    <i class="fas fa-times"></i>
    <span>Populators</span>
  </h3>

  <ul class="vertical menu">
    
      <li>
        <a href="#reform-populators-populators-the-problem">
          <i class="fas fa-arrow-right"></i>
          Populators: The Problem
        </a>
      </li>
      
    
      <li>
        <a href="#reform-populators-declarative-dsl">
          <i class="fas fa-arrow-right"></i>
          Declarative DSL
        </a>
      </li>
      
    
      <li>
        <a href="#reform-populators-populate_if_empty">
          <i class="fas fa-arrow-right"></i>
          Populate_if_empty
        </a>
      </li>
      
    
      <li>
        <a href="#reform-populators-populate_if_empty-custom">
          <i class="fas fa-arrow-right"></i>
          Populate_if_empty: Custom
        </a>
      </li>
      
    
      <li>
        <a href="#reform-populators-populate_if_empty-arguments">
          <i class="fas fa-arrow-right"></i>
          Populate_if_empty: Arguments
        </a>
      </li>
      
    
      <li>
        <a href="#reform-populators-populator">
          <i class="fas fa-arrow-right"></i>
          Populator
        </a>
      </li>
      
    
      <li>
        <a href="#reform-populators-populator-collections">
          <i class="fas fa-arrow-right"></i>
          Populator: Collections
        </a>
      </li>
      
    
      <li>
        <a href="#reform-populators-populator-return-value">
          <i class="fas fa-arrow-right"></i>
          Populator: Return Value
        </a>
      </li>
      
    
      <li>
        <a href="#reform-populators-populator-avoiding-index">
          <i class="fas fa-arrow-right"></i>
          Populator: Avoiding Index
        </a>
      </li>
      
    
      <li>
        <a href="#reform-populators-populator-single-property">
          <i class="fas fa-arrow-right"></i>
          Populator: Single Property
        </a>
      </li>
      
    
      <li>
        <a href="#reform-populators-populator-match-by-id">
          <i class="fas fa-arrow-right"></i>
          Populator: Match by ID
        </a>
      </li>
      
    
      <li>
        <a href="#reform-populators-delete">
          <i class="fas fa-arrow-right"></i>
          Delete
        </a>
      </li>
      
    
      <li>
        <a href="#reform-populators-skip">
          <i class="fas fa-arrow-right"></i>
          Skip
        </a>
      </li>
      
    
      <li>
        <a href="#reform-populators-uninitialized-collections">
          <i class="fas fa-arrow-right"></i>
          Uninitialized Collections
        </a>
      </li>
      
    
  </ul>
</div>

<div class="features" id="reform-prepopulating-features">
  <h3>
    <i class="fas fa-times"></i>
    <span>Prepopulating</span>
  </h3>

  <ul class="vertical menu">
    
      <li>
        <a href="#reform-prepopulating-configuration">
          <i class="fas fa-arrow-right"></i>
          Configuration
        </a>
      </li>
      
    
      <li>
        <a href="#reform-prepopulating-invocation">
          <i class="fas fa-arrow-right"></i>
          Invocation
        </a>
      </li>
      
    
      <li>
        <a href="#reform-prepopulating-prepopulate-is-not-populate">
          <i class="fas fa-arrow-right"></i>
          Prepopulate is not Populate
        </a>
      </li>
      
    
      <li>
        <a href="#reform-prepopulating-options">
          <i class="fas fa-arrow-right"></i>
          Options
        </a>
      </li>
      
    
      <li>
        <a href="#reform-prepopulating-execution">
          <i class="fas fa-arrow-right"></i>
          Execution
        </a>
      </li>
      
    
      <li>
        <a href="#reform-prepopulating-overriding">
          <i class="fas fa-arrow-right"></i>
          Overriding
        </a>
      </li>
      
    
      <li>
        <a href="#reform-prepopulating-defaults">
          <i class="fas fa-arrow-right"></i>
          Defaults
        </a>
      </li>
      
    
  </ul>
</div>

<div class="features" id="reform-validation-features">
  <h3>
    <i class="fas fa-times"></i>
    <span>Validation</span>
  </h3>

  <ul class="vertical menu">
    
      <li>
        <a href="#reform-validation-validation-engine">
          <i class="fas fa-arrow-right"></i>
          Validation Engine
        </a>
      </li>
      
    
      <li>
        <a href="#reform-validation-validation-groups">
          <i class="fas fa-arrow-right"></i>
          Validation Groups
        </a>
      </li>
      
    
      <li>
        <a href="#reform-validation-dry-validation">
          <i class="fas fa-arrow-right"></i>
          Dry-validation
        </a>
      </li>
      
    
      <li>
        <a href="#reform-validation-activemodel">
          <i class="fas fa-arrow-right"></i>
          ActiveModel
        </a>
      </li>
      
    
      <li>
        <a href="#reform-validation-validations-for-file-uploads">
          <i class="fas fa-arrow-right"></i>
          Validations For File Uploads
        </a>
      </li>
      
    
  </ul>
</div>

<div class="features" id="reform-rails-features">
  <h3>
    <i class="fas fa-times"></i>
    <span>Rails</span>
  </h3>

  <ul class="vertical menu">
    
      <li>
        <a href="#reform-rails-reform-rails">
          <i class="fas fa-arrow-right"></i>
          Reform-Rails
        </a>
      </li>
      
    
      <li>
        <a href="#reform-rails-uniqueness-validation">
          <i class="fas fa-arrow-right"></i>
          Uniqueness Validation
        </a>
      </li>
      
    
      <li>
        <a href="#reform-rails-activemodel-compliance">
          <i class="fas fa-arrow-right"></i>
          ActiveModel Compliance
        </a>
      </li>
      
    
      <li>
        <a href="#reform-rails-formbuilder-support">
          <i class="fas fa-arrow-right"></i>
          FormBuilder Support
        </a>
      </li>
      
        
        <li class="sub-item">
          <a href="#reform-rails-formbuilder-support-dry-validations">Dry-validations</a>
        </li>
      
    
      <li>
        <a href="#reform-rails-validation-shortform">
          <i class="fas fa-arrow-right"></i>
          Validation Shortform
        </a>
      </li>
      
    
      <li>
        <a href="#reform-rails-validations-from-models">
          <i class="fas fa-arrow-right"></i>
          Validations From Models
        </a>
      </li>
      
    
      <li>
        <a href="#reform-rails-activerecord-compatibility">
          <i class="fas fa-arrow-right"></i>
          ActiveRecord Compatibility
        </a>
      </li>
      
    
      <li>
        <a href="#reform-rails-mongoid-compatibility">
          <i class="fas fa-arrow-right"></i>
          Mongoid Compatibility
        </a>
      </li>
      
    
      <li>
        <a href="#reform-rails-troubleshooting">
          <i class="fas fa-arrow-right"></i>
          Troubleshooting
        </a>
      </li>
      
    
  </ul>
</div>

<div class="features" id="reform-upgrading-guide-features">
  <h3>
    <i class="fas fa-times"></i>
    <span>Upgrading Guide</span>
  </h3>

  <ul class="vertical menu">
    
      <li>
        <a href="#reform-upgrading-guide-2-2-to-2-3">
          <i class="fas fa-arrow-right"></i>
          2.2 to 2.3
        </a>
      </li>
      
    
      <li>
        <a href="#reform-upgrading-guide-2-1-to-2-2">
          <i class="fas fa-arrow-right"></i>
          2.1 to 2.2
        </a>
      </li>
      
    
      <li>
        <a href="#reform-upgrading-guide-1-2-to-2-0">
          <i class="fas fa-arrow-right"></i>
          1.2 to 2.0
        </a>
      </li>
      
    
  </ul>
</div>

              </div>
            </div>
          </div>
        </section>
      </main>

      <footer class="trailblazer-footer">
  <div class="container">
    <div class="row align-items-center">
      <div class="col-md-3 col-lg-2">
        <a href="/2.1/index.html" class="logo-footer">Trailblazer</a>
      </div>
      <div class="col-md-6 col-lg-8">
        <nav>
          <ul class="navbar-nav documentation-nav-items">
  <li>
    <a class="nav-item nav-link active" href="/2.1/docs/trailblazer.html">
      <i class="fas fa-arrow-right"></i>
      DOCS
    </a>
  </li>

  <li>
    <a class="nav-item nav-link " href="https://dev.to/trailblazer">BLOG</a>
  </li>

  <li class="">
    <a class="nav-item nav-link " href="/2.1/about_us.html">ABOUT US</a>
  </li>

  <li>
    <a class="nav-item nav-link " href="/2.1/learn.html">LEARN</a>
  </li>

  <li class="">
    <a class="nav-item nav-link" href="/2.0/index.html">
      <i class="fas fa-arrow-right"></i>
      2.0
    </a>
  </li>

  <li>
    <a class="nav-item nav-link" href="https://trailblazer.zulipchat.com" target="_blank">
      <i class="fas fa-comments"></i>
      CHAT
    </a>
  </li>

  <!--
  
  -->
</ul>

        </nav>
      </div>
      <div class="col-md-3 col-lg-2">
        <ul class="social purple">
          <li>
            <a href="https://github.com/trailblazer" target="_blank"><i class="fab fa-github-square"></i></a>
          </li>
          <li>
            <a href="https://www.facebook.com/trailblazer.to" target="_blank"><i class="fab fa-facebook-square"></i></a>
          </li>
          <li>
            <a href="https://twitter.com/trailblazer_to" target="_blank"><i class="fab fa-twitter-square"></i></a>
          </li>
        </ul>
      </div>
    </div>
  </div>
</footer>

    </div>
  </body>
</html>
